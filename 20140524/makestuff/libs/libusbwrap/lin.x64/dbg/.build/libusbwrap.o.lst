   1              		.file	"libusbwrap.c"
   2              		.text
   3              	.Ltext0:
   5              	queueSize:
   6              	.LFB9:
   7              		.file 1 "unbounded_queue.h"
   1:unbounded_queue.h **** #ifndef UNBOUNDED_QUEUE_H
   2:unbounded_queue.h **** #define UNBOUNDED_QUEUE_H
   3:unbounded_queue.h **** 
   4:unbounded_queue.h **** #include "libusbwrap.h"
   5:unbounded_queue.h **** 
   6:unbounded_queue.h **** #ifdef __cplusplus
   7:unbounded_queue.h **** extern "C" {
   8:unbounded_queue.h **** #endif
   9:unbounded_queue.h **** 
  10:unbounded_queue.h **** 	typedef const void* Item;
  11:unbounded_queue.h **** 	typedef Item (*CreateFunc)(void);
  12:unbounded_queue.h **** 	typedef void (*DestroyFunc)(Item);
  13:unbounded_queue.h **** 
  14:unbounded_queue.h **** 	struct UnboundedQueue {
  15:unbounded_queue.h **** 		Item *itemArray;
  16:unbounded_queue.h **** 		size_t capacity;
  17:unbounded_queue.h **** 		size_t putIndex;
  18:unbounded_queue.h **** 		size_t takeIndex;
  19:unbounded_queue.h **** 		size_t numItems;
  20:unbounded_queue.h **** 		CreateFunc createFunc;
  21:unbounded_queue.h **** 		DestroyFunc destroyFunc;
  22:unbounded_queue.h **** 	};
  23:unbounded_queue.h **** 
  24:unbounded_queue.h **** 	USBStatus queueInit(
  25:unbounded_queue.h **** 		struct UnboundedQueue *self, size_t capacity, CreateFunc createFunc, DestroyFunc destroyFunc
  26:unbounded_queue.h **** 	);
  27:unbounded_queue.h **** 	USBStatus queuePut(
  28:unbounded_queue.h **** 		struct UnboundedQueue *self, Item *item  // never blocks, can ENOMEM
  29:unbounded_queue.h **** 	);
  30:unbounded_queue.h **** 	void queueCommitPut(
  31:unbounded_queue.h **** 		struct UnboundedQueue *self
  32:unbounded_queue.h **** 	);
  33:unbounded_queue.h **** 	USBStatus queueTake(
  34:unbounded_queue.h **** 		struct UnboundedQueue *self, Item *item  // returns NULL on empty
  35:unbounded_queue.h **** 	);
  36:unbounded_queue.h **** 	void queueCommitTake(
  37:unbounded_queue.h **** 		struct UnboundedQueue *self
  38:unbounded_queue.h **** 	);
  39:unbounded_queue.h **** 	void queueDestroy(
  40:unbounded_queue.h **** 		struct UnboundedQueue *self
  41:unbounded_queue.h **** 	);
  42:unbounded_queue.h **** 	static inline size_t queueSize(const struct UnboundedQueue *self) {
   8              		.loc 1 42 0
   9              		.cfi_startproc
  10 0000 55       		pushq	%rbp
  11              		.cfi_def_cfa_offset 16
  12              		.cfi_offset 6, -16
  13 0001 4889E5   		movq	%rsp, %rbp
  14              		.cfi_def_cfa_register 6
  15 0004 48897DF8 		movq	%rdi, -8(%rbp)
  43:unbounded_queue.h **** 		return self->numItems;
  16              		.loc 1 43 0
  17 0008 488B45F8 		movq	-8(%rbp), %rax
  18 000c 488B4020 		movq	32(%rax), %rax
  44:unbounded_queue.h **** 	}
  19              		.loc 1 44 0
  20 0010 5D       		popq	%rbp
  21              		.cfi_def_cfa 7, 8
  22 0011 C3       		ret
  23              		.cfi_endproc
  24              	.LFE9:
  27              	libusb_fill_bulk_transfer:
  28              	.LFB15:
  29              		.file 2 "/usr/include/libusb-1.0/libusb.h"
   1:/usr/include/libusb-1.0/libusb.h **** /*
   2:/usr/include/libusb-1.0/libusb.h ****  * Public libusb header file
   3:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2001 Johannes Erdfelt <johannes@erdfelt.com>
   4:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2007-2008 Daniel Drake <dsd@gentoo.org>
   5:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2012 Pete Batard <pete@akeo.ie>
   6:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2012 Nathan Hjelm <hjelmn@cs.unm.edu>
   7:/usr/include/libusb-1.0/libusb.h ****  * For more information, please visit: http://libusb.info
   8:/usr/include/libusb-1.0/libusb.h ****  *
   9:/usr/include/libusb-1.0/libusb.h ****  * This library is free software; you can redistribute it and/or
  10:/usr/include/libusb-1.0/libusb.h ****  * modify it under the terms of the GNU Lesser General Public
  11:/usr/include/libusb-1.0/libusb.h ****  * License as published by the Free Software Foundation; either
  12:/usr/include/libusb-1.0/libusb.h ****  * version 2.1 of the License, or (at your option) any later version.
  13:/usr/include/libusb-1.0/libusb.h ****  *
  14:/usr/include/libusb-1.0/libusb.h ****  * This library is distributed in the hope that it will be useful,
  15:/usr/include/libusb-1.0/libusb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:/usr/include/libusb-1.0/libusb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17:/usr/include/libusb-1.0/libusb.h ****  * Lesser General Public License for more details.
  18:/usr/include/libusb-1.0/libusb.h ****  *
  19:/usr/include/libusb-1.0/libusb.h ****  * You should have received a copy of the GNU Lesser General Public
  20:/usr/include/libusb-1.0/libusb.h ****  * License along with this library; if not, write to the Free Software
  21:/usr/include/libusb-1.0/libusb.h ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  22:/usr/include/libusb-1.0/libusb.h ****  */
  23:/usr/include/libusb-1.0/libusb.h **** 
  24:/usr/include/libusb-1.0/libusb.h **** #ifndef LIBUSB_H
  25:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_H
  26:/usr/include/libusb-1.0/libusb.h **** 
  27:/usr/include/libusb-1.0/libusb.h **** #ifdef _MSC_VER
  28:/usr/include/libusb-1.0/libusb.h **** /* on MS environments, the inline keyword is available in C++ only */
  29:/usr/include/libusb-1.0/libusb.h **** #if !defined(__cplusplus)
  30:/usr/include/libusb-1.0/libusb.h **** #define inline __inline
  31:/usr/include/libusb-1.0/libusb.h **** #endif
  32:/usr/include/libusb-1.0/libusb.h **** /* ssize_t is also not available (copy/paste from MinGW) */
  33:/usr/include/libusb-1.0/libusb.h **** #ifndef _SSIZE_T_DEFINED
  34:/usr/include/libusb-1.0/libusb.h **** #define _SSIZE_T_DEFINED
  35:/usr/include/libusb-1.0/libusb.h **** #undef ssize_t
  36:/usr/include/libusb-1.0/libusb.h **** #ifdef _WIN64
  37:/usr/include/libusb-1.0/libusb.h ****   typedef __int64 ssize_t;
  38:/usr/include/libusb-1.0/libusb.h **** #else
  39:/usr/include/libusb-1.0/libusb.h ****   typedef int ssize_t;
  40:/usr/include/libusb-1.0/libusb.h **** #endif /* _WIN64 */
  41:/usr/include/libusb-1.0/libusb.h **** #endif /* _SSIZE_T_DEFINED */
  42:/usr/include/libusb-1.0/libusb.h **** #endif /* _MSC_VER */
  43:/usr/include/libusb-1.0/libusb.h **** 
  44:/usr/include/libusb-1.0/libusb.h **** /* stdint.h is not available on older MSVC */
  45:/usr/include/libusb-1.0/libusb.h **** #if defined(_MSC_VER) && (_MSC_VER < 1600) && (!defined(_STDINT)) && (!defined(_STDINT_H))
  46:/usr/include/libusb-1.0/libusb.h **** typedef unsigned __int8   uint8_t;
  47:/usr/include/libusb-1.0/libusb.h **** typedef unsigned __int16  uint16_t;
  48:/usr/include/libusb-1.0/libusb.h **** typedef unsigned __int32  uint32_t;
  49:/usr/include/libusb-1.0/libusb.h **** #else
  50:/usr/include/libusb-1.0/libusb.h **** #include <stdint.h>
  51:/usr/include/libusb-1.0/libusb.h **** #endif
  52:/usr/include/libusb-1.0/libusb.h **** 
  53:/usr/include/libusb-1.0/libusb.h **** #if !defined(_WIN32_WCE)
  54:/usr/include/libusb-1.0/libusb.h **** #include <sys/types.h>
  55:/usr/include/libusb-1.0/libusb.h **** #endif
  56:/usr/include/libusb-1.0/libusb.h **** 
  57:/usr/include/libusb-1.0/libusb.h **** #if defined(__linux__) || defined(__APPLE__) || defined(__CYGWIN__) || defined(__HAIKU__)
  58:/usr/include/libusb-1.0/libusb.h **** #include <sys/time.h>
  59:/usr/include/libusb-1.0/libusb.h **** #endif
  60:/usr/include/libusb-1.0/libusb.h **** 
  61:/usr/include/libusb-1.0/libusb.h **** #include <time.h>
  62:/usr/include/libusb-1.0/libusb.h **** #include <limits.h>
  63:/usr/include/libusb-1.0/libusb.h **** 
  64:/usr/include/libusb-1.0/libusb.h **** /* 'interface' might be defined as a macro on Windows, so we need to
  65:/usr/include/libusb-1.0/libusb.h ****  * undefine it so as not to break the current libusb API, because
  66:/usr/include/libusb-1.0/libusb.h ****  * libusb_config_descriptor has an 'interface' member
  67:/usr/include/libusb-1.0/libusb.h ****  * As this can be problematic if you include windows.h after libusb.h
  68:/usr/include/libusb-1.0/libusb.h ****  * in your sources, we force windows.h to be included first. */
  69:/usr/include/libusb-1.0/libusb.h **** #if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
  70:/usr/include/libusb-1.0/libusb.h **** #include <windows.h>
  71:/usr/include/libusb-1.0/libusb.h **** #if defined(interface)
  72:/usr/include/libusb-1.0/libusb.h **** #undef interface
  73:/usr/include/libusb-1.0/libusb.h **** #endif
  74:/usr/include/libusb-1.0/libusb.h **** #if !defined(__CYGWIN__)
  75:/usr/include/libusb-1.0/libusb.h **** #include <winsock.h>
  76:/usr/include/libusb-1.0/libusb.h **** #endif
  77:/usr/include/libusb-1.0/libusb.h **** #endif
  78:/usr/include/libusb-1.0/libusb.h **** 
  79:/usr/include/libusb-1.0/libusb.h **** #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
  80:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DEPRECATED_FOR(f) \
  81:/usr/include/libusb-1.0/libusb.h ****   __attribute__((deprecated("Use " #f " instead")))
  82:/usr/include/libusb-1.0/libusb.h **** #else
  83:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DEPRECATED_FOR(f)
  84:/usr/include/libusb-1.0/libusb.h **** #endif /* __GNUC__ */
  85:/usr/include/libusb-1.0/libusb.h **** 
  86:/usr/include/libusb-1.0/libusb.h **** /** \def LIBUSB_CALL
  87:/usr/include/libusb-1.0/libusb.h ****  * \ingroup libusb_misc
  88:/usr/include/libusb-1.0/libusb.h ****  * libusb's Windows calling convention.
  89:/usr/include/libusb-1.0/libusb.h ****  *
  90:/usr/include/libusb-1.0/libusb.h ****  * Under Windows, the selection of available compilers and configurations
  91:/usr/include/libusb-1.0/libusb.h ****  * means that, unlike other platforms, there is not <em>one true calling
  92:/usr/include/libusb-1.0/libusb.h ****  * convention</em> (calling convention: the manner in which parameters are
  93:/usr/include/libusb-1.0/libusb.h ****  * passed to functions in the generated assembly code).
  94:/usr/include/libusb-1.0/libusb.h ****  *
  95:/usr/include/libusb-1.0/libusb.h ****  * Matching the Windows API itself, libusb uses the WINAPI convention (which
  96:/usr/include/libusb-1.0/libusb.h ****  * translates to the <tt>stdcall</tt> convention) and guarantees that the
  97:/usr/include/libusb-1.0/libusb.h ****  * library is compiled in this way. The public header file also includes
  98:/usr/include/libusb-1.0/libusb.h ****  * appropriate annotations so that your own software will use the right
  99:/usr/include/libusb-1.0/libusb.h ****  * convention, even if another convention is being used by default within
 100:/usr/include/libusb-1.0/libusb.h ****  * your codebase.
 101:/usr/include/libusb-1.0/libusb.h ****  *
 102:/usr/include/libusb-1.0/libusb.h ****  * The one consideration that you must apply in your software is to mark
 103:/usr/include/libusb-1.0/libusb.h ****  * all functions which you use as libusb callbacks with this LIBUSB_CALL
 104:/usr/include/libusb-1.0/libusb.h ****  * annotation, so that they too get compiled for the correct calling
 105:/usr/include/libusb-1.0/libusb.h ****  * convention.
 106:/usr/include/libusb-1.0/libusb.h ****  *
 107:/usr/include/libusb-1.0/libusb.h ****  * On non-Windows operating systems, this macro is defined as nothing. This
 108:/usr/include/libusb-1.0/libusb.h ****  * means that you can apply it to your code without worrying about
 109:/usr/include/libusb-1.0/libusb.h ****  * cross-platform compatibility.
 110:/usr/include/libusb-1.0/libusb.h ****  */
 111:/usr/include/libusb-1.0/libusb.h **** /* LIBUSB_CALL must be defined on both definition and declaration of libusb
 112:/usr/include/libusb-1.0/libusb.h ****  * functions. You'd think that declaration would be enough, but cygwin will
 113:/usr/include/libusb-1.0/libusb.h ****  * complain about conflicting types unless both are marked this way.
 114:/usr/include/libusb-1.0/libusb.h ****  * The placement of this macro is important too; it must appear after the
 115:/usr/include/libusb-1.0/libusb.h ****  * return type, before the function name. See internal documentation for
 116:/usr/include/libusb-1.0/libusb.h ****  * API_EXPORTED.
 117:/usr/include/libusb-1.0/libusb.h ****  */
 118:/usr/include/libusb-1.0/libusb.h **** #if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
 119:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CALL WINAPI
 120:/usr/include/libusb-1.0/libusb.h **** #else
 121:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CALL
 122:/usr/include/libusb-1.0/libusb.h **** #endif
 123:/usr/include/libusb-1.0/libusb.h **** 
 124:/usr/include/libusb-1.0/libusb.h **** /** \def LIBUSB_API_VERSION
 125:/usr/include/libusb-1.0/libusb.h ****  * \ingroup libusb_misc
 126:/usr/include/libusb-1.0/libusb.h ****  * libusb's API version.
 127:/usr/include/libusb-1.0/libusb.h ****  *
 128:/usr/include/libusb-1.0/libusb.h ****  * Since version 1.0.13, to help with feature detection, libusb defines
 129:/usr/include/libusb-1.0/libusb.h ****  * a LIBUSB_API_VERSION macro that gets increased every time there is a
 130:/usr/include/libusb-1.0/libusb.h ****  * significant change to the API, such as the introduction of a new call,
 131:/usr/include/libusb-1.0/libusb.h ****  * the definition of a new macro/enum member, or any other element that
 132:/usr/include/libusb-1.0/libusb.h ****  * libusb applications may want to detect at compilation time.
 133:/usr/include/libusb-1.0/libusb.h ****  *
 134:/usr/include/libusb-1.0/libusb.h ****  * The macro is typically used in an application as follows:
 135:/usr/include/libusb-1.0/libusb.h ****  * \code
 136:/usr/include/libusb-1.0/libusb.h ****  * #if defined(LIBUSB_API_VERSION) && (LIBUSB_API_VERSION >= 0x01001234)
 137:/usr/include/libusb-1.0/libusb.h ****  * // Use one of the newer features from the libusb API
 138:/usr/include/libusb-1.0/libusb.h ****  * #endif
 139:/usr/include/libusb-1.0/libusb.h ****  * \endcode
 140:/usr/include/libusb-1.0/libusb.h ****  *
 141:/usr/include/libusb-1.0/libusb.h ****  * Internally, LIBUSB_API_VERSION is defined as follows:
 142:/usr/include/libusb-1.0/libusb.h ****  * (libusb major << 24) | (libusb minor << 16) | (16 bit incremental)
 143:/usr/include/libusb-1.0/libusb.h ****  */
 144:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_API_VERSION 0x01000105
 145:/usr/include/libusb-1.0/libusb.h **** 
 146:/usr/include/libusb-1.0/libusb.h **** /* The following is kept for compatibility, but will be deprecated in the future */
 147:/usr/include/libusb-1.0/libusb.h **** #define LIBUSBX_API_VERSION LIBUSB_API_VERSION
 148:/usr/include/libusb-1.0/libusb.h **** 
 149:/usr/include/libusb-1.0/libusb.h **** #ifdef __cplusplus
 150:/usr/include/libusb-1.0/libusb.h **** extern "C" {
 151:/usr/include/libusb-1.0/libusb.h **** #endif
 152:/usr/include/libusb-1.0/libusb.h **** 
 153:/usr/include/libusb-1.0/libusb.h **** /**
 154:/usr/include/libusb-1.0/libusb.h ****  * \ingroup libusb_misc
 155:/usr/include/libusb-1.0/libusb.h ****  * Convert a 16-bit value from host-endian to little-endian format. On
 156:/usr/include/libusb-1.0/libusb.h ****  * little endian systems, this function does nothing. On big endian systems,
 157:/usr/include/libusb-1.0/libusb.h ****  * the bytes are swapped.
 158:/usr/include/libusb-1.0/libusb.h ****  * \param x the host-endian value to convert
 159:/usr/include/libusb-1.0/libusb.h ****  * \returns the value in little-endian byte order
 160:/usr/include/libusb-1.0/libusb.h ****  */
 161:/usr/include/libusb-1.0/libusb.h **** static inline uint16_t libusb_cpu_to_le16(const uint16_t x)
 162:/usr/include/libusb-1.0/libusb.h **** {
 163:/usr/include/libusb-1.0/libusb.h **** 	union {
 164:/usr/include/libusb-1.0/libusb.h **** 		uint8_t  b8[2];
 165:/usr/include/libusb-1.0/libusb.h **** 		uint16_t b16;
 166:/usr/include/libusb-1.0/libusb.h **** 	} _tmp;
 167:/usr/include/libusb-1.0/libusb.h **** 	_tmp.b8[1] = (uint8_t) (x >> 8);
 168:/usr/include/libusb-1.0/libusb.h **** 	_tmp.b8[0] = (uint8_t) (x & 0xff);
 169:/usr/include/libusb-1.0/libusb.h **** 	return _tmp.b16;
 170:/usr/include/libusb-1.0/libusb.h **** }
 171:/usr/include/libusb-1.0/libusb.h **** 
 172:/usr/include/libusb-1.0/libusb.h **** /** \def libusb_le16_to_cpu
 173:/usr/include/libusb-1.0/libusb.h ****  * \ingroup libusb_misc
 174:/usr/include/libusb-1.0/libusb.h ****  * Convert a 16-bit value from little-endian to host-endian format. On
 175:/usr/include/libusb-1.0/libusb.h ****  * little endian systems, this function does nothing. On big endian systems,
 176:/usr/include/libusb-1.0/libusb.h ****  * the bytes are swapped.
 177:/usr/include/libusb-1.0/libusb.h ****  * \param x the little-endian value to convert
 178:/usr/include/libusb-1.0/libusb.h ****  * \returns the value in host-endian byte order
 179:/usr/include/libusb-1.0/libusb.h ****  */
 180:/usr/include/libusb-1.0/libusb.h **** #define libusb_le16_to_cpu libusb_cpu_to_le16
 181:/usr/include/libusb-1.0/libusb.h **** 
 182:/usr/include/libusb-1.0/libusb.h **** /* standard USB stuff */
 183:/usr/include/libusb-1.0/libusb.h **** 
 184:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 185:/usr/include/libusb-1.0/libusb.h ****  * Device and/or Interface Class codes */
 186:/usr/include/libusb-1.0/libusb.h **** enum libusb_class_code {
 187:/usr/include/libusb-1.0/libusb.h **** 	/** In the context of a \ref libusb_device_descriptor "device descriptor",
 188:/usr/include/libusb-1.0/libusb.h **** 	 * this bDeviceClass value indicates that each interface specifies its
 189:/usr/include/libusb-1.0/libusb.h **** 	 * own class information and all interfaces operate independently.
 190:/usr/include/libusb-1.0/libusb.h **** 	 */
 191:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PER_INTERFACE = 0,
 192:/usr/include/libusb-1.0/libusb.h **** 
 193:/usr/include/libusb-1.0/libusb.h **** 	/** Audio class */
 194:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_AUDIO = 1,
 195:/usr/include/libusb-1.0/libusb.h **** 
 196:/usr/include/libusb-1.0/libusb.h **** 	/** Communications class */
 197:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_COMM = 2,
 198:/usr/include/libusb-1.0/libusb.h **** 
 199:/usr/include/libusb-1.0/libusb.h **** 	/** Human Interface Device class */
 200:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_HID = 3,
 201:/usr/include/libusb-1.0/libusb.h **** 
 202:/usr/include/libusb-1.0/libusb.h **** 	/** Physical */
 203:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PHYSICAL = 5,
 204:/usr/include/libusb-1.0/libusb.h **** 
 205:/usr/include/libusb-1.0/libusb.h **** 	/** Printer class */
 206:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PRINTER = 7,
 207:/usr/include/libusb-1.0/libusb.h **** 
 208:/usr/include/libusb-1.0/libusb.h **** 	/** Image class */
 209:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PTP = 6, /* legacy name from libusb-0.1 usb.h */
 210:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_IMAGE = 6,
 211:/usr/include/libusb-1.0/libusb.h **** 
 212:/usr/include/libusb-1.0/libusb.h **** 	/** Mass storage class */
 213:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_MASS_STORAGE = 8,
 214:/usr/include/libusb-1.0/libusb.h **** 
 215:/usr/include/libusb-1.0/libusb.h **** 	/** Hub class */
 216:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_HUB = 9,
 217:/usr/include/libusb-1.0/libusb.h **** 
 218:/usr/include/libusb-1.0/libusb.h **** 	/** Data class */
 219:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_DATA = 10,
 220:/usr/include/libusb-1.0/libusb.h **** 
 221:/usr/include/libusb-1.0/libusb.h **** 	/** Smart Card */
 222:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_SMART_CARD = 0x0b,
 223:/usr/include/libusb-1.0/libusb.h **** 
 224:/usr/include/libusb-1.0/libusb.h **** 	/** Content Security */
 225:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_CONTENT_SECURITY = 0x0d,
 226:/usr/include/libusb-1.0/libusb.h **** 
 227:/usr/include/libusb-1.0/libusb.h **** 	/** Video */
 228:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_VIDEO = 0x0e,
 229:/usr/include/libusb-1.0/libusb.h **** 
 230:/usr/include/libusb-1.0/libusb.h **** 	/** Personal Healthcare */
 231:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PERSONAL_HEALTHCARE = 0x0f,
 232:/usr/include/libusb-1.0/libusb.h **** 
 233:/usr/include/libusb-1.0/libusb.h **** 	/** Diagnostic Device */
 234:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_DIAGNOSTIC_DEVICE = 0xdc,
 235:/usr/include/libusb-1.0/libusb.h **** 
 236:/usr/include/libusb-1.0/libusb.h **** 	/** Wireless class */
 237:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_WIRELESS = 0xe0,
 238:/usr/include/libusb-1.0/libusb.h **** 
 239:/usr/include/libusb-1.0/libusb.h **** 	/** Application class */
 240:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_APPLICATION = 0xfe,
 241:/usr/include/libusb-1.0/libusb.h **** 
 242:/usr/include/libusb-1.0/libusb.h **** 	/** Class is vendor-specific */
 243:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_VENDOR_SPEC = 0xff
 244:/usr/include/libusb-1.0/libusb.h **** };
 245:/usr/include/libusb-1.0/libusb.h **** 
 246:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 247:/usr/include/libusb-1.0/libusb.h ****  * Descriptor types as defined by the USB specification. */
 248:/usr/include/libusb-1.0/libusb.h **** enum libusb_descriptor_type {
 249:/usr/include/libusb-1.0/libusb.h **** 	/** Device descriptor. See libusb_device_descriptor. */
 250:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_DEVICE = 0x01,
 251:/usr/include/libusb-1.0/libusb.h **** 
 252:/usr/include/libusb-1.0/libusb.h **** 	/** Configuration descriptor. See libusb_config_descriptor. */
 253:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_CONFIG = 0x02,
 254:/usr/include/libusb-1.0/libusb.h **** 
 255:/usr/include/libusb-1.0/libusb.h **** 	/** String descriptor */
 256:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_STRING = 0x03,
 257:/usr/include/libusb-1.0/libusb.h **** 
 258:/usr/include/libusb-1.0/libusb.h **** 	/** Interface descriptor. See libusb_interface_descriptor. */
 259:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_INTERFACE = 0x04,
 260:/usr/include/libusb-1.0/libusb.h **** 
 261:/usr/include/libusb-1.0/libusb.h **** 	/** Endpoint descriptor. See libusb_endpoint_descriptor. */
 262:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_ENDPOINT = 0x05,
 263:/usr/include/libusb-1.0/libusb.h **** 
 264:/usr/include/libusb-1.0/libusb.h **** 	/** BOS descriptor */
 265:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_BOS = 0x0f,
 266:/usr/include/libusb-1.0/libusb.h **** 
 267:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability descriptor */
 268:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_DEVICE_CAPABILITY = 0x10,
 269:/usr/include/libusb-1.0/libusb.h **** 
 270:/usr/include/libusb-1.0/libusb.h **** 	/** HID descriptor */
 271:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_HID = 0x21,
 272:/usr/include/libusb-1.0/libusb.h **** 
 273:/usr/include/libusb-1.0/libusb.h **** 	/** HID report descriptor */
 274:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_REPORT = 0x22,
 275:/usr/include/libusb-1.0/libusb.h **** 
 276:/usr/include/libusb-1.0/libusb.h **** 	/** Physical descriptor */
 277:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_PHYSICAL = 0x23,
 278:/usr/include/libusb-1.0/libusb.h **** 
 279:/usr/include/libusb-1.0/libusb.h **** 	/** Hub descriptor */
 280:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_HUB = 0x29,
 281:/usr/include/libusb-1.0/libusb.h **** 
 282:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed Hub descriptor */
 283:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_SUPERSPEED_HUB = 0x2a,
 284:/usr/include/libusb-1.0/libusb.h **** 
 285:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed Endpoint Companion descriptor */
 286:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_SS_ENDPOINT_COMPANION = 0x30
 287:/usr/include/libusb-1.0/libusb.h **** };
 288:/usr/include/libusb-1.0/libusb.h **** 
 289:/usr/include/libusb-1.0/libusb.h **** /* Descriptor sizes per descriptor type */
 290:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_DEVICE_SIZE			18
 291:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_CONFIG_SIZE			9
 292:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_INTERFACE_SIZE		9
 293:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_ENDPOINT_SIZE			7
 294:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_ENDPOINT_AUDIO_SIZE		9	/* Audio extension */
 295:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_HUB_NONVAR_SIZE		7
 296:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE	6
 297:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_BOS_SIZE			5
 298:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_DEVICE_CAPABILITY_SIZE	3
 299:/usr/include/libusb-1.0/libusb.h **** 
 300:/usr/include/libusb-1.0/libusb.h **** /* BOS descriptor sizes */
 301:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_USB_2_0_EXTENSION_SIZE	7
 302:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE	10
 303:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_CONTAINER_ID_SIZE		20
 304:/usr/include/libusb-1.0/libusb.h **** 
 305:/usr/include/libusb-1.0/libusb.h **** /* We unwrap the BOS => define its max size */
 306:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_BOS_MAX_SIZE		((LIBUSB_DT_BOS_SIZE)     +\
 307:/usr/include/libusb-1.0/libusb.h **** 					(LIBUSB_BT_USB_2_0_EXTENSION_SIZE)       +\
 308:/usr/include/libusb-1.0/libusb.h **** 					(LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE) +\
 309:/usr/include/libusb-1.0/libusb.h **** 					(LIBUSB_BT_CONTAINER_ID_SIZE))
 310:/usr/include/libusb-1.0/libusb.h **** 
 311:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ENDPOINT_ADDRESS_MASK	0x0f    /* in bEndpointAddress */
 312:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ENDPOINT_DIR_MASK		0x80
 313:/usr/include/libusb-1.0/libusb.h **** 
 314:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 315:/usr/include/libusb-1.0/libusb.h ****  * Endpoint direction. Values for bit 7 of the
 316:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bEndpointAddress "endpoint address" scheme.
 317:/usr/include/libusb-1.0/libusb.h ****  */
 318:/usr/include/libusb-1.0/libusb.h **** enum libusb_endpoint_direction {
 319:/usr/include/libusb-1.0/libusb.h **** 	/** In: device-to-host */
 320:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_IN = 0x80,
 321:/usr/include/libusb-1.0/libusb.h **** 
 322:/usr/include/libusb-1.0/libusb.h **** 	/** Out: host-to-device */
 323:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_OUT = 0x00
 324:/usr/include/libusb-1.0/libusb.h **** };
 325:/usr/include/libusb-1.0/libusb.h **** 
 326:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_TRANSFER_TYPE_MASK			0x03    /* in bmAttributes */
 327:/usr/include/libusb-1.0/libusb.h **** 
 328:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 329:/usr/include/libusb-1.0/libusb.h ****  * Endpoint transfer type. Values for bits 0:1 of the
 330:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "endpoint attributes" field.
 331:/usr/include/libusb-1.0/libusb.h ****  */
 332:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_type {
 333:/usr/include/libusb-1.0/libusb.h **** 	/** Control endpoint */
 334:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_CONTROL = 0,
 335:/usr/include/libusb-1.0/libusb.h **** 
 336:/usr/include/libusb-1.0/libusb.h **** 	/** Isochronous endpoint */
 337:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_ISOCHRONOUS = 1,
 338:/usr/include/libusb-1.0/libusb.h **** 
 339:/usr/include/libusb-1.0/libusb.h **** 	/** Bulk endpoint */
 340:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_BULK = 2,
 341:/usr/include/libusb-1.0/libusb.h **** 
 342:/usr/include/libusb-1.0/libusb.h **** 	/** Interrupt endpoint */
 343:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_INTERRUPT = 3,
 344:/usr/include/libusb-1.0/libusb.h **** 
 345:/usr/include/libusb-1.0/libusb.h **** 	/** Stream endpoint */
 346:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_BULK_STREAM = 4,
 347:/usr/include/libusb-1.0/libusb.h **** };
 348:/usr/include/libusb-1.0/libusb.h **** 
 349:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
 350:/usr/include/libusb-1.0/libusb.h ****  * Standard requests, as defined in table 9-5 of the USB 3.0 specifications */
 351:/usr/include/libusb-1.0/libusb.h **** enum libusb_standard_request {
 352:/usr/include/libusb-1.0/libusb.h **** 	/** Request status of the specific recipient */
 353:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_STATUS = 0x00,
 354:/usr/include/libusb-1.0/libusb.h **** 
 355:/usr/include/libusb-1.0/libusb.h **** 	/** Clear or disable a specific feature */
 356:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_CLEAR_FEATURE = 0x01,
 357:/usr/include/libusb-1.0/libusb.h **** 
 358:/usr/include/libusb-1.0/libusb.h **** 	/* 0x02 is reserved */
 359:/usr/include/libusb-1.0/libusb.h **** 
 360:/usr/include/libusb-1.0/libusb.h **** 	/** Set or enable a specific feature */
 361:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_FEATURE = 0x03,
 362:/usr/include/libusb-1.0/libusb.h **** 
 363:/usr/include/libusb-1.0/libusb.h **** 	/* 0x04 is reserved */
 364:/usr/include/libusb-1.0/libusb.h **** 
 365:/usr/include/libusb-1.0/libusb.h **** 	/** Set device address for all future accesses */
 366:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_ADDRESS = 0x05,
 367:/usr/include/libusb-1.0/libusb.h **** 
 368:/usr/include/libusb-1.0/libusb.h **** 	/** Get the specified descriptor */
 369:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_DESCRIPTOR = 0x06,
 370:/usr/include/libusb-1.0/libusb.h **** 
 371:/usr/include/libusb-1.0/libusb.h **** 	/** Used to update existing descriptors or add new descriptors */
 372:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_DESCRIPTOR = 0x07,
 373:/usr/include/libusb-1.0/libusb.h **** 
 374:/usr/include/libusb-1.0/libusb.h **** 	/** Get the current device configuration value */
 375:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_CONFIGURATION = 0x08,
 376:/usr/include/libusb-1.0/libusb.h **** 
 377:/usr/include/libusb-1.0/libusb.h **** 	/** Set device configuration */
 378:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_CONFIGURATION = 0x09,
 379:/usr/include/libusb-1.0/libusb.h **** 
 380:/usr/include/libusb-1.0/libusb.h **** 	/** Return the selected alternate setting for the specified interface */
 381:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_INTERFACE = 0x0A,
 382:/usr/include/libusb-1.0/libusb.h **** 
 383:/usr/include/libusb-1.0/libusb.h **** 	/** Select an alternate interface for the specified interface */
 384:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_INTERFACE = 0x0B,
 385:/usr/include/libusb-1.0/libusb.h **** 
 386:/usr/include/libusb-1.0/libusb.h **** 	/** Set then report an endpoint's synchronization frame */
 387:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SYNCH_FRAME = 0x0C,
 388:/usr/include/libusb-1.0/libusb.h **** 
 389:/usr/include/libusb-1.0/libusb.h **** 	/** Sets both the U1 and U2 Exit Latency */
 390:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_SEL = 0x30,
 391:/usr/include/libusb-1.0/libusb.h **** 
 392:/usr/include/libusb-1.0/libusb.h **** 	/** Delay from the time a host transmits a packet to the time it is
 393:/usr/include/libusb-1.0/libusb.h **** 	  * received by the device. */
 394:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SET_ISOCH_DELAY = 0x31,
 395:/usr/include/libusb-1.0/libusb.h **** };
 396:/usr/include/libusb-1.0/libusb.h **** 
 397:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
 398:/usr/include/libusb-1.0/libusb.h ****  * Request type bits of the
 399:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 400:/usr/include/libusb-1.0/libusb.h ****  * transfers. */
 401:/usr/include/libusb-1.0/libusb.h **** enum libusb_request_type {
 402:/usr/include/libusb-1.0/libusb.h **** 	/** Standard */
 403:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_STANDARD = (0x00 << 5),
 404:/usr/include/libusb-1.0/libusb.h **** 
 405:/usr/include/libusb-1.0/libusb.h **** 	/** Class */
 406:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5),
 407:/usr/include/libusb-1.0/libusb.h **** 
 408:/usr/include/libusb-1.0/libusb.h **** 	/** Vendor */
 409:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_VENDOR = (0x02 << 5),
 410:/usr/include/libusb-1.0/libusb.h **** 
 411:/usr/include/libusb-1.0/libusb.h **** 	/** Reserved */
 412:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_RESERVED = (0x03 << 5)
 413:/usr/include/libusb-1.0/libusb.h **** };
 414:/usr/include/libusb-1.0/libusb.h **** 
 415:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
 416:/usr/include/libusb-1.0/libusb.h ****  * Recipient bits of the
 417:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 418:/usr/include/libusb-1.0/libusb.h ****  * transfers. Values 4 through 31 are reserved. */
 419:/usr/include/libusb-1.0/libusb.h **** enum libusb_request_recipient {
 420:/usr/include/libusb-1.0/libusb.h **** 	/** Device */
 421:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_DEVICE = 0x00,
 422:/usr/include/libusb-1.0/libusb.h **** 
 423:/usr/include/libusb-1.0/libusb.h **** 	/** Interface */
 424:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_INTERFACE = 0x01,
 425:/usr/include/libusb-1.0/libusb.h **** 
 426:/usr/include/libusb-1.0/libusb.h **** 	/** Endpoint */
 427:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_ENDPOINT = 0x02,
 428:/usr/include/libusb-1.0/libusb.h **** 
 429:/usr/include/libusb-1.0/libusb.h **** 	/** Other */
 430:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_OTHER = 0x03,
 431:/usr/include/libusb-1.0/libusb.h **** };
 432:/usr/include/libusb-1.0/libusb.h **** 
 433:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ISO_SYNC_TYPE_MASK		0x0C
 434:/usr/include/libusb-1.0/libusb.h **** 
 435:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 436:/usr/include/libusb-1.0/libusb.h ****  * Synchronization type for isochronous endpoints. Values for bits 2:3 of the
 437:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 438:/usr/include/libusb-1.0/libusb.h ****  * libusb_endpoint_descriptor.
 439:/usr/include/libusb-1.0/libusb.h ****  */
 440:/usr/include/libusb-1.0/libusb.h **** enum libusb_iso_sync_type {
 441:/usr/include/libusb-1.0/libusb.h **** 	/** No synchronization */
 442:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_NONE = 0,
 443:/usr/include/libusb-1.0/libusb.h **** 
 444:/usr/include/libusb-1.0/libusb.h **** 	/** Asynchronous */
 445:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_ASYNC = 1,
 446:/usr/include/libusb-1.0/libusb.h **** 
 447:/usr/include/libusb-1.0/libusb.h **** 	/** Adaptive */
 448:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_ADAPTIVE = 2,
 449:/usr/include/libusb-1.0/libusb.h **** 
 450:/usr/include/libusb-1.0/libusb.h **** 	/** Synchronous */
 451:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_SYNC = 3
 452:/usr/include/libusb-1.0/libusb.h **** };
 453:/usr/include/libusb-1.0/libusb.h **** 
 454:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ISO_USAGE_TYPE_MASK 0x30
 455:/usr/include/libusb-1.0/libusb.h **** 
 456:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 457:/usr/include/libusb-1.0/libusb.h ****  * Usage type for isochronous endpoints. Values for bits 4:5 of the
 458:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 459:/usr/include/libusb-1.0/libusb.h ****  * libusb_endpoint_descriptor.
 460:/usr/include/libusb-1.0/libusb.h ****  */
 461:/usr/include/libusb-1.0/libusb.h **** enum libusb_iso_usage_type {
 462:/usr/include/libusb-1.0/libusb.h **** 	/** Data endpoint */
 463:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_DATA = 0,
 464:/usr/include/libusb-1.0/libusb.h **** 
 465:/usr/include/libusb-1.0/libusb.h **** 	/** Feedback endpoint */
 466:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_FEEDBACK = 1,
 467:/usr/include/libusb-1.0/libusb.h **** 
 468:/usr/include/libusb-1.0/libusb.h **** 	/** Implicit feedback Data endpoint */
 469:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_IMPLICIT = 2,
 470:/usr/include/libusb-1.0/libusb.h **** };
 471:/usr/include/libusb-1.0/libusb.h **** 
 472:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 473:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB device descriptor. This
 474:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.1 of the USB 3.0 specification.
 475:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 476:/usr/include/libusb-1.0/libusb.h ****  */
 477:/usr/include/libusb-1.0/libusb.h **** struct libusb_device_descriptor {
 478:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 479:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 480:/usr/include/libusb-1.0/libusb.h **** 
 481:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 482:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE LIBUSB_DT_DEVICE in this
 483:/usr/include/libusb-1.0/libusb.h **** 	 * context. */
 484:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 485:/usr/include/libusb-1.0/libusb.h **** 
 486:/usr/include/libusb-1.0/libusb.h **** 	/** USB specification release number in binary-coded decimal. A value of
 487:/usr/include/libusb-1.0/libusb.h **** 	 * 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc. */
 488:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bcdUSB;
 489:/usr/include/libusb-1.0/libusb.h **** 
 490:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF class code for the device. See \ref libusb_class_code. */
 491:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceClass;
 492:/usr/include/libusb-1.0/libusb.h **** 
 493:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF subclass code for the device, qualified by the bDeviceClass
 494:/usr/include/libusb-1.0/libusb.h **** 	 * value */
 495:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceSubClass;
 496:/usr/include/libusb-1.0/libusb.h **** 
 497:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF protocol code for the device, qualified by the bDeviceClass and
 498:/usr/include/libusb-1.0/libusb.h **** 	 * bDeviceSubClass values */
 499:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceProtocol;
 500:/usr/include/libusb-1.0/libusb.h **** 
 501:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum packet size for endpoint 0 */
 502:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bMaxPacketSize0;
 503:/usr/include/libusb-1.0/libusb.h **** 
 504:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF vendor ID */
 505:/usr/include/libusb-1.0/libusb.h **** 	uint16_t idVendor;
 506:/usr/include/libusb-1.0/libusb.h **** 
 507:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF product ID */
 508:/usr/include/libusb-1.0/libusb.h **** 	uint16_t idProduct;
 509:/usr/include/libusb-1.0/libusb.h **** 
 510:/usr/include/libusb-1.0/libusb.h **** 	/** Device release number in binary-coded decimal */
 511:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bcdDevice;
 512:/usr/include/libusb-1.0/libusb.h **** 
 513:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing manufacturer */
 514:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iManufacturer;
 515:/usr/include/libusb-1.0/libusb.h **** 
 516:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing product */
 517:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iProduct;
 518:/usr/include/libusb-1.0/libusb.h **** 
 519:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor containing device serial number */
 520:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iSerialNumber;
 521:/usr/include/libusb-1.0/libusb.h **** 
 522:/usr/include/libusb-1.0/libusb.h **** 	/** Number of possible configurations */
 523:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumConfigurations;
 524:/usr/include/libusb-1.0/libusb.h **** };
 525:/usr/include/libusb-1.0/libusb.h **** 
 526:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 527:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB endpoint descriptor. This
 528:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.6 of the USB 3.0 specification.
 529:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 530:/usr/include/libusb-1.0/libusb.h ****  */
 531:/usr/include/libusb-1.0/libusb.h **** struct libusb_endpoint_descriptor {
 532:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 533:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 534:/usr/include/libusb-1.0/libusb.h **** 
 535:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 536:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_ENDPOINT LIBUSB_DT_ENDPOINT in
 537:/usr/include/libusb-1.0/libusb.h **** 	 * this context. */
 538:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 539:/usr/include/libusb-1.0/libusb.h **** 
 540:/usr/include/libusb-1.0/libusb.h **** 	/** The address of the endpoint described by this descriptor. Bits 0:3 are
 541:/usr/include/libusb-1.0/libusb.h **** 	 * the endpoint number. Bits 4:6 are reserved. Bit 7 indicates direction,
 542:/usr/include/libusb-1.0/libusb.h **** 	 * see \ref libusb_endpoint_direction.
 543:/usr/include/libusb-1.0/libusb.h **** 	 */
 544:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bEndpointAddress;
 545:/usr/include/libusb-1.0/libusb.h **** 
 546:/usr/include/libusb-1.0/libusb.h **** 	/** Attributes which apply to the endpoint when it is configured using
 547:/usr/include/libusb-1.0/libusb.h **** 	 * the bConfigurationValue. Bits 0:1 determine the transfer type and
 548:/usr/include/libusb-1.0/libusb.h **** 	 * correspond to \ref libusb_transfer_type. Bits 2:3 are only used for
 549:/usr/include/libusb-1.0/libusb.h **** 	 * isochronous endpoints and correspond to \ref libusb_iso_sync_type.
 550:/usr/include/libusb-1.0/libusb.h **** 	 * Bits 4:5 are also only used for isochronous endpoints and correspond to
 551:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_iso_usage_type. Bits 6:7 are reserved.
 552:/usr/include/libusb-1.0/libusb.h **** 	 */
 553:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 554:/usr/include/libusb-1.0/libusb.h **** 
 555:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum packet size this endpoint is capable of sending/receiving. */
 556:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wMaxPacketSize;
 557:/usr/include/libusb-1.0/libusb.h **** 
 558:/usr/include/libusb-1.0/libusb.h **** 	/** Interval for polling endpoint for data transfers. */
 559:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterval;
 560:/usr/include/libusb-1.0/libusb.h **** 
 561:/usr/include/libusb-1.0/libusb.h **** 	/** For audio devices only: the rate at which synchronization feedback
 562:/usr/include/libusb-1.0/libusb.h **** 	 * is provided. */
 563:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bRefresh;
 564:/usr/include/libusb-1.0/libusb.h **** 
 565:/usr/include/libusb-1.0/libusb.h **** 	/** For audio devices only: the address if the synch endpoint */
 566:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bSynchAddress;
 567:/usr/include/libusb-1.0/libusb.h **** 
 568:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusb encounters unknown endpoint descriptors,
 569:/usr/include/libusb-1.0/libusb.h **** 	 * it will store them here, should you wish to parse them. */
 570:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 571:/usr/include/libusb-1.0/libusb.h **** 
 572:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. */
 573:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 574:/usr/include/libusb-1.0/libusb.h **** };
 575:/usr/include/libusb-1.0/libusb.h **** 
 576:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 577:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB interface descriptor. This
 578:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.5 of the USB 3.0 specification.
 579:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 580:/usr/include/libusb-1.0/libusb.h ****  */
 581:/usr/include/libusb-1.0/libusb.h **** struct libusb_interface_descriptor {
 582:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 583:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 584:/usr/include/libusb-1.0/libusb.h **** 
 585:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 586:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_INTERFACE LIBUSB_DT_INTERFACE
 587:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 588:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 589:/usr/include/libusb-1.0/libusb.h **** 
 590:/usr/include/libusb-1.0/libusb.h **** 	/** Number of this interface */
 591:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceNumber;
 592:/usr/include/libusb-1.0/libusb.h **** 
 593:/usr/include/libusb-1.0/libusb.h **** 	/** Value used to select this alternate setting for this interface */
 594:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bAlternateSetting;
 595:/usr/include/libusb-1.0/libusb.h **** 
 596:/usr/include/libusb-1.0/libusb.h **** 	/** Number of endpoints used by this interface (excluding the control
 597:/usr/include/libusb-1.0/libusb.h **** 	 * endpoint). */
 598:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumEndpoints;
 599:/usr/include/libusb-1.0/libusb.h **** 
 600:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF class code for this interface. See \ref libusb_class_code. */
 601:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceClass;
 602:/usr/include/libusb-1.0/libusb.h **** 
 603:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF subclass code for this interface, qualified by the
 604:/usr/include/libusb-1.0/libusb.h **** 	 * bInterfaceClass value */
 605:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceSubClass;
 606:/usr/include/libusb-1.0/libusb.h **** 
 607:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF protocol code for this interface, qualified by the
 608:/usr/include/libusb-1.0/libusb.h **** 	 * bInterfaceClass and bInterfaceSubClass values */
 609:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceProtocol;
 610:/usr/include/libusb-1.0/libusb.h **** 
 611:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing this interface */
 612:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iInterface;
 613:/usr/include/libusb-1.0/libusb.h **** 
 614:/usr/include/libusb-1.0/libusb.h **** 	/** Array of endpoint descriptors. This length of this array is determined
 615:/usr/include/libusb-1.0/libusb.h **** 	 * by the bNumEndpoints field. */
 616:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_endpoint_descriptor *endpoint;
 617:/usr/include/libusb-1.0/libusb.h **** 
 618:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusb encounters unknown interface descriptors,
 619:/usr/include/libusb-1.0/libusb.h **** 	 * it will store them here, should you wish to parse them. */
 620:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 621:/usr/include/libusb-1.0/libusb.h **** 
 622:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. */
 623:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 624:/usr/include/libusb-1.0/libusb.h **** };
 625:/usr/include/libusb-1.0/libusb.h **** 
 626:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 627:/usr/include/libusb-1.0/libusb.h ****  * A collection of alternate settings for a particular USB interface.
 628:/usr/include/libusb-1.0/libusb.h ****  */
 629:/usr/include/libusb-1.0/libusb.h **** struct libusb_interface {
 630:/usr/include/libusb-1.0/libusb.h **** 	/** Array of interface descriptors. The length of this array is determined
 631:/usr/include/libusb-1.0/libusb.h **** 	 * by the num_altsetting field. */
 632:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_interface_descriptor *altsetting;
 633:/usr/include/libusb-1.0/libusb.h **** 
 634:/usr/include/libusb-1.0/libusb.h **** 	/** The number of alternate settings that belong to this interface */
 635:/usr/include/libusb-1.0/libusb.h **** 	int num_altsetting;
 636:/usr/include/libusb-1.0/libusb.h **** };
 637:/usr/include/libusb-1.0/libusb.h **** 
 638:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 639:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB configuration descriptor. This
 640:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.3 of the USB 3.0 specification.
 641:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 642:/usr/include/libusb-1.0/libusb.h ****  */
 643:/usr/include/libusb-1.0/libusb.h **** struct libusb_config_descriptor {
 644:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 645:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 646:/usr/include/libusb-1.0/libusb.h **** 
 647:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 648:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_CONFIG LIBUSB_DT_CONFIG
 649:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 650:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 651:/usr/include/libusb-1.0/libusb.h **** 
 652:/usr/include/libusb-1.0/libusb.h **** 	/** Total length of data returned for this configuration */
 653:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wTotalLength;
 654:/usr/include/libusb-1.0/libusb.h **** 
 655:/usr/include/libusb-1.0/libusb.h **** 	/** Number of interfaces supported by this configuration */
 656:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumInterfaces;
 657:/usr/include/libusb-1.0/libusb.h **** 
 658:/usr/include/libusb-1.0/libusb.h **** 	/** Identifier value for this configuration */
 659:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bConfigurationValue;
 660:/usr/include/libusb-1.0/libusb.h **** 
 661:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing this configuration */
 662:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iConfiguration;
 663:/usr/include/libusb-1.0/libusb.h **** 
 664:/usr/include/libusb-1.0/libusb.h **** 	/** Configuration characteristics */
 665:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 666:/usr/include/libusb-1.0/libusb.h **** 
 667:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum power consumption of the USB device from this bus in this
 668:/usr/include/libusb-1.0/libusb.h **** 	 * configuration when the device is fully operation. Expressed in units
 669:/usr/include/libusb-1.0/libusb.h **** 	 * of 2 mA when the device is operating in high-speed mode and in units
 670:/usr/include/libusb-1.0/libusb.h **** 	 * of 8 mA when the device is operating in super-speed mode. */
 671:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  MaxPower;
 672:/usr/include/libusb-1.0/libusb.h **** 
 673:/usr/include/libusb-1.0/libusb.h **** 	/** Array of interfaces supported by this configuration. The length of
 674:/usr/include/libusb-1.0/libusb.h **** 	 * this array is determined by the bNumInterfaces field. */
 675:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_interface *interface;
 676:/usr/include/libusb-1.0/libusb.h **** 
 677:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusb encounters unknown configuration
 678:/usr/include/libusb-1.0/libusb.h **** 	 * descriptors, it will store them here, should you wish to parse them. */
 679:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 680:/usr/include/libusb-1.0/libusb.h **** 
 681:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. */
 682:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 683:/usr/include/libusb-1.0/libusb.h **** };
 684:/usr/include/libusb-1.0/libusb.h **** 
 685:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 686:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the superspeed endpoint companion
 687:/usr/include/libusb-1.0/libusb.h ****  * descriptor. This descriptor is documented in section 9.6.7 of
 688:/usr/include/libusb-1.0/libusb.h ****  * the USB 3.0 specification. All multiple-byte fields are represented in
 689:/usr/include/libusb-1.0/libusb.h ****  * host-endian format.
 690:/usr/include/libusb-1.0/libusb.h ****  */
 691:/usr/include/libusb-1.0/libusb.h **** struct libusb_ss_endpoint_companion_descriptor {
 692:/usr/include/libusb-1.0/libusb.h **** 
 693:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 694:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 695:/usr/include/libusb-1.0/libusb.h **** 
 696:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 697:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_SS_ENDPOINT_COMPANION in
 698:/usr/include/libusb-1.0/libusb.h **** 	 * this context. */
 699:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 700:/usr/include/libusb-1.0/libusb.h **** 
 701:/usr/include/libusb-1.0/libusb.h **** 
 702:/usr/include/libusb-1.0/libusb.h **** 	/** The maximum number of packets the endpoint can send or
 703:/usr/include/libusb-1.0/libusb.h **** 	 *  receive as part of a burst. */
 704:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bMaxBurst;
 705:/usr/include/libusb-1.0/libusb.h **** 
 706:/usr/include/libusb-1.0/libusb.h **** 	/** In bulk EP:	bits 4:0 represents the	maximum	number of
 707:/usr/include/libusb-1.0/libusb.h **** 	 *  streams the	EP supports. In	isochronous EP:	bits 1:0
 708:/usr/include/libusb-1.0/libusb.h **** 	 *  represents the Mult	- a zero based value that determines
 709:/usr/include/libusb-1.0/libusb.h **** 	 *  the	maximum	number of packets within a service interval  */
 710:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 711:/usr/include/libusb-1.0/libusb.h **** 
 712:/usr/include/libusb-1.0/libusb.h **** 	/** The	total number of bytes this EP will transfer every
 713:/usr/include/libusb-1.0/libusb.h **** 	 *  service interval. valid only for periodic EPs. */
 714:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wBytesPerInterval;
 715:/usr/include/libusb-1.0/libusb.h **** };
 716:/usr/include/libusb-1.0/libusb.h **** 
 717:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 718:/usr/include/libusb-1.0/libusb.h ****  * A generic representation of a BOS Device Capability descriptor. It is
 719:/usr/include/libusb-1.0/libusb.h ****  * advised to check bDevCapabilityType and call the matching
 720:/usr/include/libusb-1.0/libusb.h ****  * libusb_get_*_descriptor function to get a structure fully matching the type.
 721:/usr/include/libusb-1.0/libusb.h ****  */
 722:/usr/include/libusb-1.0/libusb.h **** struct libusb_bos_dev_capability_descriptor {
 723:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 724:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bLength;
 725:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 726:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 727:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 728:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bDescriptorType;
 729:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability type */
 730:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bDevCapabilityType;
 731:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability data (bLength - 3 bytes) */
 732:/usr/include/libusb-1.0/libusb.h **** 	uint8_t dev_capability_data
 733:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
 734:/usr/include/libusb-1.0/libusb.h **** 	[] /* valid C99 code */
 735:/usr/include/libusb-1.0/libusb.h **** #else
 736:/usr/include/libusb-1.0/libusb.h **** 	[0] /* non-standard, but usually working code */
 737:/usr/include/libusb-1.0/libusb.h **** #endif
 738:/usr/include/libusb-1.0/libusb.h **** 	;
 739:/usr/include/libusb-1.0/libusb.h **** };
 740:/usr/include/libusb-1.0/libusb.h **** 
 741:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 742:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the Binary Device Object Store (BOS) descriptor.
 743:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2 of the USB 3.0 specification.
 744:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 745:/usr/include/libusb-1.0/libusb.h ****  */
 746:/usr/include/libusb-1.0/libusb.h **** struct libusb_bos_descriptor {
 747:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 748:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 749:/usr/include/libusb-1.0/libusb.h **** 
 750:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 751:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_BOS LIBUSB_DT_BOS
 752:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 753:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 754:/usr/include/libusb-1.0/libusb.h **** 
 755:/usr/include/libusb-1.0/libusb.h **** 	/** Length of this descriptor and all of its sub descriptors */
 756:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wTotalLength;
 757:/usr/include/libusb-1.0/libusb.h **** 
 758:/usr/include/libusb-1.0/libusb.h **** 	/** The number of separate device capability descriptors in
 759:/usr/include/libusb-1.0/libusb.h **** 	 * the BOS */
 760:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumDeviceCaps;
 761:/usr/include/libusb-1.0/libusb.h **** 
 762:/usr/include/libusb-1.0/libusb.h **** 	/** bNumDeviceCap Device Capability Descriptors */
 763:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_capability
 764:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
 765:/usr/include/libusb-1.0/libusb.h **** 	[] /* valid C99 code */
 766:/usr/include/libusb-1.0/libusb.h **** #else
 767:/usr/include/libusb-1.0/libusb.h **** 	[0] /* non-standard, but usually working code */
 768:/usr/include/libusb-1.0/libusb.h **** #endif
 769:/usr/include/libusb-1.0/libusb.h **** 	;
 770:/usr/include/libusb-1.0/libusb.h **** };
 771:/usr/include/libusb-1.0/libusb.h **** 
 772:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 773:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the USB 2.0 Extension descriptor
 774:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.1 of the USB 3.0 specification.
 775:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 776:/usr/include/libusb-1.0/libusb.h ****  */
 777:/usr/include/libusb-1.0/libusb.h **** struct libusb_usb_2_0_extension_descriptor {
 778:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 779:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 780:/usr/include/libusb-1.0/libusb.h **** 
 781:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 782:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 783:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 784:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 785:/usr/include/libusb-1.0/libusb.h **** 
 786:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 787:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_USB_2_0_EXTENSION
 788:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_USB_2_0_EXTENSION in this context. */
 789:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 790:/usr/include/libusb-1.0/libusb.h **** 
 791:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of supported device level features.
 792:/usr/include/libusb-1.0/libusb.h **** 	 * A value of one in a bit location indicates a feature is
 793:/usr/include/libusb-1.0/libusb.h **** 	 * supported; a value of zero indicates it is not supported.
 794:/usr/include/libusb-1.0/libusb.h **** 	 * See \ref libusb_usb_2_0_extension_attributes. */
 795:/usr/include/libusb-1.0/libusb.h **** 	uint32_t  bmAttributes;
 796:/usr/include/libusb-1.0/libusb.h **** };
 797:/usr/include/libusb-1.0/libusb.h **** 
 798:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 799:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the SuperSpeed USB Device Capability descriptor
 800:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.2 of the USB 3.0 specification.
 801:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 802:/usr/include/libusb-1.0/libusb.h ****  */
 803:/usr/include/libusb-1.0/libusb.h **** struct libusb_ss_usb_device_capability_descriptor {
 804:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 805:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 806:/usr/include/libusb-1.0/libusb.h **** 
 807:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 808:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 809:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 810:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 811:/usr/include/libusb-1.0/libusb.h **** 
 812:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 813:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_SS_USB_DEVICE_CAPABILITY
 814:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_SS_USB_DEVICE_CAPABILITY in this context. */
 815:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 816:/usr/include/libusb-1.0/libusb.h **** 
 817:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of supported device level features.
 818:/usr/include/libusb-1.0/libusb.h **** 	 * A value of one in a bit location indicates a feature is
 819:/usr/include/libusb-1.0/libusb.h **** 	 * supported; a value of zero indicates it is not supported.
 820:/usr/include/libusb-1.0/libusb.h **** 	 * See \ref libusb_ss_usb_device_capability_attributes. */
 821:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 822:/usr/include/libusb-1.0/libusb.h **** 
 823:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of the speed supported by this device when
 824:/usr/include/libusb-1.0/libusb.h **** 	 * operating in SuperSpeed mode. See \ref libusb_supported_speed. */
 825:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wSpeedSupported;
 826:/usr/include/libusb-1.0/libusb.h **** 
 827:/usr/include/libusb-1.0/libusb.h **** 	/** The lowest speed at which all the functionality supported
 828:/usr/include/libusb-1.0/libusb.h **** 	 * by the device is available to the user. For example if the
 829:/usr/include/libusb-1.0/libusb.h **** 	 * device supports all its functionality when connected at
 830:/usr/include/libusb-1.0/libusb.h **** 	 * full speed and above then it sets this value to 1. */
 831:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bFunctionalitySupport;
 832:/usr/include/libusb-1.0/libusb.h **** 
 833:/usr/include/libusb-1.0/libusb.h **** 	/** U1 Device Exit Latency. */
 834:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bU1DevExitLat;
 835:/usr/include/libusb-1.0/libusb.h **** 
 836:/usr/include/libusb-1.0/libusb.h **** 	/** U2 Device Exit Latency. */
 837:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bU2DevExitLat;
 838:/usr/include/libusb-1.0/libusb.h **** };
 839:/usr/include/libusb-1.0/libusb.h **** 
 840:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_desc
 841:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the Container ID descriptor.
 842:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification.
 843:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields, except UUIDs, are represented in host-endian format.
 844:/usr/include/libusb-1.0/libusb.h ****  */
 845:/usr/include/libusb-1.0/libusb.h **** struct libusb_container_id_descriptor {
 846:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 847:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 848:/usr/include/libusb-1.0/libusb.h **** 
 849:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 850:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 851:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 852:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 853:/usr/include/libusb-1.0/libusb.h **** 
 854:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 855:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_CONTAINER_ID
 856:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_CONTAINER_ID in this context. */
 857:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 858:/usr/include/libusb-1.0/libusb.h **** 
 859:/usr/include/libusb-1.0/libusb.h **** 	/** Reserved field */
 860:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bReserved;
 861:/usr/include/libusb-1.0/libusb.h **** 
 862:/usr/include/libusb-1.0/libusb.h **** 	/** 128 bit UUID */
 863:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  ContainerID[16];
 864:/usr/include/libusb-1.0/libusb.h **** };
 865:/usr/include/libusb-1.0/libusb.h **** 
 866:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
 867:/usr/include/libusb-1.0/libusb.h ****  * Setup packet for control transfers. */
 868:/usr/include/libusb-1.0/libusb.h **** struct libusb_control_setup {
 869:/usr/include/libusb-1.0/libusb.h **** 	/** Request type. Bits 0:4 determine recipient, see
 870:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_recipient. Bits 5:6 determine type, see
 871:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_type. Bit 7 determines data transfer direction, see
 872:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_endpoint_direction.
 873:/usr/include/libusb-1.0/libusb.h **** 	 */
 874:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmRequestType;
 875:/usr/include/libusb-1.0/libusb.h **** 
 876:/usr/include/libusb-1.0/libusb.h **** 	/** Request. If the type bits of bmRequestType are equal to
 877:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_type::LIBUSB_REQUEST_TYPE_STANDARD
 878:/usr/include/libusb-1.0/libusb.h **** 	 * "LIBUSB_REQUEST_TYPE_STANDARD" then this field refers to
 879:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_standard_request. For other cases, use of this field is
 880:/usr/include/libusb-1.0/libusb.h **** 	 * application-specific. */
 881:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bRequest;
 882:/usr/include/libusb-1.0/libusb.h **** 
 883:/usr/include/libusb-1.0/libusb.h **** 	/** Value. Varies according to request */
 884:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wValue;
 885:/usr/include/libusb-1.0/libusb.h **** 
 886:/usr/include/libusb-1.0/libusb.h **** 	/** Index. Varies according to request, typically used to pass an index
 887:/usr/include/libusb-1.0/libusb.h **** 	 * or offset */
 888:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wIndex;
 889:/usr/include/libusb-1.0/libusb.h **** 
 890:/usr/include/libusb-1.0/libusb.h **** 	/** Number of bytes to transfer */
 891:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wLength;
 892:/usr/include/libusb-1.0/libusb.h **** };
 893:/usr/include/libusb-1.0/libusb.h **** 
 894:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CONTROL_SETUP_SIZE (sizeof(struct libusb_control_setup))
 895:/usr/include/libusb-1.0/libusb.h **** 
 896:/usr/include/libusb-1.0/libusb.h **** /* libusb */
 897:/usr/include/libusb-1.0/libusb.h **** 
 898:/usr/include/libusb-1.0/libusb.h **** struct libusb_context;
 899:/usr/include/libusb-1.0/libusb.h **** struct libusb_device;
 900:/usr/include/libusb-1.0/libusb.h **** struct libusb_device_handle;
 901:/usr/include/libusb-1.0/libusb.h **** 
 902:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_lib
 903:/usr/include/libusb-1.0/libusb.h ****  * Structure providing the version of the libusb runtime
 904:/usr/include/libusb-1.0/libusb.h ****  */
 905:/usr/include/libusb-1.0/libusb.h **** struct libusb_version {
 906:/usr/include/libusb-1.0/libusb.h **** 	/** Library major version. */
 907:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t major;
 908:/usr/include/libusb-1.0/libusb.h **** 
 909:/usr/include/libusb-1.0/libusb.h **** 	/** Library minor version. */
 910:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t minor;
 911:/usr/include/libusb-1.0/libusb.h **** 
 912:/usr/include/libusb-1.0/libusb.h **** 	/** Library micro version. */
 913:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t micro;
 914:/usr/include/libusb-1.0/libusb.h **** 
 915:/usr/include/libusb-1.0/libusb.h **** 	/** Library nano version. */
 916:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t nano;
 917:/usr/include/libusb-1.0/libusb.h **** 
 918:/usr/include/libusb-1.0/libusb.h **** 	/** Library release candidate suffix string, e.g. "-rc4". */
 919:/usr/include/libusb-1.0/libusb.h **** 	const char *rc;
 920:/usr/include/libusb-1.0/libusb.h **** 
 921:/usr/include/libusb-1.0/libusb.h **** 	/** For ABI compatibility only. */
 922:/usr/include/libusb-1.0/libusb.h **** 	const char* describe;
 923:/usr/include/libusb-1.0/libusb.h **** };
 924:/usr/include/libusb-1.0/libusb.h **** 
 925:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_lib
 926:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a libusb session. The concept of individual libusb
 927:/usr/include/libusb-1.0/libusb.h ****  * sessions allows for your program to use two libraries (or dynamically
 928:/usr/include/libusb-1.0/libusb.h ****  * load two modules) which both independently use libusb. This will prevent
 929:/usr/include/libusb-1.0/libusb.h ****  * interference between the individual libusb users - for example
 930:/usr/include/libusb-1.0/libusb.h ****  * libusb_set_debug() will not affect the other user of the library, and
 931:/usr/include/libusb-1.0/libusb.h ****  * libusb_exit() will not destroy resources that the other user is still
 932:/usr/include/libusb-1.0/libusb.h ****  * using.
 933:/usr/include/libusb-1.0/libusb.h ****  *
 934:/usr/include/libusb-1.0/libusb.h ****  * Sessions are created by libusb_init() and destroyed through libusb_exit().
 935:/usr/include/libusb-1.0/libusb.h ****  * If your application is guaranteed to only ever include a single libusb
 936:/usr/include/libusb-1.0/libusb.h ****  * user (i.e. you), you do not have to worry about contexts: pass NULL in
 937:/usr/include/libusb-1.0/libusb.h ****  * every function call where a context is required. The default context
 938:/usr/include/libusb-1.0/libusb.h ****  * will be used.
 939:/usr/include/libusb-1.0/libusb.h ****  *
 940:/usr/include/libusb-1.0/libusb.h ****  * For more information, see \ref libusb_contexts.
 941:/usr/include/libusb-1.0/libusb.h ****  */
 942:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_context libusb_context;
 943:/usr/include/libusb-1.0/libusb.h **** 
 944:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
 945:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a USB device detected on the system. This is an
 946:/usr/include/libusb-1.0/libusb.h ****  * opaque type for which you are only ever provided with a pointer, usually
 947:/usr/include/libusb-1.0/libusb.h ****  * originating from libusb_get_device_list().
 948:/usr/include/libusb-1.0/libusb.h ****  *
 949:/usr/include/libusb-1.0/libusb.h ****  * Certain operations can be performed on a device, but in order to do any
 950:/usr/include/libusb-1.0/libusb.h ****  * I/O you will have to first obtain a device handle using libusb_open().
 951:/usr/include/libusb-1.0/libusb.h ****  *
 952:/usr/include/libusb-1.0/libusb.h ****  * Devices are reference counted with libusb_ref_device() and
 953:/usr/include/libusb-1.0/libusb.h ****  * libusb_unref_device(), and are freed when the reference count reaches 0.
 954:/usr/include/libusb-1.0/libusb.h ****  * New devices presented by libusb_get_device_list() have a reference count of
 955:/usr/include/libusb-1.0/libusb.h ****  * 1, and libusb_free_device_list() can optionally decrease the reference count
 956:/usr/include/libusb-1.0/libusb.h ****  * on all devices in the list. libusb_open() adds another reference which is
 957:/usr/include/libusb-1.0/libusb.h ****  * later destroyed by libusb_close().
 958:/usr/include/libusb-1.0/libusb.h ****  */
 959:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_device libusb_device;
 960:/usr/include/libusb-1.0/libusb.h **** 
 961:/usr/include/libusb-1.0/libusb.h **** 
 962:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
 963:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a handle on a USB device. This is an opaque type for
 964:/usr/include/libusb-1.0/libusb.h ****  * which you are only ever provided with a pointer, usually originating from
 965:/usr/include/libusb-1.0/libusb.h ****  * libusb_open().
 966:/usr/include/libusb-1.0/libusb.h ****  *
 967:/usr/include/libusb-1.0/libusb.h ****  * A device handle is used to perform I/O and other operations. When finished
 968:/usr/include/libusb-1.0/libusb.h ****  * with a device handle, you should call libusb_close().
 969:/usr/include/libusb-1.0/libusb.h ****  */
 970:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_device_handle libusb_device_handle;
 971:/usr/include/libusb-1.0/libusb.h **** 
 972:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
 973:/usr/include/libusb-1.0/libusb.h ****  * Speed codes. Indicates the speed at which the device is operating.
 974:/usr/include/libusb-1.0/libusb.h ****  */
 975:/usr/include/libusb-1.0/libusb.h **** enum libusb_speed {
 976:/usr/include/libusb-1.0/libusb.h **** 	/** The OS doesn't report or know the device speed. */
 977:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_UNKNOWN = 0,
 978:/usr/include/libusb-1.0/libusb.h **** 
 979:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at low speed (1.5MBit/s). */
 980:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_LOW = 1,
 981:/usr/include/libusb-1.0/libusb.h **** 
 982:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at full speed (12MBit/s). */
 983:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_FULL = 2,
 984:/usr/include/libusb-1.0/libusb.h **** 
 985:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at high speed (480MBit/s). */
 986:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_HIGH = 3,
 987:/usr/include/libusb-1.0/libusb.h **** 
 988:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at super speed (5000MBit/s). */
 989:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_SUPER = 4,
 990:/usr/include/libusb-1.0/libusb.h **** };
 991:/usr/include/libusb-1.0/libusb.h **** 
 992:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
 993:/usr/include/libusb-1.0/libusb.h ****  * Supported speeds (wSpeedSupported) bitfield. Indicates what
 994:/usr/include/libusb-1.0/libusb.h ****  * speeds the device supports.
 995:/usr/include/libusb-1.0/libusb.h ****  */
 996:/usr/include/libusb-1.0/libusb.h **** enum libusb_supported_speed {
 997:/usr/include/libusb-1.0/libusb.h **** 	/** Low speed operation supported (1.5MBit/s). */
 998:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOW_SPEED_OPERATION   = 1,
 999:/usr/include/libusb-1.0/libusb.h **** 
1000:/usr/include/libusb-1.0/libusb.h **** 	/** Full speed operation supported (12MBit/s). */
1001:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_FULL_SPEED_OPERATION  = 2,
1002:/usr/include/libusb-1.0/libusb.h **** 
1003:/usr/include/libusb-1.0/libusb.h **** 	/** High speed operation supported (480MBit/s). */
1004:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_HIGH_SPEED_OPERATION  = 4,
1005:/usr/include/libusb-1.0/libusb.h **** 
1006:/usr/include/libusb-1.0/libusb.h **** 	/** Superspeed operation supported (5000MBit/s). */
1007:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SUPER_SPEED_OPERATION = 8,
1008:/usr/include/libusb-1.0/libusb.h **** };
1009:/usr/include/libusb-1.0/libusb.h **** 
1010:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
1011:/usr/include/libusb-1.0/libusb.h ****  * Masks for the bits of the
1012:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_usb_2_0_extension_descriptor::bmAttributes "bmAttributes" field
1013:/usr/include/libusb-1.0/libusb.h ****  * of the USB 2.0 Extension descriptor.
1014:/usr/include/libusb-1.0/libusb.h ****  */
1015:/usr/include/libusb-1.0/libusb.h **** enum libusb_usb_2_0_extension_attributes {
1016:/usr/include/libusb-1.0/libusb.h **** 	/** Supports Link Power Management (LPM) */
1017:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BM_LPM_SUPPORT = 2,
1018:/usr/include/libusb-1.0/libusb.h **** };
1019:/usr/include/libusb-1.0/libusb.h **** 
1020:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
1021:/usr/include/libusb-1.0/libusb.h ****  * Masks for the bits of the
1022:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_ss_usb_device_capability_descriptor::bmAttributes "bmAttributes" field
1023:/usr/include/libusb-1.0/libusb.h ****  * field of the SuperSpeed USB Device Capability descriptor.
1024:/usr/include/libusb-1.0/libusb.h ****  */
1025:/usr/include/libusb-1.0/libusb.h **** enum libusb_ss_usb_device_capability_attributes {
1026:/usr/include/libusb-1.0/libusb.h **** 	/** Supports Latency Tolerance Messages (LTM) */
1027:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BM_LTM_SUPPORT = 2,
1028:/usr/include/libusb-1.0/libusb.h **** };
1029:/usr/include/libusb-1.0/libusb.h **** 
1030:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_dev
1031:/usr/include/libusb-1.0/libusb.h ****  * USB capability types
1032:/usr/include/libusb-1.0/libusb.h ****  */
1033:/usr/include/libusb-1.0/libusb.h **** enum libusb_bos_type {
1034:/usr/include/libusb-1.0/libusb.h **** 	/** Wireless USB device capability */
1035:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY	= 1,
1036:/usr/include/libusb-1.0/libusb.h **** 
1037:/usr/include/libusb-1.0/libusb.h **** 	/** USB 2.0 extensions */
1038:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_USB_2_0_EXTENSION			= 2,
1039:/usr/include/libusb-1.0/libusb.h **** 
1040:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed USB device capability */
1041:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_SS_USB_DEVICE_CAPABILITY		= 3,
1042:/usr/include/libusb-1.0/libusb.h **** 
1043:/usr/include/libusb-1.0/libusb.h **** 	/** Container ID type */
1044:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_CONTAINER_ID				= 4,
1045:/usr/include/libusb-1.0/libusb.h **** };
1046:/usr/include/libusb-1.0/libusb.h **** 
1047:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
1048:/usr/include/libusb-1.0/libusb.h ****  * Error codes. Most libusb functions return 0 on success or one of these
1049:/usr/include/libusb-1.0/libusb.h ****  * codes on failure.
1050:/usr/include/libusb-1.0/libusb.h ****  * You can call libusb_error_name() to retrieve a string representation of an
1051:/usr/include/libusb-1.0/libusb.h ****  * error code or libusb_strerror() to get an end-user suitable description of
1052:/usr/include/libusb-1.0/libusb.h ****  * an error code.
1053:/usr/include/libusb-1.0/libusb.h ****  */
1054:/usr/include/libusb-1.0/libusb.h **** enum libusb_error {
1055:/usr/include/libusb-1.0/libusb.h **** 	/** Success (no error) */
1056:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SUCCESS = 0,
1057:/usr/include/libusb-1.0/libusb.h **** 
1058:/usr/include/libusb-1.0/libusb.h **** 	/** Input/output error */
1059:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_IO = -1,
1060:/usr/include/libusb-1.0/libusb.h **** 
1061:/usr/include/libusb-1.0/libusb.h **** 	/** Invalid parameter */
1062:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_INVALID_PARAM = -2,
1063:/usr/include/libusb-1.0/libusb.h **** 
1064:/usr/include/libusb-1.0/libusb.h **** 	/** Access denied (insufficient permissions) */
1065:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_ACCESS = -3,
1066:/usr/include/libusb-1.0/libusb.h **** 
1067:/usr/include/libusb-1.0/libusb.h **** 	/** No such device (it may have been disconnected) */
1068:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NO_DEVICE = -4,
1069:/usr/include/libusb-1.0/libusb.h **** 
1070:/usr/include/libusb-1.0/libusb.h **** 	/** Entity not found */
1071:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NOT_FOUND = -5,
1072:/usr/include/libusb-1.0/libusb.h **** 
1073:/usr/include/libusb-1.0/libusb.h **** 	/** Resource busy */
1074:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_BUSY = -6,
1075:/usr/include/libusb-1.0/libusb.h **** 
1076:/usr/include/libusb-1.0/libusb.h **** 	/** Operation timed out */
1077:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_TIMEOUT = -7,
1078:/usr/include/libusb-1.0/libusb.h **** 
1079:/usr/include/libusb-1.0/libusb.h **** 	/** Overflow */
1080:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_OVERFLOW = -8,
1081:/usr/include/libusb-1.0/libusb.h **** 
1082:/usr/include/libusb-1.0/libusb.h **** 	/** Pipe error */
1083:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_PIPE = -9,
1084:/usr/include/libusb-1.0/libusb.h **** 
1085:/usr/include/libusb-1.0/libusb.h **** 	/** System call interrupted (perhaps due to signal) */
1086:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_INTERRUPTED = -10,
1087:/usr/include/libusb-1.0/libusb.h **** 
1088:/usr/include/libusb-1.0/libusb.h **** 	/** Insufficient memory */
1089:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NO_MEM = -11,
1090:/usr/include/libusb-1.0/libusb.h **** 
1091:/usr/include/libusb-1.0/libusb.h **** 	/** Operation not supported or unimplemented on this platform */
1092:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NOT_SUPPORTED = -12,
1093:/usr/include/libusb-1.0/libusb.h **** 
1094:/usr/include/libusb-1.0/libusb.h **** 	/* NB: Remember to update LIBUSB_ERROR_COUNT below as well as the
1095:/usr/include/libusb-1.0/libusb.h **** 	   message strings in strerror.c when adding new error codes here. */
1096:/usr/include/libusb-1.0/libusb.h **** 
1097:/usr/include/libusb-1.0/libusb.h **** 	/** Other error */
1098:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_OTHER = -99,
1099:/usr/include/libusb-1.0/libusb.h **** };
1100:/usr/include/libusb-1.0/libusb.h **** 
1101:/usr/include/libusb-1.0/libusb.h **** /* Total number of error codes in enum libusb_error */
1102:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ERROR_COUNT 14
1103:/usr/include/libusb-1.0/libusb.h **** 
1104:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1105:/usr/include/libusb-1.0/libusb.h ****  * Transfer status codes */
1106:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_status {
1107:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer completed without error. Note that this does not indicate
1108:/usr/include/libusb-1.0/libusb.h **** 	 * that the entire amount of requested data was transferred. */
1109:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_COMPLETED,
1110:/usr/include/libusb-1.0/libusb.h **** 
1111:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer failed */
1112:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_ERROR,
1113:/usr/include/libusb-1.0/libusb.h **** 
1114:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer timed out */
1115:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TIMED_OUT,
1116:/usr/include/libusb-1.0/libusb.h **** 
1117:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer was cancelled */
1118:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_CANCELLED,
1119:/usr/include/libusb-1.0/libusb.h **** 
1120:/usr/include/libusb-1.0/libusb.h **** 	/** For bulk/interrupt endpoints: halt condition detected (endpoint
1121:/usr/include/libusb-1.0/libusb.h **** 	 * stalled). For control endpoints: control request not supported. */
1122:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_STALL,
1123:/usr/include/libusb-1.0/libusb.h **** 
1124:/usr/include/libusb-1.0/libusb.h **** 	/** Device was disconnected */
1125:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_NO_DEVICE,
1126:/usr/include/libusb-1.0/libusb.h **** 
1127:/usr/include/libusb-1.0/libusb.h **** 	/** Device sent more data than requested */
1128:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_OVERFLOW,
1129:/usr/include/libusb-1.0/libusb.h **** 
1130:/usr/include/libusb-1.0/libusb.h **** 	/* NB! Remember to update libusb_error_name()
1131:/usr/include/libusb-1.0/libusb.h **** 	   when adding new status codes here. */
1132:/usr/include/libusb-1.0/libusb.h **** };
1133:/usr/include/libusb-1.0/libusb.h **** 
1134:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1135:/usr/include/libusb-1.0/libusb.h ****  * libusb_transfer.flags values */
1136:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_flags {
1137:/usr/include/libusb-1.0/libusb.h **** 	/** Report short frames as errors */
1138:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_SHORT_NOT_OK = 1<<0,
1139:/usr/include/libusb-1.0/libusb.h **** 
1140:/usr/include/libusb-1.0/libusb.h **** 	/** Automatically free() transfer buffer during libusb_free_transfer().
1141:/usr/include/libusb-1.0/libusb.h **** 	 * Note that buffers allocated with libusb_dev_mem_alloc() should not
1142:/usr/include/libusb-1.0/libusb.h **** 	 * be attempted freed in this way, since free() is not an appropriate
1143:/usr/include/libusb-1.0/libusb.h **** 	 * way to release such memory. */
1144:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_FREE_BUFFER = 1<<1,
1145:/usr/include/libusb-1.0/libusb.h **** 
1146:/usr/include/libusb-1.0/libusb.h **** 	/** Automatically call libusb_free_transfer() after callback returns.
1147:/usr/include/libusb-1.0/libusb.h **** 	 * If this flag is set, it is illegal to call libusb_free_transfer()
1148:/usr/include/libusb-1.0/libusb.h **** 	 * from your transfer callback, as this will result in a double-free
1149:/usr/include/libusb-1.0/libusb.h **** 	 * when this flag is acted upon. */
1150:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_FREE_TRANSFER = 1<<2,
1151:/usr/include/libusb-1.0/libusb.h **** 
1152:/usr/include/libusb-1.0/libusb.h **** 	/** Terminate transfers that are a multiple of the endpoint's
1153:/usr/include/libusb-1.0/libusb.h **** 	 * wMaxPacketSize with an extra zero length packet. This is useful
1154:/usr/include/libusb-1.0/libusb.h **** 	 * when a device protocol mandates that each logical request is
1155:/usr/include/libusb-1.0/libusb.h **** 	 * terminated by an incomplete packet (i.e. the logical requests are
1156:/usr/include/libusb-1.0/libusb.h **** 	 * not separated by other means).
1157:/usr/include/libusb-1.0/libusb.h **** 	 *
1158:/usr/include/libusb-1.0/libusb.h **** 	 * This flag only affects host-to-device transfers to bulk and interrupt
1159:/usr/include/libusb-1.0/libusb.h **** 	 * endpoints. In other situations, it is ignored.
1160:/usr/include/libusb-1.0/libusb.h **** 	 *
1161:/usr/include/libusb-1.0/libusb.h **** 	 * This flag only affects transfers with a length that is a multiple of
1162:/usr/include/libusb-1.0/libusb.h **** 	 * the endpoint's wMaxPacketSize. On transfers of other lengths, this
1163:/usr/include/libusb-1.0/libusb.h **** 	 * flag has no effect. Therefore, if you are working with a device that
1164:/usr/include/libusb-1.0/libusb.h **** 	 * needs a ZLP whenever the end of the logical request falls on a packet
1165:/usr/include/libusb-1.0/libusb.h **** 	 * boundary, then it is sensible to set this flag on <em>every</em>
1166:/usr/include/libusb-1.0/libusb.h **** 	 * transfer (you do not have to worry about only setting it on transfers
1167:/usr/include/libusb-1.0/libusb.h **** 	 * that end on the boundary).
1168:/usr/include/libusb-1.0/libusb.h **** 	 *
1169:/usr/include/libusb-1.0/libusb.h **** 	 * This flag is currently only supported on Linux.
1170:/usr/include/libusb-1.0/libusb.h **** 	 * On other systems, libusb_submit_transfer() will return
1171:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_ERROR_NOT_SUPPORTED for every transfer where this flag is set.
1172:/usr/include/libusb-1.0/libusb.h **** 	 *
1173:/usr/include/libusb-1.0/libusb.h **** 	 * Available since libusb-1.0.9.
1174:/usr/include/libusb-1.0/libusb.h **** 	 */
1175:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_ADD_ZERO_PACKET = 1 << 3,
1176:/usr/include/libusb-1.0/libusb.h **** };
1177:/usr/include/libusb-1.0/libusb.h **** 
1178:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1179:/usr/include/libusb-1.0/libusb.h ****  * Isochronous packet descriptor. */
1180:/usr/include/libusb-1.0/libusb.h **** struct libusb_iso_packet_descriptor {
1181:/usr/include/libusb-1.0/libusb.h **** 	/** Length of data to request in this packet */
1182:/usr/include/libusb-1.0/libusb.h **** 	unsigned int length;
1183:/usr/include/libusb-1.0/libusb.h **** 
1184:/usr/include/libusb-1.0/libusb.h **** 	/** Amount of data that was actually transferred */
1185:/usr/include/libusb-1.0/libusb.h **** 	unsigned int actual_length;
1186:/usr/include/libusb-1.0/libusb.h **** 
1187:/usr/include/libusb-1.0/libusb.h **** 	/** Status code for this packet */
1188:/usr/include/libusb-1.0/libusb.h **** 	enum libusb_transfer_status status;
1189:/usr/include/libusb-1.0/libusb.h **** };
1190:/usr/include/libusb-1.0/libusb.h **** 
1191:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer;
1192:/usr/include/libusb-1.0/libusb.h **** 
1193:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1194:/usr/include/libusb-1.0/libusb.h ****  * Asynchronous transfer callback function type. When submitting asynchronous
1195:/usr/include/libusb-1.0/libusb.h ****  * transfers, you pass a pointer to a callback function of this type via the
1196:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_transfer::callback "callback" member of the libusb_transfer
1197:/usr/include/libusb-1.0/libusb.h ****  * structure. libusb will call this function later, when the transfer has
1198:/usr/include/libusb-1.0/libusb.h ****  * completed or failed. See \ref libusb_asyncio for more information.
1199:/usr/include/libusb-1.0/libusb.h ****  * \param transfer The libusb_transfer struct the callback function is being
1200:/usr/include/libusb-1.0/libusb.h ****  * notified about.
1201:/usr/include/libusb-1.0/libusb.h ****  */
1202:/usr/include/libusb-1.0/libusb.h **** typedef void (LIBUSB_CALL *libusb_transfer_cb_fn)(struct libusb_transfer *transfer);
1203:/usr/include/libusb-1.0/libusb.h **** 
1204:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1205:/usr/include/libusb-1.0/libusb.h ****  * The generic USB transfer structure. The user populates this structure and
1206:/usr/include/libusb-1.0/libusb.h ****  * then submits it in order to request a transfer. After the transfer has
1207:/usr/include/libusb-1.0/libusb.h ****  * completed, the library populates the transfer with the results and passes
1208:/usr/include/libusb-1.0/libusb.h ****  * it back to the user.
1209:/usr/include/libusb-1.0/libusb.h ****  */
1210:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer {
1211:/usr/include/libusb-1.0/libusb.h **** 	/** Handle of the device that this transfer will be submitted to */
1212:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle;
1213:/usr/include/libusb-1.0/libusb.h **** 
1214:/usr/include/libusb-1.0/libusb.h **** 	/** A bitwise OR combination of \ref libusb_transfer_flags. */
1215:/usr/include/libusb-1.0/libusb.h **** 	uint8_t flags;
1216:/usr/include/libusb-1.0/libusb.h **** 
1217:/usr/include/libusb-1.0/libusb.h **** 	/** Address of the endpoint where this transfer will be sent. */
1218:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint;
1219:/usr/include/libusb-1.0/libusb.h **** 
1220:/usr/include/libusb-1.0/libusb.h **** 	/** Type of the endpoint from \ref libusb_transfer_type */
1221:/usr/include/libusb-1.0/libusb.h **** 	unsigned char type;
1222:/usr/include/libusb-1.0/libusb.h **** 
1223:/usr/include/libusb-1.0/libusb.h **** 	/** Timeout for this transfer in millseconds. A value of 0 indicates no
1224:/usr/include/libusb-1.0/libusb.h **** 	 * timeout. */
1225:/usr/include/libusb-1.0/libusb.h **** 	unsigned int timeout;
1226:/usr/include/libusb-1.0/libusb.h **** 
1227:/usr/include/libusb-1.0/libusb.h **** 	/** The status of the transfer. Read-only, and only for use within
1228:/usr/include/libusb-1.0/libusb.h **** 	 * transfer callback function.
1229:/usr/include/libusb-1.0/libusb.h **** 	 *
1230:/usr/include/libusb-1.0/libusb.h **** 	 * If this is an isochronous transfer, this field may read COMPLETED even
1231:/usr/include/libusb-1.0/libusb.h **** 	 * if there were errors in the frames. Use the
1232:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_iso_packet_descriptor::status "status" field in each packet
1233:/usr/include/libusb-1.0/libusb.h **** 	 * to determine if errors occurred. */
1234:/usr/include/libusb-1.0/libusb.h **** 	enum libusb_transfer_status status;
1235:/usr/include/libusb-1.0/libusb.h **** 
1236:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the data buffer */
1237:/usr/include/libusb-1.0/libusb.h **** 	int length;
1238:/usr/include/libusb-1.0/libusb.h **** 
1239:/usr/include/libusb-1.0/libusb.h **** 	/** Actual length of data that was transferred. Read-only, and only for
1240:/usr/include/libusb-1.0/libusb.h **** 	 * use within transfer callback function. Not valid for isochronous
1241:/usr/include/libusb-1.0/libusb.h **** 	 * endpoint transfers. */
1242:/usr/include/libusb-1.0/libusb.h **** 	int actual_length;
1243:/usr/include/libusb-1.0/libusb.h **** 
1244:/usr/include/libusb-1.0/libusb.h **** 	/** Callback function. This will be invoked when the transfer completes,
1245:/usr/include/libusb-1.0/libusb.h **** 	 * fails, or is cancelled. */
1246:/usr/include/libusb-1.0/libusb.h **** 	libusb_transfer_cb_fn callback;
1247:/usr/include/libusb-1.0/libusb.h **** 
1248:/usr/include/libusb-1.0/libusb.h **** 	/** User context data to pass to the callback function. */
1249:/usr/include/libusb-1.0/libusb.h **** 	void *user_data;
1250:/usr/include/libusb-1.0/libusb.h **** 
1251:/usr/include/libusb-1.0/libusb.h **** 	/** Data buffer */
1252:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer;
1253:/usr/include/libusb-1.0/libusb.h **** 
1254:/usr/include/libusb-1.0/libusb.h **** 	/** Number of isochronous packets. Only used for I/O with isochronous
1255:/usr/include/libusb-1.0/libusb.h **** 	 * endpoints. */
1256:/usr/include/libusb-1.0/libusb.h **** 	int num_iso_packets;
1257:/usr/include/libusb-1.0/libusb.h **** 
1258:/usr/include/libusb-1.0/libusb.h **** 	/** Isochronous packet descriptors, for isochronous transfers only. */
1259:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_iso_packet_descriptor iso_packet_desc
1260:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
1261:/usr/include/libusb-1.0/libusb.h **** 	[] /* valid C99 code */
1262:/usr/include/libusb-1.0/libusb.h **** #else
1263:/usr/include/libusb-1.0/libusb.h **** 	[0] /* non-standard, but usually working code */
1264:/usr/include/libusb-1.0/libusb.h **** #endif
1265:/usr/include/libusb-1.0/libusb.h **** 	;
1266:/usr/include/libusb-1.0/libusb.h **** };
1267:/usr/include/libusb-1.0/libusb.h **** 
1268:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_misc
1269:/usr/include/libusb-1.0/libusb.h ****  * Capabilities supported by an instance of libusb on the current running
1270:/usr/include/libusb-1.0/libusb.h ****  * platform. Test if the loaded library supports a given capability by calling
1271:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_has_capability().
1272:/usr/include/libusb-1.0/libusb.h ****  */
1273:/usr/include/libusb-1.0/libusb.h **** enum libusb_capability {
1274:/usr/include/libusb-1.0/libusb.h **** 	/** The libusb_has_capability() API is available. */
1275:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_CAPABILITY = 0x0000,
1276:/usr/include/libusb-1.0/libusb.h **** 	/** Hotplug support is available on this platform. */
1277:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_HOTPLUG = 0x0001,
1278:/usr/include/libusb-1.0/libusb.h **** 	/** The library can access HID devices without requiring user intervention.
1279:/usr/include/libusb-1.0/libusb.h **** 	 * Note that before being able to actually access an HID device, you may
1280:/usr/include/libusb-1.0/libusb.h **** 	 * still have to call additional libusb functions such as
1281:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_detach_kernel_driver(). */
1282:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_HID_ACCESS = 0x0100,
1283:/usr/include/libusb-1.0/libusb.h **** 	/** The library supports detaching of the default USB driver, using 
1284:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_detach_kernel_driver(), if one is set by the OS kernel */
1285:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER = 0x0101
1286:/usr/include/libusb-1.0/libusb.h **** };
1287:/usr/include/libusb-1.0/libusb.h **** 
1288:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_lib
1289:/usr/include/libusb-1.0/libusb.h ****  *  Log message levels.
1290:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_NONE (0)    : no messages ever printed by the library (default)
1291:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_ERROR (1)   : error messages are printed to stderr
1292:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_WARNING (2) : warning and error messages are printed to stderr
1293:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_INFO (3)    : informational messages are printed to stdout, warning
1294:/usr/include/libusb-1.0/libusb.h ****  *    and error messages are printed to stderr
1295:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_DEBUG (4)   : debug and informational messages are printed to stdout,
1296:/usr/include/libusb-1.0/libusb.h ****  *    warnings and errors to stderr
1297:/usr/include/libusb-1.0/libusb.h ****  */
1298:/usr/include/libusb-1.0/libusb.h **** enum libusb_log_level {
1299:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_NONE = 0,
1300:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_ERROR,
1301:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_WARNING,
1302:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_INFO,
1303:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_DEBUG,
1304:/usr/include/libusb-1.0/libusb.h **** };
1305:/usr/include/libusb-1.0/libusb.h **** 
1306:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_init(libusb_context **ctx);
1307:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_exit(libusb_context *ctx);
1308:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_set_debug(libusb_context *ctx, int level);
1309:/usr/include/libusb-1.0/libusb.h **** const struct libusb_version * LIBUSB_CALL libusb_get_version(void);
1310:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_has_capability(uint32_t capability);
1311:/usr/include/libusb-1.0/libusb.h **** const char * LIBUSB_CALL libusb_error_name(int errcode);
1312:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_setlocale(const char *locale);
1313:/usr/include/libusb-1.0/libusb.h **** const char * LIBUSB_CALL libusb_strerror(enum libusb_error errcode);
1314:/usr/include/libusb-1.0/libusb.h **** 
1315:/usr/include/libusb-1.0/libusb.h **** ssize_t LIBUSB_CALL libusb_get_device_list(libusb_context *ctx,
1316:/usr/include/libusb-1.0/libusb.h **** 	libusb_device ***list);
1317:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_device_list(libusb_device **list,
1318:/usr/include/libusb-1.0/libusb.h **** 	int unref_devices);
1319:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_ref_device(libusb_device *dev);
1320:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_unref_device(libusb_device *dev);
1321:/usr/include/libusb-1.0/libusb.h **** 
1322:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_configuration(libusb_device_handle *dev,
1323:/usr/include/libusb-1.0/libusb.h **** 	int *config);
1324:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_device_descriptor(libusb_device *dev,
1325:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_device_descriptor *desc);
1326:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_active_config_descriptor(libusb_device *dev,
1327:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_config_descriptor **config);
1328:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_config_descriptor(libusb_device *dev,
1329:/usr/include/libusb-1.0/libusb.h **** 	uint8_t config_index, struct libusb_config_descriptor **config);
1330:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_config_descriptor_by_value(libusb_device *dev,
1331:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bConfigurationValue, struct libusb_config_descriptor **config);
1332:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_config_descriptor(
1333:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_config_descriptor *config);
1334:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_ss_endpoint_companion_descriptor(
1335:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_context *ctx,
1336:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_endpoint_descriptor *endpoint,
1337:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_endpoint_companion_descriptor **ep_comp);
1338:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_ss_endpoint_companion_descriptor(
1339:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_endpoint_companion_descriptor *ep_comp);
1340:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_bos_descriptor(libusb_device_handle *dev_handle,
1341:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_descriptor **bos);
1342:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_bos_descriptor(struct libusb_bos_descriptor *bos);
1343:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_usb_2_0_extension_descriptor(
1344:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_context *ctx,
1345:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1346:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_usb_2_0_extension_descriptor **usb_2_0_extension);
1347:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_usb_2_0_extension_descriptor(
1348:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_usb_2_0_extension_descriptor *usb_2_0_extension);
1349:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_ss_usb_device_capability_descriptor(
1350:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_context *ctx,
1351:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1352:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_usb_device_capability_descriptor **ss_usb_device_cap);
1353:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_ss_usb_device_capability_descriptor(
1354:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_usb_device_capability_descriptor *ss_usb_device_cap);
1355:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_container_id_descriptor(struct libusb_context *ctx,
1356:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1357:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_container_id_descriptor **container_id);
1358:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_container_id_descriptor(
1359:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_container_id_descriptor *container_id);
1360:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_bus_number(libusb_device *dev);
1361:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_port_number(libusb_device *dev);
1362:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_port_numbers(libusb_device *dev, uint8_t* port_numbers, int port_numbers
1363:/usr/include/libusb-1.0/libusb.h **** LIBUSB_DEPRECATED_FOR(libusb_get_port_numbers)
1364:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_port_path(libusb_context *ctx, libusb_device *dev, uint8_t* path, uint8_
1365:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_get_parent(libusb_device *dev);
1366:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_device_address(libusb_device *dev);
1367:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_device_speed(libusb_device *dev);
1368:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_max_packet_size(libusb_device *dev,
1369:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1370:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_max_iso_packet_size(libusb_device *dev,
1371:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1372:/usr/include/libusb-1.0/libusb.h **** 
1373:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_open(libusb_device *dev, libusb_device_handle **dev_handle);
1374:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_close(libusb_device_handle *dev_handle);
1375:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_get_device(libusb_device_handle *dev_handle);
1376:/usr/include/libusb-1.0/libusb.h **** 
1377:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_configuration(libusb_device_handle *dev_handle,
1378:/usr/include/libusb-1.0/libusb.h **** 	int configuration);
1379:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_claim_interface(libusb_device_handle *dev_handle,
1380:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1381:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_release_interface(libusb_device_handle *dev_handle,
1382:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1383:/usr/include/libusb-1.0/libusb.h **** 
1384:/usr/include/libusb-1.0/libusb.h **** libusb_device_handle * LIBUSB_CALL libusb_open_device_with_vid_pid(
1385:/usr/include/libusb-1.0/libusb.h **** 	libusb_context *ctx, uint16_t vendor_id, uint16_t product_id);
1386:/usr/include/libusb-1.0/libusb.h **** 
1387:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_interface_alt_setting(libusb_device_handle *dev_handle,
1388:/usr/include/libusb-1.0/libusb.h **** 	int interface_number, int alternate_setting);
1389:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_clear_halt(libusb_device_handle *dev_handle,
1390:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1391:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_reset_device(libusb_device_handle *dev_handle);
1392:/usr/include/libusb-1.0/libusb.h **** 
1393:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_alloc_streams(libusb_device_handle *dev_handle,
1394:/usr/include/libusb-1.0/libusb.h **** 	uint32_t num_streams, unsigned char *endpoints, int num_endpoints);
1395:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_free_streams(libusb_device_handle *dev_handle,
1396:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *endpoints, int num_endpoints);
1397:/usr/include/libusb-1.0/libusb.h **** 
1398:/usr/include/libusb-1.0/libusb.h **** unsigned char * LIBUSB_CALL libusb_dev_mem_alloc(libusb_device_handle *dev_handle,
1399:/usr/include/libusb-1.0/libusb.h **** 	size_t length);
1400:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_dev_mem_free(libusb_device_handle *dev_handle,
1401:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, size_t length);
1402:/usr/include/libusb-1.0/libusb.h **** 
1403:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_kernel_driver_active(libusb_device_handle *dev_handle,
1404:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1405:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_detach_kernel_driver(libusb_device_handle *dev_handle,
1406:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1407:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_attach_kernel_driver(libusb_device_handle *dev_handle,
1408:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1409:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_auto_detach_kernel_driver(
1410:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle, int enable);
1411:/usr/include/libusb-1.0/libusb.h **** 
1412:/usr/include/libusb-1.0/libusb.h **** /* async I/O */
1413:/usr/include/libusb-1.0/libusb.h **** 
1414:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1415:/usr/include/libusb-1.0/libusb.h ****  * Get the data section of a control transfer. This convenience function is here
1416:/usr/include/libusb-1.0/libusb.h ****  * to remind you that the data does not start until 8 bytes into the actual
1417:/usr/include/libusb-1.0/libusb.h ****  * buffer, as the setup packet comes first.
1418:/usr/include/libusb-1.0/libusb.h ****  *
1419:/usr/include/libusb-1.0/libusb.h ****  * Calling this function only makes sense from a transfer callback function,
1420:/usr/include/libusb-1.0/libusb.h ****  * or situations where you have already allocated a suitably sized buffer at
1421:/usr/include/libusb-1.0/libusb.h ****  * transfer->buffer.
1422:/usr/include/libusb-1.0/libusb.h ****  *
1423:/usr/include/libusb-1.0/libusb.h ****  * \param transfer a transfer
1424:/usr/include/libusb-1.0/libusb.h ****  * \returns pointer to the first byte of the data section
1425:/usr/include/libusb-1.0/libusb.h ****  */
1426:/usr/include/libusb-1.0/libusb.h **** static inline unsigned char *libusb_control_transfer_get_data(
1427:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer)
1428:/usr/include/libusb-1.0/libusb.h **** {
1429:/usr/include/libusb-1.0/libusb.h **** 	return transfer->buffer + LIBUSB_CONTROL_SETUP_SIZE;
1430:/usr/include/libusb-1.0/libusb.h **** }
1431:/usr/include/libusb-1.0/libusb.h **** 
1432:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1433:/usr/include/libusb-1.0/libusb.h ****  * Get the control setup packet of a control transfer. This convenience
1434:/usr/include/libusb-1.0/libusb.h ****  * function is here to remind you that the control setup occupies the first
1435:/usr/include/libusb-1.0/libusb.h ****  * 8 bytes of the transfer data buffer.
1436:/usr/include/libusb-1.0/libusb.h ****  *
1437:/usr/include/libusb-1.0/libusb.h ****  * Calling this function only makes sense from a transfer callback function,
1438:/usr/include/libusb-1.0/libusb.h ****  * or situations where you have already allocated a suitably sized buffer at
1439:/usr/include/libusb-1.0/libusb.h ****  * transfer->buffer.
1440:/usr/include/libusb-1.0/libusb.h ****  *
1441:/usr/include/libusb-1.0/libusb.h ****  * \param transfer a transfer
1442:/usr/include/libusb-1.0/libusb.h ****  * \returns a casted pointer to the start of the transfer data buffer
1443:/usr/include/libusb-1.0/libusb.h ****  */
1444:/usr/include/libusb-1.0/libusb.h **** static inline struct libusb_control_setup *libusb_control_transfer_get_setup(
1445:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer)
1446:/usr/include/libusb-1.0/libusb.h **** {
1447:/usr/include/libusb-1.0/libusb.h **** 	return (struct libusb_control_setup *)(void *) transfer->buffer;
1448:/usr/include/libusb-1.0/libusb.h **** }
1449:/usr/include/libusb-1.0/libusb.h **** 
1450:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1451:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the setup packet (first 8 bytes of the data
1452:/usr/include/libusb-1.0/libusb.h ****  * buffer) for a control transfer. The wIndex, wValue and wLength values should
1453:/usr/include/libusb-1.0/libusb.h ****  * be given in host-endian byte order.
1454:/usr/include/libusb-1.0/libusb.h ****  *
1455:/usr/include/libusb-1.0/libusb.h ****  * \param buffer buffer to output the setup packet into
1456:/usr/include/libusb-1.0/libusb.h ****  * This pointer must be aligned to at least 2 bytes boundary.
1457:/usr/include/libusb-1.0/libusb.h ****  * \param bmRequestType see the
1458:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field of
1459:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1460:/usr/include/libusb-1.0/libusb.h ****  * \param bRequest see the
1461:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bRequest "bRequest" field of
1462:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1463:/usr/include/libusb-1.0/libusb.h ****  * \param wValue see the
1464:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wValue "wValue" field of
1465:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1466:/usr/include/libusb-1.0/libusb.h ****  * \param wIndex see the
1467:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wIndex "wIndex" field of
1468:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1469:/usr/include/libusb-1.0/libusb.h ****  * \param wLength see the
1470:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wLength "wLength" field of
1471:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1472:/usr/include/libusb-1.0/libusb.h ****  */
1473:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_control_setup(unsigned char *buffer,
1474:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex,
1475:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wLength)
1476:/usr/include/libusb-1.0/libusb.h **** {
1477:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *) buffer;
1478:/usr/include/libusb-1.0/libusb.h **** 	setup->bmRequestType = bmRequestType;
1479:/usr/include/libusb-1.0/libusb.h **** 	setup->bRequest = bRequest;
1480:/usr/include/libusb-1.0/libusb.h **** 	setup->wValue = libusb_cpu_to_le16(wValue);
1481:/usr/include/libusb-1.0/libusb.h **** 	setup->wIndex = libusb_cpu_to_le16(wIndex);
1482:/usr/include/libusb-1.0/libusb.h **** 	setup->wLength = libusb_cpu_to_le16(wLength);
1483:/usr/include/libusb-1.0/libusb.h **** }
1484:/usr/include/libusb-1.0/libusb.h **** 
1485:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer * LIBUSB_CALL libusb_alloc_transfer(int iso_packets);
1486:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_submit_transfer(struct libusb_transfer *transfer);
1487:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_cancel_transfer(struct libusb_transfer *transfer);
1488:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_transfer(struct libusb_transfer *transfer);
1489:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_transfer_set_stream_id(
1490:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer, uint32_t stream_id);
1491:/usr/include/libusb-1.0/libusb.h **** uint32_t LIBUSB_CALL libusb_transfer_get_stream_id(
1492:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer);
1493:/usr/include/libusb-1.0/libusb.h **** 
1494:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1495:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the required \ref libusb_transfer fields
1496:/usr/include/libusb-1.0/libusb.h ****  * for a control transfer.
1497:/usr/include/libusb-1.0/libusb.h ****  *
1498:/usr/include/libusb-1.0/libusb.h ****  * If you pass a transfer buffer to this function, the first 8 bytes will
1499:/usr/include/libusb-1.0/libusb.h ****  * be interpreted as a control setup packet, and the wLength field will be
1500:/usr/include/libusb-1.0/libusb.h ****  * used to automatically populate the \ref libusb_transfer::length "length"
1501:/usr/include/libusb-1.0/libusb.h ****  * field of the transfer. Therefore the recommended approach is:
1502:/usr/include/libusb-1.0/libusb.h ****  * -# Allocate a suitably sized data buffer (including space for control setup)
1503:/usr/include/libusb-1.0/libusb.h ****  * -# Call libusb_fill_control_setup()
1504:/usr/include/libusb-1.0/libusb.h ****  * -# If this is a host-to-device transfer with a data stage, put the data
1505:/usr/include/libusb-1.0/libusb.h ****  *    in place after the setup packet
1506:/usr/include/libusb-1.0/libusb.h ****  * -# Call this function
1507:/usr/include/libusb-1.0/libusb.h ****  * -# Call libusb_submit_transfer()
1508:/usr/include/libusb-1.0/libusb.h ****  *
1509:/usr/include/libusb-1.0/libusb.h ****  * It is also legal to pass a NULL buffer to this function, in which case this
1510:/usr/include/libusb-1.0/libusb.h ****  * function will not attempt to populate the length field. Remember that you
1511:/usr/include/libusb-1.0/libusb.h ****  * must then populate the buffer and length fields later.
1512:/usr/include/libusb-1.0/libusb.h ****  *
1513:/usr/include/libusb-1.0/libusb.h ****  * \param transfer the transfer to populate
1514:/usr/include/libusb-1.0/libusb.h ****  * \param dev_handle handle of the device that will handle the transfer
1515:/usr/include/libusb-1.0/libusb.h ****  * \param buffer data buffer. If provided, this function will interpret the
1516:/usr/include/libusb-1.0/libusb.h ****  * first 8 bytes as a setup packet and infer the transfer length from that.
1517:/usr/include/libusb-1.0/libusb.h ****  * This pointer must be aligned to at least 2 bytes boundary.
1518:/usr/include/libusb-1.0/libusb.h ****  * \param callback callback function to be invoked on transfer completion
1519:/usr/include/libusb-1.0/libusb.h ****  * \param user_data user data to pass to callback function
1520:/usr/include/libusb-1.0/libusb.h ****  * \param timeout timeout for the transfer in milliseconds
1521:/usr/include/libusb-1.0/libusb.h ****  */
1522:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_control_transfer(
1523:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer, libusb_device_handle *dev_handle,
1524:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, libusb_transfer_cb_fn callback, void *user_data,
1525:/usr/include/libusb-1.0/libusb.h **** 	unsigned int timeout)
1526:/usr/include/libusb-1.0/libusb.h **** {
1527:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *) buffer;
1528:/usr/include/libusb-1.0/libusb.h **** 	transfer->dev_handle = dev_handle;
1529:/usr/include/libusb-1.0/libusb.h **** 	transfer->endpoint = 0;
1530:/usr/include/libusb-1.0/libusb.h **** 	transfer->type = LIBUSB_TRANSFER_TYPE_CONTROL;
1531:/usr/include/libusb-1.0/libusb.h **** 	transfer->timeout = timeout;
1532:/usr/include/libusb-1.0/libusb.h **** 	transfer->buffer = buffer;
1533:/usr/include/libusb-1.0/libusb.h **** 	if (setup)
1534:/usr/include/libusb-1.0/libusb.h **** 		transfer->length = (int) (LIBUSB_CONTROL_SETUP_SIZE
1535:/usr/include/libusb-1.0/libusb.h **** 			+ libusb_le16_to_cpu(setup->wLength));
1536:/usr/include/libusb-1.0/libusb.h **** 	transfer->user_data = user_data;
1537:/usr/include/libusb-1.0/libusb.h **** 	transfer->callback = callback;
1538:/usr/include/libusb-1.0/libusb.h **** }
1539:/usr/include/libusb-1.0/libusb.h **** 
1540:/usr/include/libusb-1.0/libusb.h **** /** \ingroup libusb_asyncio
1541:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the required \ref libusb_transfer fields
1542:/usr/include/libusb-1.0/libusb.h ****  * for a bulk transfer.
1543:/usr/include/libusb-1.0/libusb.h ****  *
1544:/usr/include/libusb-1.0/libusb.h ****  * \param transfer the transfer to populate
1545:/usr/include/libusb-1.0/libusb.h ****  * \param dev_handle handle of the device that will handle the transfer
1546:/usr/include/libusb-1.0/libusb.h ****  * \param endpoint address of the endpoint where this transfer will be sent
1547:/usr/include/libusb-1.0/libusb.h ****  * \param buffer data buffer
1548:/usr/include/libusb-1.0/libusb.h ****  * \param length length of data buffer
1549:/usr/include/libusb-1.0/libusb.h ****  * \param callback callback function to be invoked on transfer completion
1550:/usr/include/libusb-1.0/libusb.h ****  * \param user_data user data to pass to callback function
1551:/usr/include/libusb-1.0/libusb.h ****  * \param timeout timeout for the transfer in milliseconds
1552:/usr/include/libusb-1.0/libusb.h ****  */
1553:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_bulk_transfer(struct libusb_transfer *transfer,
1554:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle, unsigned char endpoint,
1555:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, int length, libusb_transfer_cb_fn callback,
1556:/usr/include/libusb-1.0/libusb.h **** 	void *user_data, unsigned int timeout)
1557:/usr/include/libusb-1.0/libusb.h **** {
  30              		.loc 2 1557 0
  31              		.cfi_startproc
  32 0012 55       		pushq	%rbp
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 6, -16
  35 0013 4889E5   		movq	%rsp, %rbp
  36              		.cfi_def_cfa_register 6
  37 0016 48897DF8 		movq	%rdi, -8(%rbp)
  38 001a 488975F0 		movq	%rsi, -16(%rbp)
  39 001e 89D0     		movl	%edx, %eax
  40 0020 48894DE0 		movq	%rcx, -32(%rbp)
  41 0024 448945E8 		movl	%r8d, -24(%rbp)
  42 0028 4C894DD8 		movq	%r9, -40(%rbp)
  43 002c 8845EC   		movb	%al, -20(%rbp)
1558:/usr/include/libusb-1.0/libusb.h **** 	transfer->dev_handle = dev_handle;
  44              		.loc 2 1558 0
  45 002f 488B45F8 		movq	-8(%rbp), %rax
  46 0033 488B55F0 		movq	-16(%rbp), %rdx
  47 0037 488910   		movq	%rdx, (%rax)
1559:/usr/include/libusb-1.0/libusb.h **** 	transfer->endpoint = endpoint;
  48              		.loc 2 1559 0
  49 003a 488B45F8 		movq	-8(%rbp), %rax
  50 003e 0FB655EC 		movzbl	-20(%rbp), %edx
  51 0042 885009   		movb	%dl, 9(%rax)
1560:/usr/include/libusb-1.0/libusb.h **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
  52              		.loc 2 1560 0
  53 0045 488B45F8 		movq	-8(%rbp), %rax
  54 0049 C6400A02 		movb	$2, 10(%rax)
1561:/usr/include/libusb-1.0/libusb.h **** 	transfer->timeout = timeout;
  55              		.loc 2 1561 0
  56 004d 488B45F8 		movq	-8(%rbp), %rax
  57 0051 8B5518   		movl	24(%rbp), %edx
  58 0054 89500C   		movl	%edx, 12(%rax)
1562:/usr/include/libusb-1.0/libusb.h **** 	transfer->buffer = buffer;
  59              		.loc 2 1562 0
  60 0057 488B45F8 		movq	-8(%rbp), %rax
  61 005b 488B55E0 		movq	-32(%rbp), %rdx
  62 005f 48895030 		movq	%rdx, 48(%rax)
1563:/usr/include/libusb-1.0/libusb.h **** 	transfer->length = length;
  63              		.loc 2 1563 0
  64 0063 488B45F8 		movq	-8(%rbp), %rax
  65 0067 8B55E8   		movl	-24(%rbp), %edx
  66 006a 895014   		movl	%edx, 20(%rax)
1564:/usr/include/libusb-1.0/libusb.h **** 	transfer->user_data = user_data;
  67              		.loc 2 1564 0
  68 006d 488B45F8 		movq	-8(%rbp), %rax
  69 0071 488B5510 		movq	16(%rbp), %rdx
  70 0075 48895028 		movq	%rdx, 40(%rax)
1565:/usr/include/libusb-1.0/libusb.h **** 	transfer->callback = callback;
  71              		.loc 2 1565 0
  72 0079 488B45F8 		movq	-8(%rbp), %rax
  73 007d 488B55D8 		movq	-40(%rbp), %rdx
  74 0081 48895020 		movq	%rdx, 32(%rax)
1566:/usr/include/libusb-1.0/libusb.h **** }
  75              		.loc 2 1566 0
  76 0085 90       		nop
  77 0086 5D       		popq	%rbp
  78              		.cfi_def_cfa 7, 8
  79 0087 C3       		ret
  80              		.cfi_endproc
  81              	.LFE15:
  83              		.local	m_ctx
  84              		.comm	m_ctx,8,8
  85              		.section	.rodata
  86              	.LC0:
  87 0000 64657669 		.string	"device not found"
  87      6365206E 
  87      6F742066 
  87      6F756E64 
  87      00
  88              		.text
  90              	libusbOpenWithVidPid:
  91              	.LFB24:
  92              		.file 3 "libusbwrap.c"
   1:libusbwrap.c  **** /*
   2:libusbwrap.c  ****  * Copyright (C) 2009-2012 Chris McClelland
   3:libusbwrap.c  ****  *
   4:libusbwrap.c  ****  * This program is free software: you can redistribute it and/or modify
   5:libusbwrap.c  ****  * it under the terms of the GNU Lesser General Public License as published by
   6:libusbwrap.c  ****  * the Free Software Foundation, either version 3 of the License, or
   7:libusbwrap.c  ****  * (at your option) any later version.
   8:libusbwrap.c  ****  *
   9:libusbwrap.c  ****  * This program is distributed in the hope that it will be useful,
  10:libusbwrap.c  ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:libusbwrap.c  ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:libusbwrap.c  ****  * GNU Lesser General Public License for more details.
  13:libusbwrap.c  ****  *
  14:libusbwrap.c  ****  * You should have received a copy of the GNU Lesser General Public License
  15:libusbwrap.c  ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:libusbwrap.c  ****  */
  17:libusbwrap.c  **** #ifdef WIN32
  18:libusbwrap.c  **** #include <Windows.h>
  19:libusbwrap.c  **** #else
  20:libusbwrap.c  **** #define _BSD_SOURCE
  21:libusbwrap.c  **** #include <unistd.h>
  22:libusbwrap.c  **** #endif
  23:libusbwrap.c  **** #include <stdio.h>
  24:libusbwrap.c  **** #include <stdlib.h>
  25:libusbwrap.c  **** #include <string.h>
  26:libusbwrap.c  **** #include <makestuff.h>
  27:libusbwrap.c  **** #include <liberror.h>
  28:libusbwrap.c  **** #include "private.h"
  29:libusbwrap.c  **** 
  30:libusbwrap.c  **** static struct libusb_context *m_ctx = NULL;
  31:libusbwrap.c  **** 
  32:libusbwrap.c  **** // Modified from libusb_open_device_with_vid_pid in core.c of libusbx
  33:libusbwrap.c  **** //
  34:libusbwrap.c  **** static libusb_device_handle *libusbOpenWithVidPid(
  35:libusbwrap.c  **** 	libusb_context *ctx, uint16 vid, uint16 pid, uint16 did, const char **error)
  36:libusbwrap.c  **** {
  93              		.loc 3 36 0
  94              		.cfi_startproc
  95 0088 55       		pushq	%rbp
  96              		.cfi_def_cfa_offset 16
  97              		.cfi_offset 6, -16
  98 0089 4889E5   		movq	%rsp, %rbp
  99              		.cfi_def_cfa_register 6
 100 008c 4883EC70 		subq	$112, %rsp
 101 0090 48897DA8 		movq	%rdi, -88(%rbp)
 102 0094 89C8     		movl	%ecx, %eax
 103 0096 4C894590 		movq	%r8, -112(%rbp)
 104 009a 89F1     		movl	%esi, %ecx
 105 009c 66894DA4 		movw	%cx, -92(%rbp)
 106 00a0 668955A0 		movw	%dx, -96(%rbp)
 107 00a4 6689459C 		movw	%ax, -100(%rbp)
 108              		.loc 3 36 0
 109 00a8 64488B04 		movq	%fs:40, %rax
 109      25280000 
 109      00
 110 00b1 488945F8 		movq	%rax, -8(%rbp)
 111 00b5 31C0     		xorl	%eax, %eax
  37:libusbwrap.c  **** 	libusb_device_handle *retVal = NULL;
 112              		.loc 3 37 0
 113 00b7 48C745B8 		movq	$0, -72(%rbp)
 113      00000000 
  38:libusbwrap.c  **** 	struct libusb_device **devs;
  39:libusbwrap.c  **** 	struct libusb_device *found = NULL;
 114              		.loc 3 39 0
 115 00bf 48C745C8 		movq	$0, -56(%rbp)
 115      00000000 
  40:libusbwrap.c  **** 	struct libusb_device *dev;
  41:libusbwrap.c  **** 	size_t i = 0;
 116              		.loc 3 41 0
 117 00c7 48C745D8 		movq	$0, -40(%rbp)
 117      00000000 
  42:libusbwrap.c  **** 	int status = (int)libusb_get_device_list(ctx, &devs);
 118              		.loc 3 42 0
 119 00cf 488D55C0 		leaq	-64(%rbp), %rdx
 120 00d3 488B45A8 		movq	-88(%rbp), %rax
 121 00d7 4889D6   		movq	%rdx, %rsi
 122 00da 4889C7   		movq	%rax, %rdi
 123 00dd E8000000 		call	libusb_get_device_list@PLT
 123      00
 124 00e2 8945B4   		movl	%eax, -76(%rbp)
  43:libusbwrap.c  **** 	CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 125              		.loc 3 43 0
 126 00e5 837DB400 		cmpl	$0, -76(%rbp)
 127 00e9 7929     		jns	.L5
 128              		.loc 3 43 0 is_stmt 0 discriminator 1
 129 00eb 8B45B4   		movl	-76(%rbp), %eax
 130 00ee 89C7     		movl	%eax, %edi
 131 00f0 E8000000 		call	libusb_error_name@PLT
 131      00
 132 00f5 4889C2   		movq	%rax, %rdx
 133 00f8 488B4590 		movq	-112(%rbp), %rax
 134 00fc 4889D6   		movq	%rdx, %rsi
 135 00ff 4889C7   		movq	%rax, %rdi
 136 0102 E8000000 		call	errPrefix@PLT
 136      00
 137 0107 48C745B8 		movq	$0, -72(%rbp)
 137      00000000 
 138 010f E9210100 		jmp	.L6
 138      00
 139              	.L5:
  44:libusbwrap.c  **** 	dev = devs[i++];
 140              		.loc 3 44 0 is_stmt 1
 141 0114 488B4DC0 		movq	-64(%rbp), %rcx
 142 0118 488B45D8 		movq	-40(%rbp), %rax
 143 011c 488D5001 		leaq	1(%rax), %rdx
 144 0120 488955D8 		movq	%rdx, -40(%rbp)
 145 0124 48C1E003 		salq	$3, %rax
 146 0128 4801C8   		addq	%rcx, %rax
 147 012b 488B00   		movq	(%rax), %rax
 148 012e 488945D0 		movq	%rax, -48(%rbp)
  45:libusbwrap.c  **** 	while ( dev ) {
 149              		.loc 3 45 0
 150 0132 E9920000 		jmp	.L7
 150      00
 151              	.L12:
 152              	.LBB2:
  46:libusbwrap.c  **** 		struct libusb_device_descriptor desc;
  47:libusbwrap.c  **** 		status = libusb_get_device_descriptor(dev, &desc);
 153              		.loc 3 47 0
 154 0137 488D55E0 		leaq	-32(%rbp), %rdx
 155 013b 488B45D0 		movq	-48(%rbp), %rax
 156 013f 4889D6   		movq	%rdx, %rsi
 157 0142 4889C7   		movq	%rax, %rdi
 158 0145 E8000000 		call	libusb_get_device_descriptor@PLT
 158      00
 159 014a 8945B4   		movl	%eax, -76(%rbp)
  48:libusbwrap.c  **** 		CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 160              		.loc 3 48 0
 161 014d 837DB400 		cmpl	$0, -76(%rbp)
 162 0151 7929     		jns	.L8
 163              		.loc 3 48 0 is_stmt 0 discriminator 1
 164 0153 8B45B4   		movl	-76(%rbp), %eax
 165 0156 89C7     		movl	%eax, %edi
 166 0158 E8000000 		call	libusb_error_name@PLT
 166      00
 167 015d 4889C2   		movq	%rax, %rdx
 168 0160 488B4590 		movq	-112(%rbp), %rax
 169 0164 4889D6   		movq	%rdx, %rsi
 170 0167 4889C7   		movq	%rax, %rdi
 171 016a E8000000 		call	errPrefix@PLT
 171      00
 172 016f 48C745B8 		movq	$0, -72(%rbp)
 172      00000000 
 173 0177 E9B90000 		jmp	.L6
 173      00
 174              	.L8:
  49:libusbwrap.c  **** 		if (
  50:libusbwrap.c  **** 			desc.idVendor == vid &&
 175              		.loc 3 50 0 is_stmt 1
 176 017c 0FB745E8 		movzwl	-24(%rbp), %eax
  49:libusbwrap.c  **** 		if (
 177              		.loc 3 49 0
 178 0180 663945A4 		cmpw	%ax, -92(%rbp)
 179 0184 7525     		jne	.L9
  51:libusbwrap.c  **** 			desc.idProduct == pid &&
 180              		.loc 3 51 0
 181 0186 0FB745EA 		movzwl	-22(%rbp), %eax
  50:libusbwrap.c  **** 			desc.idProduct == pid &&
 182              		.loc 3 50 0
 183 018a 663945A0 		cmpw	%ax, -96(%rbp)
 184 018e 751B     		jne	.L9
 185              		.loc 3 51 0
 186 0190 66837D9C 		cmpw	$0, -100(%rbp)
 186      00
 187 0195 740A     		je	.L10
  52:libusbwrap.c  **** 			(did == 0x0000 || desc.bcdDevice == did)
 188              		.loc 3 52 0
 189 0197 0FB745EC 		movzwl	-20(%rbp), %eax
 190 019b 6639459C 		cmpw	%ax, -100(%rbp)
 191 019f 750A     		jne	.L9
 192              	.L10:
  53:libusbwrap.c  **** 		) {
  54:libusbwrap.c  **** 			found = dev;
 193              		.loc 3 54 0
 194 01a1 488B45D0 		movq	-48(%rbp), %rax
 195 01a5 488945C8 		movq	%rax, -56(%rbp)
 196 01a9 EB29     		jmp	.L11
 197              	.L9:
  55:libusbwrap.c  **** 			break;
  56:libusbwrap.c  **** 		}
  57:libusbwrap.c  **** 		dev = devs[i++];
 198              		.loc 3 57 0
 199 01ab 488B4DC0 		movq	-64(%rbp), %rcx
 200 01af 488B45D8 		movq	-40(%rbp), %rax
 201 01b3 488D5001 		leaq	1(%rax), %rdx
 202 01b7 488955D8 		movq	%rdx, -40(%rbp)
 203 01bb 48C1E003 		salq	$3, %rax
 204 01bf 4801C8   		addq	%rcx, %rax
 205 01c2 488B00   		movq	(%rax), %rax
 206 01c5 488945D0 		movq	%rax, -48(%rbp)
 207              	.L7:
 208              	.LBE2:
  45:libusbwrap.c  **** 		struct libusb_device_descriptor desc;
 209              		.loc 3 45 0
 210 01c9 48837DD0 		cmpq	$0, -48(%rbp)
 210      00
 211 01ce 0F8563FF 		jne	.L12
 211      FFFF
 212              	.L11:
  58:libusbwrap.c  **** 	}
  59:libusbwrap.c  **** 
  60:libusbwrap.c  **** 	if ( found ) {
 213              		.loc 3 60 0
 214 01d4 48837DC8 		cmpq	$0, -56(%rbp)
 214      00
 215 01d9 7442     		je	.L13
  61:libusbwrap.c  **** 		status = libusb_open(found, &retVal);
 216              		.loc 3 61 0
 217 01db 488D55B8 		leaq	-72(%rbp), %rdx
 218 01df 488B45C8 		movq	-56(%rbp), %rax
 219 01e3 4889D6   		movq	%rdx, %rsi
 220 01e6 4889C7   		movq	%rax, %rdi
 221 01e9 E8000000 		call	libusb_open@PLT
 221      00
 222 01ee 8945B4   		movl	%eax, -76(%rbp)
  62:libusbwrap.c  **** 		CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 223              		.loc 3 62 0
 224 01f1 837DB400 		cmpl	$0, -76(%rbp)
 225 01f5 793E     		jns	.L6
 226              		.loc 3 62 0 is_stmt 0 discriminator 1
 227 01f7 8B45B4   		movl	-76(%rbp), %eax
 228 01fa 89C7     		movl	%eax, %edi
 229 01fc E8000000 		call	libusb_error_name@PLT
 229      00
 230 0201 4889C2   		movq	%rax, %rdx
 231 0204 488B4590 		movq	-112(%rbp), %rax
 232 0208 4889D6   		movq	%rdx, %rsi
 233 020b 4889C7   		movq	%rax, %rdi
 234 020e E8000000 		call	errPrefix@PLT
 234      00
 235 0213 48C745B8 		movq	$0, -72(%rbp)
 235      00000000 
 236 021b EB18     		jmp	.L6
 237              	.L13:
  63:libusbwrap.c  **** 	} else {
  64:libusbwrap.c  **** 		errRender(error, "device not found");
 238              		.loc 3 64 0 is_stmt 1
 239 021d 488B4590 		movq	-112(%rbp), %rax
 240 0221 488D3500 		leaq	.LC0(%rip), %rsi
 240      000000
 241 0228 4889C7   		movq	%rax, %rdi
 242 022b B8000000 		movl	$0, %eax
 242      00
 243 0230 E8000000 		call	errRender@PLT
 243      00
 244              	.L6:
  65:libusbwrap.c  **** 	}
  66:libusbwrap.c  **** 
  67:libusbwrap.c  **** cleanup:
  68:libusbwrap.c  **** 	libusb_free_device_list(devs, 1);
 245              		.loc 3 68 0
 246 0235 488B45C0 		movq	-64(%rbp), %rax
 247 0239 BE010000 		movl	$1, %esi
 247      00
 248 023e 4889C7   		movq	%rax, %rdi
 249 0241 E8000000 		call	libusb_free_device_list@PLT
 249      00
  69:libusbwrap.c  **** 	return retVal;
 250              		.loc 3 69 0
 251 0246 488B45B8 		movq	-72(%rbp), %rax
  70:libusbwrap.c  **** }
 252              		.loc 3 70 0
 253 024a 488B4DF8 		movq	-8(%rbp), %rcx
 254 024e 6448330C 		xorq	%fs:40, %rcx
 254      25280000 
 254      00
 255 0257 7405     		je	.L15
 256 0259 E8000000 		call	__stack_chk_fail@PLT
 256      00
 257              	.L15:
 258 025e C9       		leave
 259              		.cfi_def_cfa 7, 8
 260 025f C3       		ret
 261              		.cfi_endproc
 262              	.LFE24:
 264              		.globl	usbValidateVidPid
 266              	usbValidateVidPid:
 267              	.LFB25:
  71:libusbwrap.c  **** 
  72:libusbwrap.c  **** // Return true if vp is VVVV:PPPP where V and P are hex digits:
  73:libusbwrap.c  **** //
  74:libusbwrap.c  **** DLLEXPORT(bool) usbValidateVidPid(const char *vp) {
 268              		.loc 3 74 0
 269              		.cfi_startproc
 270 0260 55       		pushq	%rbp
 271              		.cfi_def_cfa_offset 16
 272              		.cfi_offset 6, -16
 273 0261 4889E5   		movq	%rsp, %rbp
 274              		.cfi_def_cfa_register 6
 275 0264 4883EC20 		subq	$32, %rsp
 276 0268 48897DE8 		movq	%rdi, -24(%rbp)
  75:libusbwrap.c  **** 	int i;
  76:libusbwrap.c  **** 	char ch;
  77:libusbwrap.c  **** 	const size_t len = strlen(vp);
 277              		.loc 3 77 0
 278 026c 488B45E8 		movq	-24(%rbp), %rax
 279 0270 4889C7   		movq	%rax, %rdi
 280 0273 E8000000 		call	strlen@PLT
 280      00
 281 0278 488945F8 		movq	%rax, -8(%rbp)
  78:libusbwrap.c  **** 	bool hasDID;
  79:libusbwrap.c  **** 	if ( !vp ) {
 282              		.loc 3 79 0
 283 027c 48837DE8 		cmpq	$0, -24(%rbp)
 283      00
 284 0281 750A     		jne	.L17
  80:libusbwrap.c  **** 		return false;
 285              		.loc 3 80 0
 286 0283 B8000000 		movl	$0, %eax
 286      00
 287 0288 E9530100 		jmp	.L18
 287      00
 288              	.L17:
  81:libusbwrap.c  **** 	}
  82:libusbwrap.c  **** 	if ( len == 9 ) {
 289              		.loc 3 82 0
 290 028d 48837DF8 		cmpq	$9, -8(%rbp)
 290      09
 291 0292 7506     		jne	.L19
  83:libusbwrap.c  **** 		hasDID = false;
 292              		.loc 3 83 0
 293 0294 C645F200 		movb	$0, -14(%rbp)
 294 0298 EB17     		jmp	.L20
 295              	.L19:
  84:libusbwrap.c  **** 	} else if ( len == 14 ) {
 296              		.loc 3 84 0
 297 029a 48837DF8 		cmpq	$14, -8(%rbp)
 297      0E
 298 029f 7506     		jne	.L21
  85:libusbwrap.c  **** 		hasDID = true;
 299              		.loc 3 85 0
 300 02a1 C645F201 		movb	$1, -14(%rbp)
 301 02a5 EB0A     		jmp	.L20
 302              	.L21:
  86:libusbwrap.c  **** 	} else {
  87:libusbwrap.c  **** 		return false;
 303              		.loc 3 87 0
 304 02a7 B8000000 		movl	$0, %eax
 304      00
 305 02ac E92F0100 		jmp	.L18
 305      00
 306              	.L20:
  88:libusbwrap.c  **** 	}
  89:libusbwrap.c  **** 	if ( vp[4] != ':' || (hasDID && vp[9] != ':') ) {
 307              		.loc 3 89 0
 308 02b1 488B45E8 		movq	-24(%rbp), %rax
 309 02b5 4883C004 		addq	$4, %rax
 310 02b9 0FB600   		movzbl	(%rax), %eax
 311 02bc 3C3A     		cmpb	$58, %al
 312 02be 7515     		jne	.L22
 313              		.loc 3 89 0 is_stmt 0 discriminator 1
 314 02c0 807DF200 		cmpb	$0, -14(%rbp)
 315 02c4 7419     		je	.L23
 316              		.loc 3 89 0 discriminator 2
 317 02c6 488B45E8 		movq	-24(%rbp), %rax
 318 02ca 4883C009 		addq	$9, %rax
 319 02ce 0FB600   		movzbl	(%rax), %eax
 320 02d1 3C3A     		cmpb	$58, %al
 321 02d3 740A     		je	.L23
 322              	.L22:
  90:libusbwrap.c  **** 		return false;
 323              		.loc 3 90 0 is_stmt 1
 324 02d5 B8000000 		movl	$0, %eax
 324      00
 325 02da E9010100 		jmp	.L18
 325      00
 326              	.L23:
  91:libusbwrap.c  **** 	}
  92:libusbwrap.c  **** 	for ( i = 0; i < 4; i++ ) {
 327              		.loc 3 92 0
 328 02df C745F400 		movl	$0, -12(%rbp)
 328      000000
 329 02e6 EB45     		jmp	.L24
 330              	.L29:
  93:libusbwrap.c  **** 		ch = vp[i];
 331              		.loc 3 93 0
 332 02e8 8B45F4   		movl	-12(%rbp), %eax
 333 02eb 4863D0   		movslq	%eax, %rdx
 334 02ee 488B45E8 		movq	-24(%rbp), %rax
 335 02f2 4801D0   		addq	%rdx, %rax
 336 02f5 0FB600   		movzbl	(%rax), %eax
 337 02f8 8845F3   		movb	%al, -13(%rbp)
  94:libusbwrap.c  **** 		if (
 338              		.loc 3 94 0
 339 02fb 807DF32F 		cmpb	$47, -13(%rbp)
 340 02ff 7E1E     		jle	.L25
  95:libusbwrap.c  **** 			ch < '0' ||
 341              		.loc 3 95 0
 342 0301 807DF339 		cmpb	$57, -13(%rbp)
 343 0305 7E06     		jle	.L26
  96:libusbwrap.c  **** 			(ch > '9' && ch < 'A') ||
 344              		.loc 3 96 0
 345 0307 807DF340 		cmpb	$64, -13(%rbp)
 346 030b 7E12     		jle	.L25
 347              	.L26:
 348              		.loc 3 96 0 is_stmt 0 discriminator 1
 349 030d 807DF346 		cmpb	$70, -13(%rbp)
 350 0311 7E06     		jle	.L27
  97:libusbwrap.c  **** 			(ch > 'F' && ch < 'a') ||
 351              		.loc 3 97 0 is_stmt 1
 352 0313 807DF360 		cmpb	$96, -13(%rbp)
 353 0317 7E06     		jle	.L25
 354              	.L27:
 355              		.loc 3 97 0 is_stmt 0 discriminator 1
 356 0319 807DF366 		cmpb	$102, -13(%rbp)
 357 031d 7E0A     		jle	.L28
 358              	.L25:
  98:libusbwrap.c  **** 			ch > 'f')
  99:libusbwrap.c  **** 		{
 100:libusbwrap.c  **** 			return false;
 359              		.loc 3 100 0 is_stmt 1
 360 031f B8000000 		movl	$0, %eax
 360      00
 361 0324 E9B70000 		jmp	.L18
 361      00
 362              	.L28:
  92:libusbwrap.c  **** 		ch = vp[i];
 363              		.loc 3 92 0 discriminator 2
 364 0329 8345F401 		addl	$1, -12(%rbp)
 365              	.L24:
  92:libusbwrap.c  **** 		ch = vp[i];
 366              		.loc 3 92 0 is_stmt 0 discriminator 1
 367 032d 837DF403 		cmpl	$3, -12(%rbp)
 368 0331 7EB5     		jle	.L29
 101:libusbwrap.c  **** 		}
 102:libusbwrap.c  **** 	}
 103:libusbwrap.c  **** 	for ( i = 5; i < 9; i++ ) {
 369              		.loc 3 103 0 is_stmt 1
 370 0333 C745F405 		movl	$5, -12(%rbp)
 370      000000
 371 033a EB42     		jmp	.L30
 372              	.L35:
 104:libusbwrap.c  **** 		ch = vp[i];
 373              		.loc 3 104 0
 374 033c 8B45F4   		movl	-12(%rbp), %eax
 375 033f 4863D0   		movslq	%eax, %rdx
 376 0342 488B45E8 		movq	-24(%rbp), %rax
 377 0346 4801D0   		addq	%rdx, %rax
 378 0349 0FB600   		movzbl	(%rax), %eax
 379 034c 8845F3   		movb	%al, -13(%rbp)
 105:libusbwrap.c  **** 		if (
 380              		.loc 3 105 0
 381 034f 807DF32F 		cmpb	$47, -13(%rbp)
 382 0353 7E1E     		jle	.L31
 106:libusbwrap.c  **** 			ch < '0' ||
 383              		.loc 3 106 0
 384 0355 807DF339 		cmpb	$57, -13(%rbp)
 385 0359 7E06     		jle	.L32
 107:libusbwrap.c  **** 			(ch > '9' && ch < 'A') ||
 386              		.loc 3 107 0
 387 035b 807DF340 		cmpb	$64, -13(%rbp)
 388 035f 7E12     		jle	.L31
 389              	.L32:
 390              		.loc 3 107 0 is_stmt 0 discriminator 1
 391 0361 807DF346 		cmpb	$70, -13(%rbp)
 392 0365 7E06     		jle	.L33
 108:libusbwrap.c  **** 			(ch > 'F' && ch < 'a') ||
 393              		.loc 3 108 0 is_stmt 1
 394 0367 807DF360 		cmpb	$96, -13(%rbp)
 395 036b 7E06     		jle	.L31
 396              	.L33:
 397              		.loc 3 108 0 is_stmt 0 discriminator 1
 398 036d 807DF366 		cmpb	$102, -13(%rbp)
 399 0371 7E07     		jle	.L34
 400              	.L31:
 109:libusbwrap.c  **** 			ch > 'f')
 110:libusbwrap.c  **** 		{
 111:libusbwrap.c  **** 			return false;
 401              		.loc 3 111 0 is_stmt 1
 402 0373 B8000000 		movl	$0, %eax
 402      00
 403 0378 EB66     		jmp	.L18
 404              	.L34:
 103:libusbwrap.c  **** 		ch = vp[i];
 405              		.loc 3 103 0 discriminator 2
 406 037a 8345F401 		addl	$1, -12(%rbp)
 407              	.L30:
 103:libusbwrap.c  **** 		ch = vp[i];
 408              		.loc 3 103 0 is_stmt 0 discriminator 1
 409 037e 837DF408 		cmpl	$8, -12(%rbp)
 410 0382 7EB8     		jle	.L35
 112:libusbwrap.c  **** 		}
 113:libusbwrap.c  **** 	}
 114:libusbwrap.c  **** 	if ( hasDID ) {
 411              		.loc 3 114 0 is_stmt 1
 412 0384 807DF200 		cmpb	$0, -14(%rbp)
 413 0388 7451     		je	.L36
 115:libusbwrap.c  **** 		for ( i = 10; i < 14; i++ ) {
 414              		.loc 3 115 0
 415 038a C745F40A 		movl	$10, -12(%rbp)
 415      000000
 416 0391 EB42     		jmp	.L37
 417              	.L42:
 116:libusbwrap.c  **** 			ch = vp[i];
 418              		.loc 3 116 0
 419 0393 8B45F4   		movl	-12(%rbp), %eax
 420 0396 4863D0   		movslq	%eax, %rdx
 421 0399 488B45E8 		movq	-24(%rbp), %rax
 422 039d 4801D0   		addq	%rdx, %rax
 423 03a0 0FB600   		movzbl	(%rax), %eax
 424 03a3 8845F3   		movb	%al, -13(%rbp)
 117:libusbwrap.c  **** 			if (
 425              		.loc 3 117 0
 426 03a6 807DF32F 		cmpb	$47, -13(%rbp)
 427 03aa 7E1E     		jle	.L38
 118:libusbwrap.c  **** 				ch < '0' ||
 428              		.loc 3 118 0
 429 03ac 807DF339 		cmpb	$57, -13(%rbp)
 430 03b0 7E06     		jle	.L39
 119:libusbwrap.c  **** 				(ch > '9' && ch < 'A') ||
 431              		.loc 3 119 0
 432 03b2 807DF340 		cmpb	$64, -13(%rbp)
 433 03b6 7E12     		jle	.L38
 434              	.L39:
 435              		.loc 3 119 0 is_stmt 0 discriminator 1
 436 03b8 807DF346 		cmpb	$70, -13(%rbp)
 437 03bc 7E06     		jle	.L40
 120:libusbwrap.c  **** 				(ch > 'F' && ch < 'a') ||
 438              		.loc 3 120 0 is_stmt 1
 439 03be 807DF360 		cmpb	$96, -13(%rbp)
 440 03c2 7E06     		jle	.L38
 441              	.L40:
 442              		.loc 3 120 0 is_stmt 0 discriminator 1
 443 03c4 807DF366 		cmpb	$102, -13(%rbp)
 444 03c8 7E07     		jle	.L41
 445              	.L38:
 121:libusbwrap.c  **** 				ch > 'f')
 122:libusbwrap.c  **** 			{
 123:libusbwrap.c  **** 				return false;
 446              		.loc 3 123 0 is_stmt 1
 447 03ca B8000000 		movl	$0, %eax
 447      00
 448 03cf EB0F     		jmp	.L18
 449              	.L41:
 115:libusbwrap.c  **** 			ch = vp[i];
 450              		.loc 3 115 0 discriminator 2
 451 03d1 8345F401 		addl	$1, -12(%rbp)
 452              	.L37:
 115:libusbwrap.c  **** 			ch = vp[i];
 453              		.loc 3 115 0 is_stmt 0 discriminator 1
 454 03d5 837DF40D 		cmpl	$13, -12(%rbp)
 455 03d9 7EB8     		jle	.L42
 456              	.L36:
 124:libusbwrap.c  **** 			}
 125:libusbwrap.c  **** 		}
 126:libusbwrap.c  **** 	}
 127:libusbwrap.c  **** 	return true;
 457              		.loc 3 127 0 is_stmt 1
 458 03db B8010000 		movl	$1, %eax
 458      00
 459              	.L18:
 128:libusbwrap.c  **** }
 460              		.loc 3 128 0
 461 03e0 C9       		leave
 462              		.cfi_def_cfa 7, 8
 463 03e1 C3       		ret
 464              		.cfi_endproc
 465              	.LFE25:
 467              		.section	.rodata
 468              	.LC1:
 469 0011 75736249 		.string	"usbInitialise(): %s"
 469      6E697469 
 469      616C6973 
 469      6528293A 
 469      20257300 
 470              		.text
 471              		.globl	usbInitialise
 473              	usbInitialise:
 474              	.LFB26:
 129:libusbwrap.c  **** 
 130:libusbwrap.c  **** // Initialise LibUSB with the given log level.
 131:libusbwrap.c  **** //
 132:libusbwrap.c  **** DLLEXPORT(USBStatus) usbInitialise(int debugLevel, const char **error) {
 475              		.loc 3 132 0
 476              		.cfi_startproc
 477 03e2 55       		pushq	%rbp
 478              		.cfi_def_cfa_offset 16
 479              		.cfi_offset 6, -16
 480 03e3 4889E5   		movq	%rsp, %rbp
 481              		.cfi_def_cfa_register 6
 482 03e6 4883EC20 		subq	$32, %rsp
 483 03ea 897DEC   		movl	%edi, -20(%rbp)
 484 03ed 488975E0 		movq	%rsi, -32(%rbp)
 133:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 485              		.loc 3 133 0
 486 03f1 C745F800 		movl	$0, -8(%rbp)
 486      000000
 134:libusbwrap.c  **** 	int status = libusb_init(&m_ctx);
 487              		.loc 3 134 0
 488 03f8 488D3D00 		leaq	m_ctx(%rip), %rdi
 488      000000
 489 03ff E8000000 		call	libusb_init@PLT
 489      00
 490 0404 8945FC   		movl	%eax, -4(%rbp)
 135:libusbwrap.c  **** 	CHECK_STATUS(status, USB_INIT, cleanup, "usbInitialise(): %s", libusb_error_name(status));
 491              		.loc 3 135 0
 492 0407 837DFC00 		cmpl	$0, -4(%rbp)
 493 040b 742E     		je	.L44
 494              		.loc 3 135 0 is_stmt 0 discriminator 1
 495 040d 8B45FC   		movl	-4(%rbp), %eax
 496 0410 89C7     		movl	%eax, %edi
 497 0412 E8000000 		call	libusb_error_name@PLT
 497      00
 498 0417 4889C2   		movq	%rax, %rdx
 499 041a 488B45E0 		movq	-32(%rbp), %rax
 500 041e 488D3500 		leaq	.LC1(%rip), %rsi
 500      000000
 501 0425 4889C7   		movq	%rax, %rdi
 502 0428 B8000000 		movl	$0, %eax
 502      00
 503 042d E8000000 		call	errRender@PLT
 503      00
 504 0432 C745F802 		movl	$2, -8(%rbp)
 504      000000
 505 0439 EB14     		jmp	.L45
 506              	.L44:
 136:libusbwrap.c  **** 	libusb_set_debug(m_ctx, debugLevel);
 507              		.loc 3 136 0 is_stmt 1
 508 043b 488B0500 		movq	m_ctx(%rip), %rax
 508      000000
 509 0442 8B55EC   		movl	-20(%rbp), %edx
 510 0445 89D6     		movl	%edx, %esi
 511 0447 4889C7   		movq	%rax, %rdi
 512 044a E8000000 		call	libusb_set_debug@PLT
 512      00
 513              	.L45:
 137:libusbwrap.c  **** cleanup:
 138:libusbwrap.c  **** 	return retVal;
 514              		.loc 3 138 0
 515 044f 8B45F8   		movl	-8(%rbp), %eax
 139:libusbwrap.c  **** }
 516              		.loc 3 139 0
 517 0452 C9       		leave
 518              		.cfi_def_cfa 7, 8
 519 0453 C3       		ret
 520              		.cfi_endproc
 521              	.LFE26:
 523              		.section	.rodata
 524 0025 000000   		.align 8
 525              	.LC2:
 526 0028 75736249 		.string	"usbIsDeviceAvailable(): you forgot to call usbInitialise()!"
 526      73446576 
 526      69636541 
 526      7661696C 
 526      61626C65 
 527              	.LC3:
 528 0064 75736249 		.string	"usbIsDeviceAvailable(): %s"
 528      73446576 
 528      69636541 
 528      7661696C 
 528      61626C65 
 529 007f 00       		.align 8
 530              	.LC4:
 531 0080 75736249 		.string	"usbIsDeviceAvailable(): The supplied VID:PID:DID \"%s\" is invalid; it should look like 1
 531      73446576 
 531      69636541 
 531      7661696C 
 531      61626C65 
 532              		.text
 533              		.globl	usbIsDeviceAvailable
 535              	usbIsDeviceAvailable:
 536              	.LFB27:
 140:libusbwrap.c  **** 
 141:libusbwrap.c  **** #define isMatching (thisDevice->descriptor.idVendor == vid && thisDevice->descriptor.idProduct == p
 142:libusbwrap.c  **** 
 143:libusbwrap.c  **** #define FORMAT_ERR "The supplied VID:PID:DID \"%s\" is invalid; it should look like 1D50:602B or 1D
 144:libusbwrap.c  **** 
 145:libusbwrap.c  **** // Find the descriptor of the first occurance of the specified device
 146:libusbwrap.c  **** //
 147:libusbwrap.c  **** DLLEXPORT(USBStatus) usbIsDeviceAvailable(const char *vp, bool *isAvailable, const char **error) {
 537              		.loc 3 147 0
 538              		.cfi_startproc
 539 0454 55       		pushq	%rbp
 540              		.cfi_def_cfa_offset 16
 541              		.cfi_offset 6, -16
 542 0455 4889E5   		movq	%rsp, %rbp
 543              		.cfi_def_cfa_register 6
 544 0458 4883EC70 		subq	$112, %rsp
 545 045c 48897DA8 		movq	%rdi, -88(%rbp)
 546 0460 488975A0 		movq	%rsi, -96(%rbp)
 547 0464 48895598 		movq	%rdx, -104(%rbp)
 548              		.loc 3 147 0
 549 0468 64488B04 		movq	%fs:40, %rax
 549      25280000 
 549      00
 550 0471 488945F8 		movq	%rax, -8(%rbp)
 551 0475 31C0     		xorl	%eax, %eax
 148:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 552              		.loc 3 148 0
 553 0477 C745C400 		movl	$0, -60(%rbp)
 553      000000
 149:libusbwrap.c  **** 	struct libusb_device **devList = NULL;
 554              		.loc 3 149 0
 555 047e 48C745D0 		movq	$0, -48(%rbp)
 555      00000000 
 150:libusbwrap.c  **** 	struct libusb_device *thisDev;
 151:libusbwrap.c  **** 	struct libusb_device_descriptor desc;
 152:libusbwrap.c  **** 	uint16 vid, pid, did;
 153:libusbwrap.c  **** 	int status, count;
 154:libusbwrap.c  **** 	CHECK_STATUS(
 556              		.loc 3 154 0
 557 0486 488B0500 		movq	m_ctx(%rip), %rax
 557      000000
 558 048d 4885C0   		testq	%rax, %rax
 559 0490 751F     		jne	.L48
 560              		.loc 3 154 0 is_stmt 0 discriminator 1
 561 0492 488B4598 		movq	-104(%rbp), %rax
 562 0496 488D3500 		leaq	.LC2(%rip), %rsi
 562      000000
 563 049d 4889C7   		movq	%rax, %rdi
 564 04a0 E8000000 		call	errPrefix@PLT
 564      00
 565 04a5 C745C402 		movl	$2, -60(%rbp)
 565      000000
 566 04ac E9A80100 		jmp	.L49
 566      00
 567              	.L48:
 155:libusbwrap.c  **** 		!m_ctx, USB_INIT, cleanup,
 156:libusbwrap.c  **** 		"usbIsDeviceAvailable(): you forgot to call usbInitialise()!");
 157:libusbwrap.c  **** 	count = (int)libusb_get_device_list(m_ctx, &devList);
 568              		.loc 3 157 0 is_stmt 1
 569 04b1 488B0500 		movq	m_ctx(%rip), %rax
 569      000000
 570 04b8 488D55D0 		leaq	-48(%rbp), %rdx
 571 04bc 4889D6   		movq	%rdx, %rsi
 572 04bf 4889C7   		movq	%rax, %rdi
 573 04c2 E8000000 		call	libusb_get_device_list@PLT
 573      00
 574 04c7 8945C8   		movl	%eax, -56(%rbp)
 158:libusbwrap.c  **** 	CHECK_STATUS(
 575              		.loc 3 158 0
 576 04ca 837DC800 		cmpl	$0, -56(%rbp)
 577 04ce 7931     		jns	.L50
 578              		.loc 3 158 0 is_stmt 0 discriminator 1
 579 04d0 8B45C8   		movl	-56(%rbp), %eax
 580 04d3 89C7     		movl	%eax, %edi
 581 04d5 E8000000 		call	libusb_error_name@PLT
 581      00
 582 04da 4889C2   		movq	%rax, %rdx
 583 04dd 488B4598 		movq	-104(%rbp), %rax
 584 04e1 488D3500 		leaq	.LC3(%rip), %rsi
 584      000000
 585 04e8 4889C7   		movq	%rax, %rdi
 586 04eb B8000000 		movl	$0, %eax
 586      00
 587 04f0 E8000000 		call	errRender@PLT
 587      00
 588 04f5 C745C405 		movl	$5, -60(%rbp)
 588      000000
 589 04fc E9580100 		jmp	.L49
 589      00
 590              	.L50:
 159:libusbwrap.c  **** 		count < 0, USB_CANNOT_OPEN_DEVICE, cleanup,
 160:libusbwrap.c  **** 		"usbIsDeviceAvailable(): %s", libusb_error_name(count));
 161:libusbwrap.c  **** 	CHECK_STATUS(
 591              		.loc 3 161 0 is_stmt 1
 592 0501 488B45A8 		movq	-88(%rbp), %rax
 593 0505 4889C7   		movq	%rax, %rdi
 594 0508 E8000000 		call	usbValidateVidPid@PLT
 594      00
 595 050d 83F001   		xorl	$1, %eax
 596 0510 84C0     		testb	%al, %al
 597 0512 7428     		je	.L51
 598              		.loc 3 161 0 is_stmt 0 discriminator 1
 599 0514 488B55A8 		movq	-88(%rbp), %rdx
 600 0518 488B4598 		movq	-104(%rbp), %rax
 601 051c 488D3500 		leaq	.LC4(%rip), %rsi
 601      000000
 602 0523 4889C7   		movq	%rax, %rdi
 603 0526 B8000000 		movl	$0, %eax
 603      00
 604 052b E8000000 		call	errRender@PLT
 604      00
 605 0530 C745C401 		movl	$1, -60(%rbp)
 605      000000
 606 0537 E91D0100 		jmp	.L49
 606      00
 607              	.L51:
 162:libusbwrap.c  **** 		!usbValidateVidPid(vp), USB_INVALID_VIDPID, cleanup,
 163:libusbwrap.c  **** 		"usbIsDeviceAvailable(): "FORMAT_ERR, vp);
 164:libusbwrap.c  **** 	vid = (uint16)strtoul(vp, NULL, 16);
 608              		.loc 3 164 0 is_stmt 1
 609 053c 488B45A8 		movq	-88(%rbp), %rax
 610 0540 BA100000 		movl	$16, %edx
 610      00
 611 0545 BE000000 		movl	$0, %esi
 611      00
 612 054a 4889C7   		movq	%rax, %rdi
 613 054d E8000000 		call	strtoul@PLT
 613      00
 614 0552 668945BE 		movw	%ax, -66(%rbp)
 165:libusbwrap.c  **** 	pid = (uint16)strtoul(vp+5, NULL, 16);
 615              		.loc 3 165 0
 616 0556 488B45A8 		movq	-88(%rbp), %rax
 617 055a 4883C005 		addq	$5, %rax
 618 055e BA100000 		movl	$16, %edx
 618      00
 619 0563 BE000000 		movl	$0, %esi
 619      00
 620 0568 4889C7   		movq	%rax, %rdi
 621 056b E8000000 		call	strtoul@PLT
 621      00
 622 0570 668945C0 		movw	%ax, -64(%rbp)
 166:libusbwrap.c  **** 	did = (uint16)((strlen(vp) == 14) ? strtoul(vp+10, NULL, 16) : 0x0000);
 623              		.loc 3 166 0
 624 0574 488B45A8 		movq	-88(%rbp), %rax
 625 0578 4889C7   		movq	%rax, %rdi
 626 057b E8000000 		call	strlen@PLT
 626      00
 627 0580 4883F80E 		cmpq	$14, %rax
 628 0584 751C     		jne	.L52
 629              		.loc 3 166 0 is_stmt 0 discriminator 1
 630 0586 488B45A8 		movq	-88(%rbp), %rax
 631 058a 4883C00A 		addq	$10, %rax
 632 058e BA100000 		movl	$16, %edx
 632      00
 633 0593 BE000000 		movl	$0, %esi
 633      00
 634 0598 4889C7   		movq	%rax, %rdi
 635 059b E8000000 		call	strtoul@PLT
 635      00
 636 05a0 EB05     		jmp	.L53
 637              	.L52:
 638              		.loc 3 166 0 discriminator 2
 639 05a2 B8000000 		movl	$0, %eax
 639      00
 640              	.L53:
 641              		.loc 3 166 0 discriminator 4
 642 05a7 668945C2 		movw	%ax, -62(%rbp)
 167:libusbwrap.c  **** 	*isAvailable = false;
 643              		.loc 3 167 0 is_stmt 1 discriminator 4
 644 05ab 488B45A0 		movq	-96(%rbp), %rax
 645 05af C60000   		movb	$0, (%rax)
 168:libusbwrap.c  **** 	while ( count-- ) {
 646              		.loc 3 168 0 discriminator 4
 647 05b2 E9900000 		jmp	.L54
 647      00
 648              	.L57:
 169:libusbwrap.c  **** 		thisDev = devList[count];
 649              		.loc 3 169 0
 650 05b7 488B45D0 		movq	-48(%rbp), %rax
 651 05bb 8B55C8   		movl	-56(%rbp), %edx
 652 05be 4863D2   		movslq	%edx, %rdx
 653 05c1 48C1E203 		salq	$3, %rdx
 654 05c5 4801D0   		addq	%rdx, %rax
 655 05c8 488B00   		movq	(%rax), %rax
 656 05cb 488945D8 		movq	%rax, -40(%rbp)
 170:libusbwrap.c  **** 		status = libusb_get_device_descriptor(thisDev, &desc);
 657              		.loc 3 170 0
 658 05cf 488D55E0 		leaq	-32(%rbp), %rdx
 659 05d3 488B45D8 		movq	-40(%rbp), %rax
 660 05d7 4889D6   		movq	%rdx, %rsi
 661 05da 4889C7   		movq	%rax, %rdi
 662 05dd E8000000 		call	libusb_get_device_descriptor@PLT
 662      00
 663 05e2 8945CC   		movl	%eax, -52(%rbp)
 171:libusbwrap.c  **** 		CHECK_STATUS(
 664              		.loc 3 171 0
 665 05e5 837DCC00 		cmpl	$0, -52(%rbp)
 666 05e9 742E     		je	.L55
 667              		.loc 3 171 0 is_stmt 0 discriminator 1
 668 05eb 8B45CC   		movl	-52(%rbp), %eax
 669 05ee 89C7     		movl	%eax, %edi
 670 05f0 E8000000 		call	libusb_error_name@PLT
 670      00
 671 05f5 4889C2   		movq	%rax, %rdx
 672 05f8 488B4598 		movq	-104(%rbp), %rax
 673 05fc 488D3500 		leaq	.LC3(%rip), %rsi
 673      000000
 674 0603 4889C7   		movq	%rax, %rdi
 675 0606 B8000000 		movl	$0, %eax
 675      00
 676 060b E8000000 		call	errRender@PLT
 676      00
 677 0610 C745C409 		movl	$9, -60(%rbp)
 677      000000
 678 0617 EB40     		jmp	.L49
 679              	.L55:
 172:libusbwrap.c  **** 			status, USB_CANNOT_GET_DESCRIPTOR, cleanup,
 173:libusbwrap.c  **** 			"usbIsDeviceAvailable(): %s", libusb_error_name(status));
 174:libusbwrap.c  **** 		if (
 175:libusbwrap.c  **** 			desc.idVendor == vid &&
 680              		.loc 3 175 0 is_stmt 1
 681 0619 0FB745E8 		movzwl	-24(%rbp), %eax
 174:libusbwrap.c  **** 			desc.idVendor == vid &&
 682              		.loc 3 174 0
 683 061d 663945BE 		cmpw	%ax, -66(%rbp)
 684 0621 7524     		jne	.L54
 176:libusbwrap.c  **** 			desc.idProduct == pid &&
 685              		.loc 3 176 0
 686 0623 0FB745EA 		movzwl	-22(%rbp), %eax
 175:libusbwrap.c  **** 			desc.idProduct == pid &&
 687              		.loc 3 175 0
 688 0627 663945C0 		cmpw	%ax, -64(%rbp)
 689 062b 751A     		jne	.L54
 690              		.loc 3 176 0
 691 062d 66837DC2 		cmpw	$0, -62(%rbp)
 691      00
 692 0632 740A     		je	.L56
 177:libusbwrap.c  **** 			(did == 0x0000 || desc.bcdDevice == did)
 693              		.loc 3 177 0
 694 0634 0FB745EC 		movzwl	-20(%rbp), %eax
 695 0638 663945C2 		cmpw	%ax, -62(%rbp)
 696 063c 7509     		jne	.L54
 697              	.L56:
 178:libusbwrap.c  **** 		) {
 179:libusbwrap.c  **** 			*isAvailable = true;
 698              		.loc 3 179 0
 699 063e 488B45A0 		movq	-96(%rbp), %rax
 700 0642 C60001   		movb	$1, (%rax)
 180:libusbwrap.c  **** 			break;
 701              		.loc 3 180 0
 702 0645 EB12     		jmp	.L49
 703              	.L54:
 168:libusbwrap.c  **** 		thisDev = devList[count];
 704              		.loc 3 168 0
 705 0647 8B45C8   		movl	-56(%rbp), %eax
 706 064a 8D50FF   		leal	-1(%rax), %edx
 707 064d 8955C8   		movl	%edx, -56(%rbp)
 708 0650 85C0     		testl	%eax, %eax
 709 0652 0F855FFF 		jne	.L57
 709      FFFF
 181:libusbwrap.c  **** 		}
 182:libusbwrap.c  **** 	}
 183:libusbwrap.c  **** cleanup:
 710              		.loc 3 183 0
 711 0658 90       		nop
 712              	.L49:
 184:libusbwrap.c  **** 	libusb_free_device_list(devList, 1);
 713              		.loc 3 184 0
 714 0659 488B45D0 		movq	-48(%rbp), %rax
 715 065d BE010000 		movl	$1, %esi
 715      00
 716 0662 4889C7   		movq	%rax, %rdi
 717 0665 E8000000 		call	libusb_free_device_list@PLT
 717      00
 185:libusbwrap.c  **** 	return retVal;
 718              		.loc 3 185 0
 719 066a 8B45C4   		movl	-60(%rbp), %eax
 186:libusbwrap.c  **** }
 720              		.loc 3 186 0
 721 066d 488B4DF8 		movq	-8(%rbp), %rcx
 722 0671 6448330C 		xorq	%fs:40, %rcx
 722      25280000 
 722      00
 723 067a 7405     		je	.L59
 724 067c E8000000 		call	__stack_chk_fail@PLT
 724      00
 725              	.L59:
 726 0681 C9       		leave
 727              		.cfi_def_cfa 7, 8
 728 0682 C3       		ret
 729              		.cfi_endproc
 730              	.LFE27:
 732              		.globl	createTransfer
 734              	createTransfer:
 735              	.LFB28:
 187:libusbwrap.c  **** 
 188:libusbwrap.c  **** struct TransferWrapper {
 189:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 190:libusbwrap.c  **** 	int completed;
 191:libusbwrap.c  **** 	struct AsyncTransferFlags flags;
 192:libusbwrap.c  **** 	uint8 buffer[0x10000];  // can use this...
 193:libusbwrap.c  **** 	uint8 *bufPtr;          // ...or this.
 194:libusbwrap.c  **** };
 195:libusbwrap.c  **** struct TransferWrapper *createTransfer(void) {
 736              		.loc 3 195 0
 737              		.cfi_startproc
 738 0683 55       		pushq	%rbp
 739              		.cfi_def_cfa_offset 16
 740              		.cfi_offset 6, -16
 741 0684 4889E5   		movq	%rsp, %rbp
 742              		.cfi_def_cfa_register 6
 743 0687 4883EC10 		subq	$16, %rsp
 196:libusbwrap.c  **** 	struct TransferWrapper *retVal = (struct TransferWrapper *)calloc(1, sizeof(struct TransferWrapper
 744              		.loc 3 196 0
 745 068b BE180001 		movl	$65560, %esi
 745      00
 746 0690 BF010000 		movl	$1, %edi
 746      00
 747 0695 E8000000 		call	calloc@PLT
 747      00
 748 069a 488945F8 		movq	%rax, -8(%rbp)
 197:libusbwrap.c  **** 	CHECK_STATUS(retVal == NULL, NULL, exit);
 749              		.loc 3 197 0
 750 069e 48837DF8 		cmpq	$0, -8(%rbp)
 750      00
 751 06a3 750A     		jne	.L61
 752              		.loc 3 197 0 is_stmt 0 discriminator 1
 753 06a5 48C745F8 		movq	$0, -8(%rbp)
 753      00000000 
 754 06ad EB3D     		jmp	.L62
 755              	.L61:
 198:libusbwrap.c  **** 	retVal->transfer = libusb_alloc_transfer(0);
 756              		.loc 3 198 0 is_stmt 1
 757 06af BF000000 		movl	$0, %edi
 757      00
 758 06b4 E8000000 		call	libusb_alloc_transfer@PLT
 758      00
 759 06b9 4889C2   		movq	%rax, %rdx
 760 06bc 488B45F8 		movq	-8(%rbp), %rax
 761 06c0 488910   		movq	%rdx, (%rax)
 199:libusbwrap.c  **** 	CHECK_STATUS(retVal->transfer == NULL, NULL, freeWrap);
 762              		.loc 3 199 0
 763 06c3 488B45F8 		movq	-8(%rbp), %rax
 764 06c7 488B00   		movq	(%rax), %rax
 765 06ca 4885C0   		testq	%rax, %rax
 766 06cd 7517     		jne	.L63
 767              		.loc 3 199 0 is_stmt 0 discriminator 1
 768 06cf 48C745F8 		movq	$0, -8(%rbp)
 768      00000000 
 769 06d7 90       		nop
 770              	.L64:
 200:libusbwrap.c  **** 	return retVal;
 201:libusbwrap.c  **** freeWrap:
 202:libusbwrap.c  **** 	free((void*)retVal);
 771              		.loc 3 202 0 is_stmt 1 discriminator 1
 772 06d8 488B45F8 		movq	-8(%rbp), %rax
 773 06dc 4889C7   		movq	%rax, %rdi
 774 06df E8000000 		call	free@PLT
 774      00
 775 06e4 EB06     		jmp	.L62
 776              	.L63:
 200:libusbwrap.c  **** 	return retVal;
 777              		.loc 3 200 0
 778 06e6 488B45F8 		movq	-8(%rbp), %rax
 779 06ea EB05     		jmp	.L65
 780              	.L62:
 203:libusbwrap.c  **** exit:
 204:libusbwrap.c  **** 	return NULL;
 781              		.loc 3 204 0
 782 06ec B8000000 		movl	$0, %eax
 782      00
 783              	.L65:
 205:libusbwrap.c  **** }
 784              		.loc 3 205 0
 785 06f1 C9       		leave
 786              		.cfi_def_cfa 7, 8
 787 06f2 C3       		ret
 788              		.cfi_endproc
 789              	.LFE28:
 792              	destroyTransfer:
 793              	.LFB29:
 206:libusbwrap.c  **** 
 207:libusbwrap.c  **** static void destroyTransfer(struct TransferWrapper *tx) {
 794              		.loc 3 207 0
 795              		.cfi_startproc
 796 06f3 55       		pushq	%rbp
 797              		.cfi_def_cfa_offset 16
 798              		.cfi_offset 6, -16
 799 06f4 4889E5   		movq	%rsp, %rbp
 800              		.cfi_def_cfa_register 6
 801 06f7 4883EC10 		subq	$16, %rsp
 802 06fb 48897DF8 		movq	%rdi, -8(%rbp)
 208:libusbwrap.c  **** 	if ( tx ) {
 803              		.loc 3 208 0
 804 06ff 48837DF8 		cmpq	$0, -8(%rbp)
 804      00
 805 0704 741B     		je	.L68
 209:libusbwrap.c  **** 		libusb_free_transfer(tx->transfer);
 806              		.loc 3 209 0
 807 0706 488B45F8 		movq	-8(%rbp), %rax
 808 070a 488B00   		movq	(%rax), %rax
 809 070d 4889C7   		movq	%rax, %rdi
 810 0710 E8000000 		call	libusb_free_transfer@PLT
 810      00
 210:libusbwrap.c  **** 		free((void*)tx);
 811              		.loc 3 210 0
 812 0715 488B45F8 		movq	-8(%rbp), %rax
 813 0719 4889C7   		movq	%rax, %rdi
 814 071c E8000000 		call	free@PLT
 814      00
 815              	.L68:
 211:libusbwrap.c  **** 	}
 212:libusbwrap.c  **** }
 816              		.loc 3 212 0
 817 0721 90       		nop
 818 0722 C9       		leave
 819              		.cfi_def_cfa 7, 8
 820 0723 C3       		ret
 821              		.cfi_endproc
 822              	.LFE29:
 824              		.section	.rodata
 825 00f2 00000000 		.align 8
 825      0000
 826              	.LC5:
 827 00f8 7573624F 		.string	"usbOpenDevice(): you forgot to call usbInitialise()!"
 827      70656E44 
 827      65766963 
 827      6528293A 
 827      20796F75 
 828 012d 000000   		.align 8
 829              	.LC6:
 830 0130 7573624F 		.string	"usbOpenDevice(): The supplied VID:PID:DID \"%s\" is invalid; it should look like 1D50:602
 830      70656E44 
 830      65766963 
 830      6528293A 
 830      20546865 
 831 019b 00000000 		.align 8
 831      00
 832              	.LC7:
 833 01a0 7573624F 		.string	"usbOpenDevice(): Out of memory!"
 833      70656E44 
 833      65766963 
 833      6528293A 
 833      204F7574 
 834              	.LC8:
 835 01c0 7573624F 		.string	"usbOpenDevice()"
 835      70656E44 
 835      65766963 
 835      65282900 
 836              	.LC9:
 837 01d0 7573624F 		.string	"usbOpenDevice(): %s"
 837      70656E44 
 837      65766963 
 837      6528293A 
 837      20257300 
 838              		.text
 839              		.globl	usbOpenDevice
 841              	usbOpenDevice:
 842              	.LFB30:
 213:libusbwrap.c  **** 
 214:libusbwrap.c  **** // Find the descriptor of the first occurance of the specified device
 215:libusbwrap.c  **** //
 216:libusbwrap.c  **** DLLEXPORT(USBStatus) usbOpenDevice(
 217:libusbwrap.c  **** 	const char *vp, int configuration, int iface, int altSetting,
 218:libusbwrap.c  **** 	struct USBDevice **devHandlePtr, const char **error)
 219:libusbwrap.c  **** {
 843              		.loc 3 219 0
 844              		.cfi_startproc
 845 0724 55       		pushq	%rbp
 846              		.cfi_def_cfa_offset 16
 847              		.cfi_offset 6, -16
 848 0725 4889E5   		movq	%rsp, %rbp
 849              		.cfi_def_cfa_register 6
 850 0728 4883EC50 		subq	$80, %rsp
 851 072c 48897DD8 		movq	%rdi, -40(%rbp)
 852 0730 8975D4   		movl	%esi, -44(%rbp)
 853 0733 8955D0   		movl	%edx, -48(%rbp)
 854 0736 894DCC   		movl	%ecx, -52(%rbp)
 855 0739 4C8945C0 		movq	%r8, -64(%rbp)
 856 073d 4C894DB8 		movq	%r9, -72(%rbp)
 220:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 857              		.loc 3 220 0
 858 0741 C745E800 		movl	$0, -24(%rbp)
 858      000000
 221:libusbwrap.c  **** 	uint16 vid, pid, did;
 222:libusbwrap.c  **** 	int status;
 223:libusbwrap.c  **** 	struct USBDevice *newWrapper;
 224:libusbwrap.c  **** 	struct libusb_device_handle *newHandle;
 225:libusbwrap.c  **** 	CHECK_STATUS(
 859              		.loc 3 225 0
 860 0748 488B0500 		movq	m_ctx(%rip), %rax
 860      000000
 861 074f 4885C0   		testq	%rax, %rax
 862 0752 751F     		jne	.L70
 863              		.loc 3 225 0 is_stmt 0 discriminator 1
 864 0754 488B45B8 		movq	-72(%rbp), %rax
 865 0758 488D3500 		leaq	.LC5(%rip), %rsi
 865      000000
 866 075f 4889C7   		movq	%rax, %rdi
 867 0762 E8000000 		call	errPrefix@PLT
 867      00
 868 0767 C745E802 		movl	$2, -24(%rbp)
 868      000000
 869 076e E9AA0200 		jmp	.L71
 869      00
 870              	.L70:
 226:libusbwrap.c  **** 		!m_ctx, USB_INIT, exit,
 227:libusbwrap.c  **** 		"usbOpenDevice(): you forgot to call usbInitialise()!");
 228:libusbwrap.c  **** 	CHECK_STATUS(
 871              		.loc 3 228 0 is_stmt 1
 872 0773 488B45D8 		movq	-40(%rbp), %rax
 873 0777 4889C7   		movq	%rax, %rdi
 874 077a E8000000 		call	usbValidateVidPid@PLT
 874      00
 875 077f 83F001   		xorl	$1, %eax
 876 0782 84C0     		testb	%al, %al
 877 0784 7428     		je	.L72
 878              		.loc 3 228 0 is_stmt 0 discriminator 1
 879 0786 488B55D8 		movq	-40(%rbp), %rdx
 880 078a 488B45B8 		movq	-72(%rbp), %rax
 881 078e 488D3500 		leaq	.LC6(%rip), %rsi
 881      000000
 882 0795 4889C7   		movq	%rax, %rdi
 883 0798 B8000000 		movl	$0, %eax
 883      00
 884 079d E8000000 		call	errRender@PLT
 884      00
 885 07a2 C745E801 		movl	$1, -24(%rbp)
 885      000000
 886 07a9 E96F0200 		jmp	.L71
 886      00
 887              	.L72:
 229:libusbwrap.c  **** 		!usbValidateVidPid(vp), USB_INVALID_VIDPID, exit,
 230:libusbwrap.c  **** 		"usbOpenDevice(): "FORMAT_ERR, vp);
 231:libusbwrap.c  **** 	vid = (uint16)strtoul(vp, NULL, 16);
 888              		.loc 3 231 0 is_stmt 1
 889 07ae 488B45D8 		movq	-40(%rbp), %rax
 890 07b2 BA100000 		movl	$16, %edx
 890      00
 891 07b7 BE000000 		movl	$0, %esi
 891      00
 892 07bc 4889C7   		movq	%rax, %rdi
 893 07bf E8000000 		call	strtoul@PLT
 893      00
 894 07c4 668945E2 		movw	%ax, -30(%rbp)
 232:libusbwrap.c  **** 	pid = (uint16)strtoul(vp+5, NULL, 16);
 895              		.loc 3 232 0
 896 07c8 488B45D8 		movq	-40(%rbp), %rax
 897 07cc 4883C005 		addq	$5, %rax
 898 07d0 BA100000 		movl	$16, %edx
 898      00
 899 07d5 BE000000 		movl	$0, %esi
 899      00
 900 07da 4889C7   		movq	%rax, %rdi
 901 07dd E8000000 		call	strtoul@PLT
 901      00
 902 07e2 668945E4 		movw	%ax, -28(%rbp)
 233:libusbwrap.c  **** 	did = (uint16)((strlen(vp) == 14) ? strtoul(vp+10, NULL, 16) : 0x0000);
 903              		.loc 3 233 0
 904 07e6 488B45D8 		movq	-40(%rbp), %rax
 905 07ea 4889C7   		movq	%rax, %rdi
 906 07ed E8000000 		call	strlen@PLT
 906      00
 907 07f2 4883F80E 		cmpq	$14, %rax
 908 07f6 751C     		jne	.L73
 909              		.loc 3 233 0 is_stmt 0 discriminator 1
 910 07f8 488B45D8 		movq	-40(%rbp), %rax
 911 07fc 4883C00A 		addq	$10, %rax
 912 0800 BA100000 		movl	$16, %edx
 912      00
 913 0805 BE000000 		movl	$0, %esi
 913      00
 914 080a 4889C7   		movq	%rax, %rdi
 915 080d E8000000 		call	strtoul@PLT
 915      00
 916 0812 EB05     		jmp	.L74
 917              	.L73:
 918              		.loc 3 233 0 discriminator 2
 919 0814 B8000000 		movl	$0, %eax
 919      00
 920              	.L74:
 921              		.loc 3 233 0 discriminator 4
 922 0819 668945E6 		movw	%ax, -26(%rbp)
 234:libusbwrap.c  **** 	newWrapper = (struct USBDevice *)malloc(sizeof(struct USBDevice));
 923              		.loc 3 234 0 is_stmt 1 discriminator 4
 924 081d BF400000 		movl	$64, %edi
 924      00
 925 0822 E8000000 		call	malloc@PLT
 925      00
 926 0827 488945F0 		movq	%rax, -16(%rbp)
 235:libusbwrap.c  **** 	CHECK_STATUS(newWrapper == NULL, USB_ALLOC_ERR, exit, "usbOpenDevice(): Out of memory!");
 927              		.loc 3 235 0 discriminator 4
 928 082b 48837DF0 		cmpq	$0, -16(%rbp)
 928      00
 929 0830 751F     		jne	.L75
 930              		.loc 3 235 0 is_stmt 0 discriminator 1
 931 0832 488B45B8 		movq	-72(%rbp), %rax
 932 0836 488D3500 		leaq	.LC7(%rip), %rsi
 932      000000
 933 083d 4889C7   		movq	%rax, %rdi
 934 0840 E8000000 		call	errPrefix@PLT
 934      00
 935 0845 C745E80C 		movl	$12, -24(%rbp)
 935      000000
 936 084c E9CC0100 		jmp	.L71
 936      00
 937              	.L75:
 236:libusbwrap.c  **** 	status = queueInit(&newWrapper->queue, 4, (CreateFunc)createTransfer, (DestroyFunc)destroyTransfer
 938              		.loc 3 236 0 is_stmt 1
 939 0851 488B45F0 		movq	-16(%rbp), %rax
 940 0855 488D7808 		leaq	8(%rax), %rdi
 941 0859 488D0D93 		leaq	destroyTransfer(%rip), %rcx
 941      FEFFFF
 942 0860 488B0500 		movq	createTransfer@GOTPCREL(%rip), %rax
 942      000000
 943 0867 4889C2   		movq	%rax, %rdx
 944 086a BE040000 		movl	$4, %esi
 944      00
 945 086f E8000000 		call	queueInit@PLT
 945      00
 946 0874 8945EC   		movl	%eax, -20(%rbp)
 237:libusbwrap.c  **** 	CHECK_STATUS(status, USB_ALLOC_ERR, freeWrap, "usbOpenDevice(): Out of memory!");
 947              		.loc 3 237 0
 948 0877 837DEC00 		cmpl	$0, -20(%rbp)
 949 087b 741F     		je	.L76
 950              		.loc 3 237 0 is_stmt 0 discriminator 1
 951 087d 488B45B8 		movq	-72(%rbp), %rax
 952 0881 488D3500 		leaq	.LC7(%rip), %rsi
 952      000000
 953 0888 4889C7   		movq	%rax, %rdi
 954 088b E8000000 		call	errPrefix@PLT
 954      00
 955 0890 C745E80C 		movl	$12, -24(%rbp)
 955      000000
 956 0897 E9750100 		jmp	.L77
 956      00
 957              	.L76:
 238:libusbwrap.c  **** 	newHandle = libusbOpenWithVidPid(m_ctx, vid, pid, did, error);
 958              		.loc 3 238 0 is_stmt 1
 959 089c 0FB74DE6 		movzwl	-26(%rbp), %ecx
 960 08a0 0FB755E4 		movzwl	-28(%rbp), %edx
 961 08a4 0FB775E2 		movzwl	-30(%rbp), %esi
 962 08a8 488B0500 		movq	m_ctx(%rip), %rax
 962      000000
 963 08af 488B7DB8 		movq	-72(%rbp), %rdi
 964 08b3 4989F8   		movq	%rdi, %r8
 965 08b6 4889C7   		movq	%rax, %rdi
 966 08b9 E8CAF7FF 		call	libusbOpenWithVidPid
 966      FF
 967 08be 488945F8 		movq	%rax, -8(%rbp)
 239:libusbwrap.c  **** 	CHECK_STATUS(!newHandle, USB_CANNOT_OPEN_DEVICE, freeQueue, "usbOpenDevice()");
 968              		.loc 3 239 0
 969 08c2 48837DF8 		cmpq	$0, -8(%rbp)
 969      00
 970 08c7 751F     		jne	.L78
 971              		.loc 3 239 0 is_stmt 0 discriminator 1
 972 08c9 488B45B8 		movq	-72(%rbp), %rax
 973 08cd 488D3500 		leaq	.LC8(%rip), %rsi
 973      000000
 974 08d4 4889C7   		movq	%rax, %rdi
 975 08d7 E8000000 		call	errPrefix@PLT
 975      00
 976 08dc C745E805 		movl	$5, -24(%rbp)
 976      000000
 977 08e3 E9190100 		jmp	.L79
 977      00
 978              	.L78:
 240:libusbwrap.c  **** 	status = libusb_set_configuration(newHandle, configuration);
 979              		.loc 3 240 0 is_stmt 1
 980 08e8 8B55D4   		movl	-44(%rbp), %edx
 981 08eb 488B45F8 		movq	-8(%rbp), %rax
 982 08ef 89D6     		movl	%edx, %esi
 983 08f1 4889C7   		movq	%rax, %rdi
 984 08f4 E8000000 		call	libusb_set_configuration@PLT
 984      00
 985 08f9 8945EC   		movl	%eax, -20(%rbp)
 241:libusbwrap.c  **** 	CHECK_STATUS(
 986              		.loc 3 241 0
 987 08fc 837DEC00 		cmpl	$0, -20(%rbp)
 988 0900 7931     		jns	.L80
 989              		.loc 3 241 0 is_stmt 0 discriminator 1
 990 0902 8B45EC   		movl	-20(%rbp), %eax
 991 0905 89C7     		movl	%eax, %edi
 992 0907 E8000000 		call	libusb_error_name@PLT
 992      00
 993 090c 4889C2   		movq	%rax, %rdx
 994 090f 488B45B8 		movq	-72(%rbp), %rax
 995 0913 488D3500 		leaq	.LC9(%rip), %rsi
 995      000000
 996 091a 4889C7   		movq	%rax, %rdi
 997 091d B8000000 		movl	$0, %eax
 997      00
 998 0922 E8000000 		call	errRender@PLT
 998      00
 999 0927 C745E806 		movl	$6, -24(%rbp)
 999      000000
 1000 092e E9C20000 		jmp	.L81
 1000      00
 1001              	.L80:
 242:libusbwrap.c  **** 		status < 0, USB_CANNOT_SET_CONFIGURATION, closeDev,
 243:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 244:libusbwrap.c  **** 	status = libusb_claim_interface(newHandle, iface);
 1002              		.loc 3 244 0 is_stmt 1
 1003 0933 8B55D0   		movl	-48(%rbp), %edx
 1004 0936 488B45F8 		movq	-8(%rbp), %rax
 1005 093a 89D6     		movl	%edx, %esi
 1006 093c 4889C7   		movq	%rax, %rdi
 1007 093f E8000000 		call	libusb_claim_interface@PLT
 1007      00
 1008 0944 8945EC   		movl	%eax, -20(%rbp)
 245:libusbwrap.c  **** 	CHECK_STATUS(
 1009              		.loc 3 245 0
 1010 0947 837DEC00 		cmpl	$0, -20(%rbp)
 1011 094b 792E     		jns	.L82
 1012              		.loc 3 245 0 is_stmt 0 discriminator 1
 1013 094d 8B45EC   		movl	-20(%rbp), %eax
 1014 0950 89C7     		movl	%eax, %edi
 1015 0952 E8000000 		call	libusb_error_name@PLT
 1015      00
 1016 0957 4889C2   		movq	%rax, %rdx
 1017 095a 488B45B8 		movq	-72(%rbp), %rax
 1018 095e 488D3500 		leaq	.LC9(%rip), %rsi
 1018      000000
 1019 0965 4889C7   		movq	%rax, %rdi
 1020 0968 B8000000 		movl	$0, %eax
 1020      00
 1021 096d E8000000 		call	errRender@PLT
 1021      00
 1022 0972 C745E807 		movl	$7, -24(%rbp)
 1022      000000
 1023 0979 EB7A     		jmp	.L81
 1024              	.L82:
 246:libusbwrap.c  **** 		status < 0, USB_CANNOT_CLAIM_INTERFACE, closeDev,
 247:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 248:libusbwrap.c  **** 	status = libusb_set_interface_alt_setting(newHandle, iface, altSetting);
 1025              		.loc 3 248 0 is_stmt 1
 1026 097b 8B55CC   		movl	-52(%rbp), %edx
 1027 097e 8B4DD0   		movl	-48(%rbp), %ecx
 1028 0981 488B45F8 		movq	-8(%rbp), %rax
 1029 0985 89CE     		movl	%ecx, %esi
 1030 0987 4889C7   		movq	%rax, %rdi
 1031 098a E8000000 		call	libusb_set_interface_alt_setting@PLT
 1031      00
 1032 098f 8945EC   		movl	%eax, -20(%rbp)
 249:libusbwrap.c  **** 	CHECK_STATUS(
 1033              		.loc 3 249 0
 1034 0992 837DEC00 		cmpl	$0, -20(%rbp)
 1035 0996 7940     		jns	.L83
 1036              		.loc 3 249 0 is_stmt 0 discriminator 1
 1037 0998 8B45EC   		movl	-20(%rbp), %eax
 1038 099b 89C7     		movl	%eax, %edi
 1039 099d E8000000 		call	libusb_error_name@PLT
 1039      00
 1040 09a2 4889C2   		movq	%rax, %rdx
 1041 09a5 488B45B8 		movq	-72(%rbp), %rax
 1042 09a9 488D3500 		leaq	.LC9(%rip), %rsi
 1042      000000
 1043 09b0 4889C7   		movq	%rax, %rdi
 1044 09b3 B8000000 		movl	$0, %eax
 1044      00
 1045 09b8 E8000000 		call	errRender@PLT
 1045      00
 1046 09bd C745E808 		movl	$8, -24(%rbp)
 1046      000000
 1047 09c4 90       		nop
 1048              	.L84:
 250:libusbwrap.c  **** 		status < 0, USB_CANNOT_SET_ALTINT, release,
 251:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 252:libusbwrap.c  **** 	newWrapper->handle = newHandle;	
 253:libusbwrap.c  **** 	*devHandlePtr = newWrapper;
 254:libusbwrap.c  **** 	return USB_SUCCESS;
 255:libusbwrap.c  **** release:
 256:libusbwrap.c  **** 	libusb_release_interface(newHandle, iface);
 1049              		.loc 3 256 0 is_stmt 1 discriminator 1
 1050 09c5 8B55D0   		movl	-48(%rbp), %edx
 1051 09c8 488B45F8 		movq	-8(%rbp), %rax
 1052 09cc 89D6     		movl	%edx, %esi
 1053 09ce 4889C7   		movq	%rax, %rdi
 1054 09d1 E8000000 		call	libusb_release_interface@PLT
 1054      00
 1055 09d6 EB1D     		jmp	.L81
 1056              	.L83:
 252:libusbwrap.c  **** 	*devHandlePtr = newWrapper;
 1057              		.loc 3 252 0
 1058 09d8 488B45F0 		movq	-16(%rbp), %rax
 1059 09dc 488B55F8 		movq	-8(%rbp), %rdx
 1060 09e0 488910   		movq	%rdx, (%rax)
 253:libusbwrap.c  **** 	return USB_SUCCESS;
 1061              		.loc 3 253 0
 1062 09e3 488B45C0 		movq	-64(%rbp), %rax
 1063 09e7 488B55F0 		movq	-16(%rbp), %rdx
 1064 09eb 488910   		movq	%rdx, (%rax)
 254:libusbwrap.c  **** release:
 1065              		.loc 3 254 0
 1066 09ee B8000000 		movl	$0, %eax
 1066      00
 1067 09f3 EB36     		jmp	.L85
 1068              	.L81:
 257:libusbwrap.c  **** closeDev:
 258:libusbwrap.c  **** 	libusb_close(newHandle);	
 1069              		.loc 3 258 0
 1070 09f5 488B45F8 		movq	-8(%rbp), %rax
 1071 09f9 4889C7   		movq	%rax, %rdi
 1072 09fc E8000000 		call	libusb_close@PLT
 1072      00
 1073              	.L79:
 259:libusbwrap.c  **** freeQueue:
 260:libusbwrap.c  **** 	queueDestroy(&newWrapper->queue);
 1074              		.loc 3 260 0
 1075 0a01 488B45F0 		movq	-16(%rbp), %rax
 1076 0a05 4883C008 		addq	$8, %rax
 1077 0a09 4889C7   		movq	%rax, %rdi
 1078 0a0c E8000000 		call	queueDestroy@PLT
 1078      00
 1079              	.L77:
 261:libusbwrap.c  **** freeWrap:
 262:libusbwrap.c  **** 	free((void*)newWrapper);
 1080              		.loc 3 262 0
 1081 0a11 488B45F0 		movq	-16(%rbp), %rax
 1082 0a15 4889C7   		movq	%rax, %rdi
 1083 0a18 E8000000 		call	free@PLT
 1083      00
 1084              	.L71:
 263:libusbwrap.c  **** exit:
 264:libusbwrap.c  **** 	*devHandlePtr = NULL;
 1085              		.loc 3 264 0
 1086 0a1d 488B45C0 		movq	-64(%rbp), %rax
 1087 0a21 48C70000 		movq	$0, (%rax)
 1087      000000
 265:libusbwrap.c  **** 	return retVal;
 1088              		.loc 3 265 0
 1089 0a28 8B45E8   		movl	-24(%rbp), %eax
 1090              	.L85:
 266:libusbwrap.c  **** }
 1091              		.loc 3 266 0
 1092 0a2b C9       		leave
 1093              		.cfi_def_cfa 7, 8
 1094 0a2c C3       		ret
 1095              		.cfi_endproc
 1096              	.LFE30:
 1098              		.globl	usbCloseDevice
 1100              	usbCloseDevice:
 1101              	.LFB31:
 267:libusbwrap.c  **** 
 268:libusbwrap.c  **** DLLEXPORT(void) usbCloseDevice(struct USBDevice *dev, int iface) {
 1102              		.loc 3 268 0
 1103              		.cfi_startproc
 1104 0a2d 55       		pushq	%rbp
 1105              		.cfi_def_cfa_offset 16
 1106              		.cfi_offset 6, -16
 1107 0a2e 4889E5   		movq	%rsp, %rbp
 1108              		.cfi_def_cfa_register 6
 1109 0a31 4883EC20 		subq	$32, %rsp
 1110 0a35 48897DE8 		movq	%rdi, -24(%rbp)
 1111 0a39 8975E4   		movl	%esi, -28(%rbp)
 269:libusbwrap.c  **** 	if ( dev ) {
 1112              		.loc 3 269 0
 1113 0a3c 48837DE8 		cmpq	$0, -24(%rbp)
 1113      00
 1114 0a41 7444     		je	.L88
 1115              	.LBB3:
 270:libusbwrap.c  **** 		struct libusb_device_handle *ptr = dev->handle;
 1116              		.loc 3 270 0
 1117 0a43 488B45E8 		movq	-24(%rbp), %rax
 1118 0a47 488B00   		movq	(%rax), %rax
 1119 0a4a 488945F8 		movq	%rax, -8(%rbp)
 271:libusbwrap.c  **** 		libusb_release_interface(ptr, iface);
 1120              		.loc 3 271 0
 1121 0a4e 8B55E4   		movl	-28(%rbp), %edx
 1122 0a51 488B45F8 		movq	-8(%rbp), %rax
 1123 0a55 89D6     		movl	%edx, %esi
 1124 0a57 4889C7   		movq	%rax, %rdi
 1125 0a5a E8000000 		call	libusb_release_interface@PLT
 1125      00
 272:libusbwrap.c  **** 		libusb_close(ptr);
 1126              		.loc 3 272 0
 1127 0a5f 488B45F8 		movq	-8(%rbp), %rax
 1128 0a63 4889C7   		movq	%rax, %rdi
 1129 0a66 E8000000 		call	libusb_close@PLT
 1129      00
 273:libusbwrap.c  **** 		queueDestroy(&dev->queue);
 1130              		.loc 3 273 0
 1131 0a6b 488B45E8 		movq	-24(%rbp), %rax
 1132 0a6f 4883C008 		addq	$8, %rax
 1133 0a73 4889C7   		movq	%rax, %rdi
 1134 0a76 E8000000 		call	queueDestroy@PLT
 1134      00
 274:libusbwrap.c  **** 		free((void*)dev);
 1135              		.loc 3 274 0
 1136 0a7b 488B45E8 		movq	-24(%rbp), %rax
 1137 0a7f 4889C7   		movq	%rax, %rdi
 1138 0a82 E8000000 		call	free@PLT
 1138      00
 1139              	.L88:
 1140              	.LBE3:
 275:libusbwrap.c  **** 	}
 276:libusbwrap.c  **** }
 1141              		.loc 3 276 0
 1142 0a87 90       		nop
 1143 0a88 C9       		leave
 1144              		.cfi_def_cfa 7, 8
 1145 0a89 C3       		ret
 1146              		.cfi_endproc
 1147              	.LFE31:
 1149              		.section	.rodata
 1150              	.LC10:
 1151 01e4 75736243 		.string	"usbControlRead(): Timeout!"
 1151      6F6E7472 
 1151      6F6C5265 
 1151      61642829 
 1151      3A205469 
 1152              	.LC11:
 1153 01ff 75736243 		.string	"usbControlRead(): %s"
 1153      6F6E7472 
 1153      6F6C5265 
 1153      61642829 
 1153      3A202573 
 1154 0214 00000000 		.align 8
 1155              	.LC12:
 1156 0218 75736243 		.string	"usbControlRead(): Expected to read %d bytes but actually read %d"
 1156      6F6E7472 
 1156      6F6C5265 
 1156      61642829 
 1156      3A204578 
 1157              		.text
 1158              		.globl	usbControlRead
 1160              	usbControlRead:
 1161              	.LFB32:
 277:libusbwrap.c  **** 
 278:libusbwrap.c  **** DLLEXPORT(USBStatus) usbControlRead(
 279:libusbwrap.c  **** 	struct USBDevice *dev, uint8 bRequest, uint16 wValue, uint16 wIndex,
 280:libusbwrap.c  **** 	uint8 *data, uint16 wLength,
 281:libusbwrap.c  **** 	uint32 timeout, const char **error)
 282:libusbwrap.c  **** {
 1162              		.loc 3 282 0
 1163              		.cfi_startproc
 1164 0a8a 55       		pushq	%rbp
 1165              		.cfi_def_cfa_offset 16
 1166              		.cfi_offset 6, -16
 1167 0a8b 4889E5   		movq	%rsp, %rbp
 1168              		.cfi_def_cfa_register 6
 1169 0a8e 4883EC30 		subq	$48, %rsp
 1170 0a92 48897DE8 		movq	%rdi, -24(%rbp)
 1171 0a96 89C8     		movl	%ecx, %eax
 1172 0a98 4C8945D0 		movq	%r8, -48(%rbp)
 1173 0a9c 4489CF   		movl	%r9d, %edi
 1174 0a9f 89F1     		movl	%esi, %ecx
 1175 0aa1 884DE4   		movb	%cl, -28(%rbp)
 1176 0aa4 668955E0 		movw	%dx, -32(%rbp)
 1177 0aa8 668945DC 		movw	%ax, -36(%rbp)
 1178 0aac 89F8     		movl	%edi, %eax
 1179 0aae 668945D8 		movw	%ax, -40(%rbp)
 283:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1180              		.loc 3 283 0
 1181 0ab2 C745F800 		movl	$0, -8(%rbp)
 1181      000000
 284:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1182              		.loc 3 284 0
 1183 0ab9 0FB775D8 		movzwl	-40(%rbp), %esi
 1184 0abd 440FB745 		movzwl	-36(%rbp), %r8d
 1184      DC
 1185 0ac2 0FB74DE0 		movzwl	-32(%rbp), %ecx
 1186 0ac6 0FB655E4 		movzbl	-28(%rbp), %edx
 285:libusbwrap.c  **** 		dev->handle,
 1187              		.loc 3 285 0
 1188 0aca 488B45E8 		movq	-24(%rbp), %rax
 1189 0ace 488B00   		movq	(%rax), %rax
 284:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1190              		.loc 3 284 0
 1191 0ad1 4C8B4DD0 		movq	-48(%rbp), %r9
 1192 0ad5 8B7D10   		movl	16(%rbp), %edi
 1193 0ad8 57       		pushq	%rdi
 1194 0ad9 56       		pushq	%rsi
 1195 0ada BEC00000 		movl	$192, %esi
 1195      00
 1196 0adf 4889C7   		movq	%rax, %rdi
 1197 0ae2 E8000000 		call	libusb_control_transfer@PLT
 1197      00
 1198 0ae7 4883C410 		addq	$16, %rsp
 1199 0aeb 8945FC   		movl	%eax, -4(%rbp)
 286:libusbwrap.c  **** 		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
 287:libusbwrap.c  **** 		bRequest,
 288:libusbwrap.c  **** 		wValue,
 289:libusbwrap.c  **** 		wIndex,
 290:libusbwrap.c  **** 		(uint8 *)data,
 291:libusbwrap.c  **** 		wLength,
 292:libusbwrap.c  **** 		timeout
 293:libusbwrap.c  **** 	);
 294:libusbwrap.c  **** 	CHECK_STATUS(
 1200              		.loc 3 294 0
 1201 0aee 837DFCF9 		cmpl	$-7, -4(%rbp)
 1202 0af2 751C     		jne	.L90
 1203              		.loc 3 294 0 is_stmt 0 discriminator 1
 1204 0af4 488B4518 		movq	24(%rbp), %rax
 1205 0af8 488D3500 		leaq	.LC10(%rip), %rsi
 1205      000000
 1206 0aff 4889C7   		movq	%rax, %rdi
 1207 0b02 E8000000 		call	errPrefix@PLT
 1207      00
 1208 0b07 C745F812 		movl	$18, -8(%rbp)
 1208      000000
 1209 0b0e EB66     		jmp	.L91
 1210              	.L90:
 295:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 296:libusbwrap.c  **** 		"usbControlRead(): Timeout!");
 297:libusbwrap.c  **** 	CHECK_STATUS(
 1211              		.loc 3 297 0 is_stmt 1
 1212 0b10 837DFC00 		cmpl	$0, -4(%rbp)
 1213 0b14 792E     		jns	.L92
 1214              		.loc 3 297 0 is_stmt 0 discriminator 1
 1215 0b16 8B45FC   		movl	-4(%rbp), %eax
 1216 0b19 89C7     		movl	%eax, %edi
 1217 0b1b E8000000 		call	libusb_error_name@PLT
 1217      00
 1218 0b20 4889C2   		movq	%rax, %rdx
 1219 0b23 488B4518 		movq	24(%rbp), %rax
 1220 0b27 488D3500 		leaq	.LC11(%rip), %rsi
 1220      000000
 1221 0b2e 4889C7   		movq	%rax, %rdi
 1222 0b31 B8000000 		movl	$0, %eax
 1222      00
 1223 0b36 E8000000 		call	errRender@PLT
 1223      00
 1224 0b3b C745F80A 		movl	$10, -8(%rbp)
 1224      000000
 1225 0b42 EB32     		jmp	.L91
 1226              	.L92:
 298:libusbwrap.c  **** 		status < 0, USB_CONTROL, cleanup,
 299:libusbwrap.c  **** 		"usbControlRead(): %s", libusb_error_name(status));
 300:libusbwrap.c  **** 	CHECK_STATUS(
 1227              		.loc 3 300 0 is_stmt 1
 1228 0b44 0FB745D8 		movzwl	-40(%rbp), %eax
 1229 0b48 3945FC   		cmpl	%eax, -4(%rbp)
 1230 0b4b 7428     		je	.L94
 1231              		.loc 3 300 0 is_stmt 0 discriminator 1
 1232 0b4d 0FB755D8 		movzwl	-40(%rbp), %edx
 1233 0b51 8B4DFC   		movl	-4(%rbp), %ecx
 1234 0b54 488B4518 		movq	24(%rbp), %rax
 1235 0b58 488D3500 		leaq	.LC12(%rip), %rsi
 1235      000000
 1236 0b5f 4889C7   		movq	%rax, %rdi
 1237 0b62 B8000000 		movl	$0, %eax
 1237      00
 1238 0b67 E8000000 		call	errRender@PLT
 1238      00
 1239 0b6c C745F80A 		movl	$10, -8(%rbp)
 1239      000000
 1240 0b73 EB01     		jmp	.L91
 1241              	.L94:
 301:libusbwrap.c  **** 		status != wLength, USB_CONTROL, cleanup,
 302:libusbwrap.c  **** 		"usbControlRead(): Expected to read %d bytes but actually read %d", wLength, status);
 303:libusbwrap.c  **** cleanup:
 1242              		.loc 3 303 0 is_stmt 1
 1243 0b75 90       		nop
 1244              	.L91:
 304:libusbwrap.c  **** 	return retVal;
 1245              		.loc 3 304 0
 1246 0b76 8B45F8   		movl	-8(%rbp), %eax
 305:libusbwrap.c  **** }
 1247              		.loc 3 305 0
 1248 0b79 C9       		leave
 1249              		.cfi_def_cfa 7, 8
 1250 0b7a C3       		ret
 1251              		.cfi_endproc
 1252              	.LFE32:
 1254              		.section	.rodata
 1255              	.LC13:
 1256 0259 75736243 		.string	"usbControlWrite(): Timeout"
 1256      6F6E7472 
 1256      6F6C5772 
 1256      69746528 
 1256      293A2054 
 1257              	.LC14:
 1258 0274 75736243 		.string	"usbControlWrite(): %s"
 1258      6F6E7472 
 1258      6F6C5772 
 1258      69746528 
 1258      293A2025 
 1259 028a 00000000 		.align 8
 1259      0000
 1260              	.LC15:
 1261 0290 75736243 		.string	"usbControlWrite(): Expected to write %d bytes but actually wrote %d"
 1261      6F6E7472 
 1261      6F6C5772 
 1261      69746528 
 1261      293A2045 
 1262              		.text
 1263              		.globl	usbControlWrite
 1265              	usbControlWrite:
 1266              	.LFB33:
 306:libusbwrap.c  **** 
 307:libusbwrap.c  **** DLLEXPORT(USBStatus) usbControlWrite(
 308:libusbwrap.c  **** 	struct USBDevice *dev, uint8 bRequest, uint16 wValue, uint16 wIndex,
 309:libusbwrap.c  **** 	const uint8 *data, uint16 wLength,
 310:libusbwrap.c  **** 	uint32 timeout, const char **error)
 311:libusbwrap.c  **** {
 1267              		.loc 3 311 0
 1268              		.cfi_startproc
 1269 0b7b 55       		pushq	%rbp
 1270              		.cfi_def_cfa_offset 16
 1271              		.cfi_offset 6, -16
 1272 0b7c 4889E5   		movq	%rsp, %rbp
 1273              		.cfi_def_cfa_register 6
 1274 0b7f 4883EC30 		subq	$48, %rsp
 1275 0b83 48897DE8 		movq	%rdi, -24(%rbp)
 1276 0b87 89C8     		movl	%ecx, %eax
 1277 0b89 4C8945D0 		movq	%r8, -48(%rbp)
 1278 0b8d 4489CF   		movl	%r9d, %edi
 1279 0b90 89F1     		movl	%esi, %ecx
 1280 0b92 884DE4   		movb	%cl, -28(%rbp)
 1281 0b95 668955E0 		movw	%dx, -32(%rbp)
 1282 0b99 668945DC 		movw	%ax, -36(%rbp)
 1283 0b9d 89F8     		movl	%edi, %eax
 1284 0b9f 668945D8 		movw	%ax, -40(%rbp)
 312:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1285              		.loc 3 312 0
 1286 0ba3 C745F800 		movl	$0, -8(%rbp)
 1286      000000
 313:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1287              		.loc 3 313 0
 1288 0baa 0FB775D8 		movzwl	-40(%rbp), %esi
 1289 0bae 440FB745 		movzwl	-36(%rbp), %r8d
 1289      DC
 1290 0bb3 0FB74DE0 		movzwl	-32(%rbp), %ecx
 1291 0bb7 0FB655E4 		movzbl	-28(%rbp), %edx
 314:libusbwrap.c  **** 		dev->handle,
 1292              		.loc 3 314 0
 1293 0bbb 488B45E8 		movq	-24(%rbp), %rax
 1294 0bbf 488B00   		movq	(%rax), %rax
 313:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1295              		.loc 3 313 0
 1296 0bc2 4C8B4DD0 		movq	-48(%rbp), %r9
 1297 0bc6 8B7D10   		movl	16(%rbp), %edi
 1298 0bc9 57       		pushq	%rdi
 1299 0bca 56       		pushq	%rsi
 1300 0bcb BE400000 		movl	$64, %esi
 1300      00
 1301 0bd0 4889C7   		movq	%rax, %rdi
 1302 0bd3 E8000000 		call	libusb_control_transfer@PLT
 1302      00
 1303 0bd8 4883C410 		addq	$16, %rsp
 1304 0bdc 8945FC   		movl	%eax, -4(%rbp)
 315:libusbwrap.c  **** 		LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
 316:libusbwrap.c  **** 		bRequest,
 317:libusbwrap.c  **** 		wValue,
 318:libusbwrap.c  **** 		wIndex,
 319:libusbwrap.c  **** 		(uint8 *)data,
 320:libusbwrap.c  **** 		wLength,
 321:libusbwrap.c  **** 		timeout
 322:libusbwrap.c  **** 	);
 323:libusbwrap.c  **** 	CHECK_STATUS(
 1305              		.loc 3 323 0
 1306 0bdf 837DFCF9 		cmpl	$-7, -4(%rbp)
 1307 0be3 751C     		jne	.L96
 1308              		.loc 3 323 0 is_stmt 0 discriminator 1
 1309 0be5 488B4518 		movq	24(%rbp), %rax
 1310 0be9 488D3500 		leaq	.LC13(%rip), %rsi
 1310      000000
 1311 0bf0 4889C7   		movq	%rax, %rdi
 1312 0bf3 E8000000 		call	errPrefix@PLT
 1312      00
 1313 0bf8 C745F812 		movl	$18, -8(%rbp)
 1313      000000
 1314 0bff EB66     		jmp	.L97
 1315              	.L96:
 324:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 325:libusbwrap.c  **** 		"usbControlWrite(): Timeout");
 326:libusbwrap.c  **** 	CHECK_STATUS(
 1316              		.loc 3 326 0 is_stmt 1
 1317 0c01 837DFC00 		cmpl	$0, -4(%rbp)
 1318 0c05 792E     		jns	.L98
 1319              		.loc 3 326 0 is_stmt 0 discriminator 1
 1320 0c07 8B45FC   		movl	-4(%rbp), %eax
 1321 0c0a 89C7     		movl	%eax, %edi
 1322 0c0c E8000000 		call	libusb_error_name@PLT
 1322      00
 1323 0c11 4889C2   		movq	%rax, %rdx
 1324 0c14 488B4518 		movq	24(%rbp), %rax
 1325 0c18 488D3500 		leaq	.LC14(%rip), %rsi
 1325      000000
 1326 0c1f 4889C7   		movq	%rax, %rdi
 1327 0c22 B8000000 		movl	$0, %eax
 1327      00
 1328 0c27 E8000000 		call	errRender@PLT
 1328      00
 1329 0c2c C745F80A 		movl	$10, -8(%rbp)
 1329      000000
 1330 0c33 EB32     		jmp	.L97
 1331              	.L98:
 327:libusbwrap.c  **** 		status < 0, USB_CONTROL, cleanup,
 328:libusbwrap.c  **** 		"usbControlWrite(): %s", libusb_error_name(status));
 329:libusbwrap.c  **** 	CHECK_STATUS(
 1332              		.loc 3 329 0 is_stmt 1
 1333 0c35 0FB745D8 		movzwl	-40(%rbp), %eax
 1334 0c39 3945FC   		cmpl	%eax, -4(%rbp)
 1335 0c3c 7428     		je	.L100
 1336              		.loc 3 329 0 is_stmt 0 discriminator 1
 1337 0c3e 0FB755D8 		movzwl	-40(%rbp), %edx
 1338 0c42 8B4DFC   		movl	-4(%rbp), %ecx
 1339 0c45 488B4518 		movq	24(%rbp), %rax
 1340 0c49 488D3500 		leaq	.LC15(%rip), %rsi
 1340      000000
 1341 0c50 4889C7   		movq	%rax, %rdi
 1342 0c53 B8000000 		movl	$0, %eax
 1342      00
 1343 0c58 E8000000 		call	errRender@PLT
 1343      00
 1344 0c5d C745F80A 		movl	$10, -8(%rbp)
 1344      000000
 1345 0c64 EB01     		jmp	.L97
 1346              	.L100:
 330:libusbwrap.c  **** 		status != wLength, USB_CONTROL, cleanup,
 331:libusbwrap.c  **** 		"usbControlWrite(): Expected to write %d bytes but actually wrote %d", wLength, status);
 332:libusbwrap.c  **** cleanup:
 1347              		.loc 3 332 0 is_stmt 1
 1348 0c66 90       		nop
 1349              	.L97:
 333:libusbwrap.c  **** 	return retVal;
 1350              		.loc 3 333 0
 1351 0c67 8B45F8   		movl	-8(%rbp), %eax
 334:libusbwrap.c  **** }
 1352              		.loc 3 334 0
 1353 0c6a C9       		leave
 1354              		.cfi_def_cfa 7, 8
 1355 0c6b C3       		ret
 1356              		.cfi_endproc
 1357              	.LFE33:
 1359              		.section	.rodata
 1360              	.LC16:
 1361 02d4 75736242 		.string	"usbBulkRead(): Timeout"
 1361      756C6B52 
 1361      65616428 
 1361      293A2054 
 1361      696D656F 
 1362              	.LC17:
 1363 02eb 75736242 		.string	"usbBulkRead(): %s"
 1363      756C6B52 
 1363      65616428 
 1363      293A2025 
 1363      7300
 1364 02fd 000000   		.align 8
 1365              	.LC18:
 1366 0300 75736242 		.string	"usbBulkRead(): Expected to read %d bytes but actually read %d (status = %d): %s"
 1366      756C6B52 
 1366      65616428 
 1366      293A2045 
 1366      78706563 
 1367              		.text
 1368              		.globl	usbBulkRead
 1370              	usbBulkRead:
 1371              	.LFB34:
 335:libusbwrap.c  **** 
 336:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkRead(
 337:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint8 *data, uint32 count,
 338:libusbwrap.c  **** 	uint32 timeout, const char **error)
 339:libusbwrap.c  **** {
 1372              		.loc 3 339 0
 1373              		.cfi_startproc
 1374 0c6c 55       		pushq	%rbp
 1375              		.cfi_def_cfa_offset 16
 1376              		.cfi_offset 6, -16
 1377 0c6d 4889E5   		movq	%rsp, %rbp
 1378              		.cfi_def_cfa_register 6
 1379 0c70 4883EC50 		subq	$80, %rsp
 1380 0c74 48897DD8 		movq	%rdi, -40(%rbp)
 1381 0c78 89F0     		movl	%esi, %eax
 1382 0c7a 488955C8 		movq	%rdx, -56(%rbp)
 1383 0c7e 894DD0   		movl	%ecx, -48(%rbp)
 1384 0c81 448945C4 		movl	%r8d, -60(%rbp)
 1385 0c85 4C894DB8 		movq	%r9, -72(%rbp)
 1386 0c89 8845D4   		movb	%al, -44(%rbp)
 1387              		.loc 3 339 0
 1388 0c8c 64488B04 		movq	%fs:40, %rax
 1388      25280000 
 1388      00
 1389 0c95 488945F8 		movq	%rax, -8(%rbp)
 1390 0c99 31C0     		xorl	%eax, %eax
 340:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1391              		.loc 3 340 0
 1392 0c9b C745F000 		movl	$0, -16(%rbp)
 1392      000000
 341:libusbwrap.c  **** 	int numRead;
 342:libusbwrap.c  **** 	int status = libusb_bulk_transfer(
 1393              		.loc 3 342 0
 1394 0ca2 8B4DD0   		movl	-48(%rbp), %ecx
 1395 0ca5 0FB645D4 		movzbl	-44(%rbp), %eax
 1396 0ca9 83C880   		orl	$-128, %eax
 1397 0cac 0FB6F0   		movzbl	%al, %esi
 343:libusbwrap.c  **** 		dev->handle,
 1398              		.loc 3 343 0
 1399 0caf 488B45D8 		movq	-40(%rbp), %rax
 1400 0cb3 488B00   		movq	(%rax), %rax
 342:libusbwrap.c  **** 		dev->handle,
 1401              		.loc 3 342 0
 1402 0cb6 448B45C4 		movl	-60(%rbp), %r8d
 1403 0cba 488D7DEC 		leaq	-20(%rbp), %rdi
 1404 0cbe 488B55C8 		movq	-56(%rbp), %rdx
 1405 0cc2 4589C1   		movl	%r8d, %r9d
 1406 0cc5 4989F8   		movq	%rdi, %r8
 1407 0cc8 4889C7   		movq	%rax, %rdi
 1408 0ccb E8000000 		call	libusb_bulk_transfer@PLT
 1408      00
 1409 0cd0 8945F4   		movl	%eax, -12(%rbp)
 344:libusbwrap.c  **** 		LIBUSB_ENDPOINT_IN | endpoint,
 345:libusbwrap.c  **** 		data,
 346:libusbwrap.c  **** 		(int)count,
 347:libusbwrap.c  **** 		&numRead,
 348:libusbwrap.c  **** 		timeout
 349:libusbwrap.c  **** 	);
 350:libusbwrap.c  **** 	CHECK_STATUS(
 1410              		.loc 3 350 0
 1411 0cd3 837DF4F9 		cmpl	$-7, -12(%rbp)
 1412 0cd7 751C     		jne	.L102
 1413              		.loc 3 350 0 is_stmt 0 discriminator 1
 1414 0cd9 488B45B8 		movq	-72(%rbp), %rax
 1415 0cdd 488D3500 		leaq	.LC16(%rip), %rsi
 1415      000000
 1416 0ce4 4889C7   		movq	%rax, %rdi
 1417 0ce7 E8000000 		call	errPrefix@PLT
 1417      00
 1418 0cec C745F012 		movl	$18, -16(%rbp)
 1418      000000
 1419 0cf3 EB7A     		jmp	.L103
 1420              	.L102:
 351:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 352:libusbwrap.c  **** 		"usbBulkRead(): Timeout");
 353:libusbwrap.c  **** 	CHECK_STATUS(
 1421              		.loc 3 353 0 is_stmt 1
 1422 0cf5 837DF400 		cmpl	$0, -12(%rbp)
 1423 0cf9 792E     		jns	.L104
 1424              		.loc 3 353 0 is_stmt 0 discriminator 1
 1425 0cfb 8B45F4   		movl	-12(%rbp), %eax
 1426 0cfe 89C7     		movl	%eax, %edi
 1427 0d00 E8000000 		call	libusb_error_name@PLT
 1427      00
 1428 0d05 4889C2   		movq	%rax, %rdx
 1429 0d08 488B45B8 		movq	-72(%rbp), %rax
 1430 0d0c 488D3500 		leaq	.LC17(%rip), %rsi
 1430      000000
 1431 0d13 4889C7   		movq	%rax, %rdi
 1432 0d16 B8000000 		movl	$0, %eax
 1432      00
 1433 0d1b E8000000 		call	errRender@PLT
 1433      00
 1434 0d20 C745F00B 		movl	$11, -16(%rbp)
 1434      000000
 1435 0d27 EB46     		jmp	.L103
 1436              	.L104:
 354:libusbwrap.c  **** 		status < 0, USB_BULK, cleanup,
 355:libusbwrap.c  **** 		"usbBulkRead(): %s", libusb_error_name(status));
 356:libusbwrap.c  **** 	CHECK_STATUS(
 1437              		.loc 3 356 0 is_stmt 1
 1438 0d29 8B45EC   		movl	-20(%rbp), %eax
 1439 0d2c 3945D0   		cmpl	%eax, -48(%rbp)
 1440 0d2f 743D     		je	.L107
 1441              		.loc 3 356 0 is_stmt 0 discriminator 1
 1442 0d31 8B45F4   		movl	-12(%rbp), %eax
 1443 0d34 89C7     		movl	%eax, %edi
 1444 0d36 E8000000 		call	libusb_error_name@PLT
 1444      00
 1445 0d3b 4889C7   		movq	%rax, %rdi
 1446 0d3e 8B4DEC   		movl	-20(%rbp), %ecx
 1447 0d41 8B75F4   		movl	-12(%rbp), %esi
 1448 0d44 8B55D0   		movl	-48(%rbp), %edx
 1449 0d47 488B45B8 		movq	-72(%rbp), %rax
 1450 0d4b 4989F9   		movq	%rdi, %r9
 1451 0d4e 4189F0   		movl	%esi, %r8d
 1452 0d51 488D3500 		leaq	.LC18(%rip), %rsi
 1452      000000
 1453 0d58 4889C7   		movq	%rax, %rdi
 1454 0d5b B8000000 		movl	$0, %eax
 1454      00
 1455 0d60 E8000000 		call	errRender@PLT
 1455      00
 1456 0d65 C745F00B 		movl	$11, -16(%rbp)
 1456      000000
 1457 0d6c EB01     		jmp	.L103
 1458              	.L107:
 357:libusbwrap.c  **** 		(uint32)numRead != count, USB_BULK, cleanup,
 358:libusbwrap.c  **** 		"usbBulkRead(): Expected to read %d bytes but actually read %d (status = %d): %s",
 359:libusbwrap.c  **** 		count, numRead, status, libusb_error_name(status));
 360:libusbwrap.c  **** cleanup:
 1459              		.loc 3 360 0 is_stmt 1
 1460 0d6e 90       		nop
 1461              	.L103:
 361:libusbwrap.c  **** 	return retVal;
 1462              		.loc 3 361 0
 1463 0d6f 8B45F0   		movl	-16(%rbp), %eax
 362:libusbwrap.c  **** }
 1464              		.loc 3 362 0
 1465 0d72 488B4DF8 		movq	-8(%rbp), %rcx
 1466 0d76 6448330C 		xorq	%fs:40, %rcx
 1466      25280000 
 1466      00
 1467 0d7f 7405     		je	.L106
 1468 0d81 E8000000 		call	__stack_chk_fail@PLT
 1468      00
 1469              	.L106:
 1470 0d86 C9       		leave
 1471              		.cfi_def_cfa 7, 8
 1472 0d87 C3       		ret
 1473              		.cfi_endproc
 1474              	.LFE34:
 1476              		.section	.rodata
 1477              	.LC19:
 1478 0350 75736242 		.string	"usbBulkWrite(): Timeout"
 1478      756C6B57 
 1478      72697465 
 1478      28293A20 
 1478      54696D65 
 1479              	.LC20:
 1480 0368 75736242 		.string	"usbBulkWrite(): %s"
 1480      756C6B57 
 1480      72697465 
 1480      28293A20 
 1480      257300
 1481 037b 00000000 		.align 8
 1481      00
 1482              	.LC21:
 1483 0380 75736242 		.string	"usbBulkWrite(): Expected to write %d bytes but actually wrote %d (status = %d): %s"
 1483      756C6B57 
 1483      72697465 
 1483      28293A20 
 1483      45787065 
 1484              		.text
 1485              		.globl	usbBulkWrite
 1487              	usbBulkWrite:
 1488              	.LFB35:
 363:libusbwrap.c  **** 
 364:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWrite(
 365:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, const uint8 *data, uint32 count,
 366:libusbwrap.c  **** 	uint32 timeout, const char **error)
 367:libusbwrap.c  **** {
 1489              		.loc 3 367 0
 1490              		.cfi_startproc
 1491 0d88 55       		pushq	%rbp
 1492              		.cfi_def_cfa_offset 16
 1493              		.cfi_offset 6, -16
 1494 0d89 4889E5   		movq	%rsp, %rbp
 1495              		.cfi_def_cfa_register 6
 1496 0d8c 4883EC50 		subq	$80, %rsp
 1497 0d90 48897DD8 		movq	%rdi, -40(%rbp)
 1498 0d94 89F0     		movl	%esi, %eax
 1499 0d96 488955C8 		movq	%rdx, -56(%rbp)
 1500 0d9a 894DD0   		movl	%ecx, -48(%rbp)
 1501 0d9d 448945C4 		movl	%r8d, -60(%rbp)
 1502 0da1 4C894DB8 		movq	%r9, -72(%rbp)
 1503 0da5 8845D4   		movb	%al, -44(%rbp)
 1504              		.loc 3 367 0
 1505 0da8 64488B04 		movq	%fs:40, %rax
 1505      25280000 
 1505      00
 1506 0db1 488945F8 		movq	%rax, -8(%rbp)
 1507 0db5 31C0     		xorl	%eax, %eax
 368:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1508              		.loc 3 368 0
 1509 0db7 C745F000 		movl	$0, -16(%rbp)
 1509      000000
 369:libusbwrap.c  **** 	int numWritten;
 370:libusbwrap.c  **** 	int status = libusb_bulk_transfer(
 1510              		.loc 3 370 0
 1511 0dbe 8B4DD0   		movl	-48(%rbp), %ecx
 1512 0dc1 0FB675D4 		movzbl	-44(%rbp), %esi
 371:libusbwrap.c  **** 		dev->handle,
 1513              		.loc 3 371 0
 1514 0dc5 488B45D8 		movq	-40(%rbp), %rax
 1515 0dc9 488B00   		movq	(%rax), %rax
 370:libusbwrap.c  **** 		dev->handle,
 1516              		.loc 3 370 0
 1517 0dcc 448B45C4 		movl	-60(%rbp), %r8d
 1518 0dd0 488D7DEC 		leaq	-20(%rbp), %rdi
 1519 0dd4 488B55C8 		movq	-56(%rbp), %rdx
 1520 0dd8 4589C1   		movl	%r8d, %r9d
 1521 0ddb 4989F8   		movq	%rdi, %r8
 1522 0dde 4889C7   		movq	%rax, %rdi
 1523 0de1 E8000000 		call	libusb_bulk_transfer@PLT
 1523      00
 1524 0de6 8945F4   		movl	%eax, -12(%rbp)
 372:libusbwrap.c  **** 		LIBUSB_ENDPOINT_OUT | endpoint,
 373:libusbwrap.c  **** 		(uint8 *)data,
 374:libusbwrap.c  **** 		(int)count,
 375:libusbwrap.c  **** 		&numWritten,
 376:libusbwrap.c  **** 		timeout
 377:libusbwrap.c  **** 	);
 378:libusbwrap.c  **** 	CHECK_STATUS(
 1525              		.loc 3 378 0
 1526 0de9 837DF4F9 		cmpl	$-7, -12(%rbp)
 1527 0ded 751C     		jne	.L109
 1528              		.loc 3 378 0 is_stmt 0 discriminator 1
 1529 0def 488B45B8 		movq	-72(%rbp), %rax
 1530 0df3 488D3500 		leaq	.LC19(%rip), %rsi
 1530      000000
 1531 0dfa 4889C7   		movq	%rax, %rdi
 1532 0dfd E8000000 		call	errPrefix@PLT
 1532      00
 1533 0e02 C745F012 		movl	$18, -16(%rbp)
 1533      000000
 1534 0e09 EB7A     		jmp	.L110
 1535              	.L109:
 379:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 380:libusbwrap.c  **** 		"usbBulkWrite(): Timeout");
 381:libusbwrap.c  **** 	CHECK_STATUS(
 1536              		.loc 3 381 0 is_stmt 1
 1537 0e0b 837DF400 		cmpl	$0, -12(%rbp)
 1538 0e0f 792E     		jns	.L111
 1539              		.loc 3 381 0 is_stmt 0 discriminator 1
 1540 0e11 8B45F4   		movl	-12(%rbp), %eax
 1541 0e14 89C7     		movl	%eax, %edi
 1542 0e16 E8000000 		call	libusb_error_name@PLT
 1542      00
 1543 0e1b 4889C2   		movq	%rax, %rdx
 1544 0e1e 488B45B8 		movq	-72(%rbp), %rax
 1545 0e22 488D3500 		leaq	.LC20(%rip), %rsi
 1545      000000
 1546 0e29 4889C7   		movq	%rax, %rdi
 1547 0e2c B8000000 		movl	$0, %eax
 1547      00
 1548 0e31 E8000000 		call	errRender@PLT
 1548      00
 1549 0e36 C745F00B 		movl	$11, -16(%rbp)
 1549      000000
 1550 0e3d EB46     		jmp	.L110
 1551              	.L111:
 382:libusbwrap.c  **** 		status < 0, USB_BULK, cleanup,
 383:libusbwrap.c  **** 		"usbBulkWrite(): %s", libusb_error_name(status));
 384:libusbwrap.c  **** 	CHECK_STATUS(
 1552              		.loc 3 384 0 is_stmt 1
 1553 0e3f 8B45EC   		movl	-20(%rbp), %eax
 1554 0e42 3945D0   		cmpl	%eax, -48(%rbp)
 1555 0e45 743D     		je	.L114
 1556              		.loc 3 384 0 is_stmt 0 discriminator 1
 1557 0e47 8B45F4   		movl	-12(%rbp), %eax
 1558 0e4a 89C7     		movl	%eax, %edi
 1559 0e4c E8000000 		call	libusb_error_name@PLT
 1559      00
 1560 0e51 4889C7   		movq	%rax, %rdi
 1561 0e54 8B4DEC   		movl	-20(%rbp), %ecx
 1562 0e57 8B75F4   		movl	-12(%rbp), %esi
 1563 0e5a 8B55D0   		movl	-48(%rbp), %edx
 1564 0e5d 488B45B8 		movq	-72(%rbp), %rax
 1565 0e61 4989F9   		movq	%rdi, %r9
 1566 0e64 4189F0   		movl	%esi, %r8d
 1567 0e67 488D3500 		leaq	.LC21(%rip), %rsi
 1567      000000
 1568 0e6e 4889C7   		movq	%rax, %rdi
 1569 0e71 B8000000 		movl	$0, %eax
 1569      00
 1570 0e76 E8000000 		call	errRender@PLT
 1570      00
 1571 0e7b C745F00B 		movl	$11, -16(%rbp)
 1571      000000
 1572 0e82 EB01     		jmp	.L110
 1573              	.L114:
 385:libusbwrap.c  **** 		(uint32)numWritten != count, USB_BULK, cleanup,
 386:libusbwrap.c  **** 		"usbBulkWrite(): Expected to write %d bytes but actually wrote %d (status = %d): %s",
 387:libusbwrap.c  **** 		count, numWritten, status, libusb_error_name(status));
 388:libusbwrap.c  **** cleanup:
 1574              		.loc 3 388 0 is_stmt 1
 1575 0e84 90       		nop
 1576              	.L110:
 389:libusbwrap.c  **** 	return retVal;
 1577              		.loc 3 389 0
 1578 0e85 8B45F0   		movl	-16(%rbp), %eax
 390:libusbwrap.c  **** }
 1579              		.loc 3 390 0
 1580 0e88 488B4DF8 		movq	-8(%rbp), %rcx
 1581 0e8c 6448330C 		xorq	%fs:40, %rcx
 1581      25280000 
 1581      00
 1582 0e95 7405     		je	.L113
 1583 0e97 E8000000 		call	__stack_chk_fail@PLT
 1583      00
 1584              	.L113:
 1585 0e9c C9       		leave
 1586              		.cfi_def_cfa 7, 8
 1587 0e9d C3       		ret
 1588              		.cfi_endproc
 1589              	.LFE35:
 1592              	bulk_transfer_cb:
 1593              	.LFB36:
 391:libusbwrap.c  **** 
 392:libusbwrap.c  **** static void LIBUSB_CALL bulk_transfer_cb(struct libusb_transfer *transfer) {
 1594              		.loc 3 392 0
 1595              		.cfi_startproc
 1596 0e9e 55       		pushq	%rbp
 1597              		.cfi_def_cfa_offset 16
 1598              		.cfi_offset 6, -16
 1599 0e9f 4889E5   		movq	%rsp, %rbp
 1600              		.cfi_def_cfa_register 6
 1601 0ea2 48897DE8 		movq	%rdi, -24(%rbp)
 393:libusbwrap.c  **** 	int *completed = transfer->user_data;
 1602              		.loc 3 393 0
 1603 0ea6 488B45E8 		movq	-24(%rbp), %rax
 1604 0eaa 488B4028 		movq	40(%rax), %rax
 1605 0eae 488945F8 		movq	%rax, -8(%rbp)
 394:libusbwrap.c  **** 	*completed = 1;
 1606              		.loc 3 394 0
 1607 0eb2 488B45F8 		movq	-8(%rbp), %rax
 1608 0eb6 C7000100 		movl	$1, (%rax)
 1608      0000
 395:libusbwrap.c  **** }
 1609              		.loc 3 395 0
 1610 0ebc 90       		nop
 1611 0ebd 5D       		popq	%rbp
 1612              		.cfi_def_cfa 7, 8
 1613 0ebe C3       		ret
 1614              		.cfi_endproc
 1615              	.LFE36:
 1617              		.section	.rodata
 1618 03d3 00000000 		.align 8
 1618      00
 1619              	.LC22:
 1620 03d8 75736242 		.string	"usbBulkWriteAsync(): Submission error: %s"
 1620      756C6B57 
 1620      72697465 
 1620      4173796E 
 1620      6328293A 
 1621              		.text
 1622              		.globl	usbBulkWriteAsync
 1624              	usbBulkWriteAsync:
 1625              	.LFB37:
 396:libusbwrap.c  **** 
 397:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsync(
 398:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, const uint8 *buffer, uint32 length, uint32 timeout,
 399:libusbwrap.c  **** 	const char **error)
 400:libusbwrap.c  **** {
 1626              		.loc 3 400 0
 1627              		.cfi_startproc
 1628 0ebf 55       		pushq	%rbp
 1629              		.cfi_def_cfa_offset 16
 1630              		.cfi_offset 6, -16
 1631 0ec0 4889E5   		movq	%rsp, %rbp
 1632              		.cfi_def_cfa_register 6
 1633 0ec3 4883EC60 		subq	$96, %rsp
 1634 0ec7 48897DC8 		movq	%rdi, -56(%rbp)
 1635 0ecb 89F0     		movl	%esi, %eax
 1636 0ecd 488955B8 		movq	%rdx, -72(%rbp)
 1637 0ed1 894DC0   		movl	%ecx, -64(%rbp)
 1638 0ed4 448945B4 		movl	%r8d, -76(%rbp)
 1639 0ed8 4C894DA8 		movq	%r9, -88(%rbp)
 1640 0edc 8845C4   		movb	%al, -60(%rbp)
 1641              		.loc 3 400 0
 1642 0edf 64488B04 		movq	%fs:40, %rax
 1642      25280000 
 1642      00
 1643 0ee8 488945F8 		movq	%rax, -8(%rbp)
 1644 0eec 31C0     		xorl	%eax, %eax
 401:libusbwrap.c  **** 	int retVal = USB_SUCCESS;
 1645              		.loc 3 401 0
 1646 0eee C745D400 		movl	$0, -44(%rbp)
 1646      000000
 402:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 403:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 404:libusbwrap.c  **** 	int *completed;
 405:libusbwrap.c  **** 	int iStatus;
 406:libusbwrap.c  **** 	USBStatus uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1647              		.loc 3 406 0
 1648 0ef5 488B45C8 		movq	-56(%rbp), %rax
 1649 0ef9 488D5008 		leaq	8(%rax), %rdx
 1650 0efd 488D45E0 		leaq	-32(%rbp), %rax
 1651 0f01 4889C6   		movq	%rax, %rsi
 1652 0f04 4889D7   		movq	%rdx, %rdi
 1653 0f07 E8000000 		call	queuePut@PLT
 1653      00
 1654 0f0c 8945D8   		movl	%eax, -40(%rbp)
 407:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup);
 1655              		.loc 3 407 0
 1656 0f0f 837DD800 		cmpl	$0, -40(%rbp)
 1657 0f13 740B     		je	.L117
 1658              		.loc 3 407 0 is_stmt 0 discriminator 1
 1659 0f15 8B45D8   		movl	-40(%rbp), %eax
 1660 0f18 8945D4   		movl	%eax, -44(%rbp)
 1661 0f1b E9BB0000 		jmp	.L118
 1661      00
 1662              	.L117:
 408:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1663              		.loc 3 408 0 is_stmt 1
 1664 0f20 488B45E0 		movq	-32(%rbp), %rax
 1665 0f24 488B00   		movq	(%rax), %rax
 1666 0f27 488945E8 		movq	%rax, -24(%rbp)
 409:libusbwrap.c  **** 	completed = &wrapper->completed;
 1667              		.loc 3 409 0
 1668 0f2b 488B45E0 		movq	-32(%rbp), %rax
 1669 0f2f 4883C008 		addq	$8, %rax
 1670 0f33 488945F0 		movq	%rax, -16(%rbp)
 410:libusbwrap.c  **** 	*completed = 0;
 1671              		.loc 3 410 0
 1672 0f37 488B45F0 		movq	-16(%rbp), %rax
 1673 0f3b C7000000 		movl	$0, (%rax)
 1673      0000
 411:libusbwrap.c  **** 	wrapper->flags.isRead = 0;
 1674              		.loc 3 411 0
 1675 0f41 488B45E0 		movq	-32(%rbp), %rax
 1676 0f45 0FB6500C 		movzbl	12(%rax), %edx
 1677 0f49 83E2FE   		andl	$-2, %edx
 1678 0f4c 88500C   		movb	%dl, 12(%rax)
 412:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1679              		.loc 3 412 0
 1680 0f4f 448B45C0 		movl	-64(%rbp), %r8d
 1681 0f53 0FB655C4 		movzbl	-60(%rbp), %edx
 413:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_OUT | endpoint, (uint8 *)buffer, (int)length,
 1682              		.loc 3 413 0
 1683 0f57 488B45C8 		movq	-56(%rbp), %rax
 1684 0f5b 488B30   		movq	(%rax), %rsi
 412:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1685              		.loc 3 412 0
 1686 0f5e 488B4DB8 		movq	-72(%rbp), %rcx
 1687 0f62 488B45E8 		movq	-24(%rbp), %rax
 1688 0f66 8B7DB4   		movl	-76(%rbp), %edi
 1689 0f69 57       		pushq	%rdi
 1690 0f6a FF75F0   		pushq	-16(%rbp)
 1691 0f6d 4C8D0D2A 		leaq	bulk_transfer_cb(%rip), %r9
 1691      FFFFFF
 1692 0f74 4889C7   		movq	%rax, %rdi
 1693 0f77 E896F0FF 		call	libusb_fill_bulk_transfer
 1693      FF
 1694 0f7c 4883C410 		addq	$16, %rsp
 414:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 415:libusbwrap.c  **** 	);
 416:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 1695              		.loc 3 416 0
 1696 0f80 488B45E8 		movq	-24(%rbp), %rax
 1697 0f84 C6400A02 		movb	$2, 10(%rax)
 417:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 1698              		.loc 3 417 0
 1699 0f88 488B45E8 		movq	-24(%rbp), %rax
 1700 0f8c 4889C7   		movq	%rax, %rdi
 1701 0f8f E8000000 		call	libusb_submit_transfer@PLT
 1701      00
 1702 0f94 8945DC   		movl	%eax, -36(%rbp)
 418:libusbwrap.c  **** 	CHECK_STATUS(
 1703              		.loc 3 418 0
 1704 0f97 837DDC00 		cmpl	$0, -36(%rbp)
 1705 0f9b 742E     		je	.L119
 1706              		.loc 3 418 0 is_stmt 0 discriminator 1
 1707 0f9d 8B45DC   		movl	-36(%rbp), %eax
 1708 0fa0 89C7     		movl	%eax, %edi
 1709 0fa2 E8000000 		call	libusb_error_name@PLT
 1709      00
 1710 0fa7 4889C2   		movq	%rax, %rdx
 1711 0faa 488B45A8 		movq	-88(%rbp), %rax
 1712 0fae 488D3500 		leaq	.LC22(%rip), %rsi
 1712      000000
 1713 0fb5 4889C7   		movq	%rax, %rdi
 1714 0fb8 B8000000 		movl	$0, %eax
 1714      00
 1715 0fbd E8000000 		call	errRender@PLT
 1715      00
 1716 0fc2 C745D40E 		movl	$14, -44(%rbp)
 1716      000000
 1717 0fc9 EB10     		jmp	.L118
 1718              	.L119:
 419:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 420:libusbwrap.c  **** 		"usbBulkWriteAsync(): Submission error: %s", libusb_error_name(iStatus)
 421:libusbwrap.c  **** 	);
 422:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 1719              		.loc 3 422 0 is_stmt 1
 1720 0fcb 488B45C8 		movq	-56(%rbp), %rax
 1721 0fcf 4883C008 		addq	$8, %rax
 1722 0fd3 4889C7   		movq	%rax, %rdi
 1723 0fd6 E8000000 		call	queueCommitPut@PLT
 1723      00
 1724              	.L118:
 423:libusbwrap.c  **** cleanup:
 424:libusbwrap.c  **** 	return retVal;
 1725              		.loc 3 424 0
 1726 0fdb 8B45D4   		movl	-44(%rbp), %eax
 425:libusbwrap.c  **** }
 1727              		.loc 3 425 0
 1728 0fde 488B4DF8 		movq	-8(%rbp), %rcx
 1729 0fe2 6448330C 		xorq	%fs:40, %rcx
 1729      25280000 
 1729      00
 1730 0feb 7405     		je	.L121
 1731 0fed E8000000 		call	__stack_chk_fail@PLT
 1731      00
 1732              	.L121:
 1733 0ff2 C9       		leave
 1734              		.cfi_def_cfa 7, 8
 1735 0ff3 C3       		ret
 1736              		.cfi_endproc
 1737              	.LFE37:
 1739              		.section	.rodata
 1740 0402 00000000 		.align 8
 1740      0000
 1741              	.LC23:
 1742 0408 75736242 		.string	"usbBulkWriteAsyncPrepare(): Work queue insertion error"
 1742      756C6B57 
 1742      72697465 
 1742      4173796E 
 1742      63507265 
 1743              		.text
 1744              		.globl	usbBulkWriteAsyncPrepare
 1746              	usbBulkWriteAsyncPrepare:
 1747              	.LFB38:
 426:libusbwrap.c  **** 
 427:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsyncPrepare(
 428:libusbwrap.c  **** 	struct USBDevice *dev, uint8 **buffer, const char **error)
 429:libusbwrap.c  **** {
 1748              		.loc 3 429 0
 1749              		.cfi_startproc
 1750 0ff4 55       		pushq	%rbp
 1751              		.cfi_def_cfa_offset 16
 1752              		.cfi_offset 6, -16
 1753 0ff5 4889E5   		movq	%rsp, %rbp
 1754              		.cfi_def_cfa_register 6
 1755 0ff8 4883EC40 		subq	$64, %rsp
 1756 0ffc 48897DD8 		movq	%rdi, -40(%rbp)
 1757 1000 488975D0 		movq	%rsi, -48(%rbp)
 1758 1004 488955C8 		movq	%rdx, -56(%rbp)
 1759              		.loc 3 429 0
 1760 1008 64488B04 		movq	%fs:40, %rax
 1760      25280000 
 1760      00
 1761 1011 488945F8 		movq	%rax, -8(%rbp)
 1762 1015 31C0     		xorl	%eax, %eax
 430:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1763              		.loc 3 430 0
 1764 1017 C745E800 		movl	$0, -24(%rbp)
 1764      000000
 431:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 432:libusbwrap.c  **** 	USBStatus status = queuePut(&dev->queue, (Item*)&wrapper);
 1765              		.loc 3 432 0
 1766 101e 488B45D8 		movq	-40(%rbp), %rax
 1767 1022 488D5008 		leaq	8(%rax), %rdx
 1768 1026 488D45F0 		leaq	-16(%rbp), %rax
 1769 102a 4889C6   		movq	%rax, %rsi
 1770 102d 4889D7   		movq	%rdx, %rdi
 1771 1030 E8000000 		call	queuePut@PLT
 1771      00
 1772 1035 8945EC   		movl	%eax, -20(%rbp)
 433:libusbwrap.c  **** 	CHECK_STATUS(status, status, cleanup, "usbBulkWriteAsyncPrepare(): Work queue insertion error");
 1773              		.loc 3 433 0
 1774 1038 837DEC00 		cmpl	$0, -20(%rbp)
 1775 103c 741B     		je	.L123
 1776              		.loc 3 433 0 is_stmt 0 discriminator 1
 1777 103e 488B45C8 		movq	-56(%rbp), %rax
 1778 1042 488D3500 		leaq	.LC23(%rip), %rsi
 1778      000000
 1779 1049 4889C7   		movq	%rax, %rdi
 1780 104c E8000000 		call	errPrefix@PLT
 1780      00
 1781 1051 8B45EC   		movl	-20(%rbp), %eax
 1782 1054 8945E8   		movl	%eax, -24(%rbp)
 1783 1057 EB0F     		jmp	.L124
 1784              	.L123:
 434:libusbwrap.c  **** 	*buffer = wrapper->buffer;
 1785              		.loc 3 434 0 is_stmt 1
 1786 1059 488B45F0 		movq	-16(%rbp), %rax
 1787 105d 488D5010 		leaq	16(%rax), %rdx
 1788 1061 488B45D0 		movq	-48(%rbp), %rax
 1789 1065 488910   		movq	%rdx, (%rax)
 1790              	.L124:
 435:libusbwrap.c  **** cleanup:
 436:libusbwrap.c  **** 	return retVal;
 1791              		.loc 3 436 0
 1792 1068 8B45E8   		movl	-24(%rbp), %eax
 437:libusbwrap.c  **** }
 1793              		.loc 3 437 0
 1794 106b 488B4DF8 		movq	-8(%rbp), %rcx
 1795 106f 6448330C 		xorq	%fs:40, %rcx
 1795      25280000 
 1795      00
 1796 1078 7405     		je	.L126
 1797 107a E8000000 		call	__stack_chk_fail@PLT
 1797      00
 1798              	.L126:
 1799 107f C9       		leave
 1800              		.cfi_def_cfa 7, 8
 1801 1080 C3       		ret
 1802              		.cfi_endproc
 1803              	.LFE38:
 1805              		.section	.rodata
 1806 043f 00       		.align 8
 1807              	.LC24:
 1808 0440 75736242 		.string	"usbBulkWriteAsyncSubmit(): Transfer length exceeds 0x10000"
 1808      756C6B57 
 1808      72697465 
 1808      4173796E 
 1808      63537562 
 1809 047b 00000000 		.align 8
 1809      00
 1810              	.LC25:
 1811 0480 75736242 		.string	"usbBulkWriteAsyncSubmit(): Work queue insertion error"
 1811      756C6B57 
 1811      72697465 
 1811      4173796E 
 1811      63537562 
 1812 04b6 0000     		.align 8
 1813              	.LC26:
 1814 04b8 75736242 		.string	"usbBulkWriteAsyncSubmit(): Submission error: %s"
 1814      756C6B57 
 1814      72697465 
 1814      4173796E 
 1814      63537562 
 1815              		.text
 1816              		.globl	usbBulkWriteAsyncSubmit
 1818              	usbBulkWriteAsyncSubmit:
 1819              	.LFB39:
 438:libusbwrap.c  **** 
 439:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsyncSubmit(
 440:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint32 length, uint32 timeout, const char **error)
 441:libusbwrap.c  **** {
 1820              		.loc 3 441 0
 1821              		.cfi_startproc
 1822 1081 55       		pushq	%rbp
 1823              		.cfi_def_cfa_offset 16
 1824              		.cfi_offset 6, -16
 1825 1082 4889E5   		movq	%rsp, %rbp
 1826              		.cfi_def_cfa_register 6
 1827 1085 4883EC50 		subq	$80, %rsp
 1828 1089 48897DC8 		movq	%rdi, -56(%rbp)
 1829 108d 89F0     		movl	%esi, %eax
 1830 108f 8955C0   		movl	%edx, -64(%rbp)
 1831 1092 894DBC   		movl	%ecx, -68(%rbp)
 1832 1095 4C8945B0 		movq	%r8, -80(%rbp)
 1833 1099 8845C4   		movb	%al, -60(%rbp)
 1834              		.loc 3 441 0
 1835 109c 64488B04 		movq	%fs:40, %rax
 1835      25280000 
 1835      00
 1836 10a5 488945F8 		movq	%rax, -8(%rbp)
 1837 10a9 31C0     		xorl	%eax, %eax
 442:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1838              		.loc 3 442 0
 1839 10ab C745D400 		movl	$0, -44(%rbp)
 1839      000000
 443:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 444:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 445:libusbwrap.c  **** 	int *completed;
 446:libusbwrap.c  **** 	USBStatus uStatus;
 447:libusbwrap.c  **** 	int iStatus;
 448:libusbwrap.c  **** 	CHECK_STATUS(
 1840              		.loc 3 448 0
 1841 10b2 817DC000 		cmpl	$65536, -64(%rbp)
 1841      000100
 1842 10b9 761F     		jbe	.L128
 1843              		.loc 3 448 0 is_stmt 0 discriminator 1
 1844 10bb 488B45B0 		movq	-80(%rbp), %rax
 1845 10bf 488D3500 		leaq	.LC24(%rip), %rsi
 1845      000000
 1846 10c6 4889C7   		movq	%rax, %rdi
 1847 10c9 E8000000 		call	errPrefix@PLT
 1847      00
 1848 10ce C745D411 		movl	$17, -44(%rbp)
 1848      000000
 1849 10d5 E9000100 		jmp	.L129
 1849      00
 1850              	.L128:
 449:libusbwrap.c  **** 		length > 0x10000, USB_ASYNC_SIZE, cleanup,
 450:libusbwrap.c  **** 		"usbBulkWriteAsyncSubmit(): Transfer length exceeds 0x10000");
 451:libusbwrap.c  **** 	uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1851              		.loc 3 451 0 is_stmt 1
 1852 10da 488B45C8 		movq	-56(%rbp), %rax
 1853 10de 488D5008 		leaq	8(%rax), %rdx
 1854 10e2 488D45E0 		leaq	-32(%rbp), %rax
 1855 10e6 4889C6   		movq	%rax, %rsi
 1856 10e9 4889D7   		movq	%rdx, %rdi
 1857 10ec E8000000 		call	queuePut@PLT
 1857      00
 1858 10f1 8945D8   		movl	%eax, -40(%rbp)
 452:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup, "usbBulkWriteAsyncSubmit(): Work queue insertion error");
 1859              		.loc 3 452 0
 1860 10f4 837DD800 		cmpl	$0, -40(%rbp)
 1861 10f8 741E     		je	.L130
 1862              		.loc 3 452 0 is_stmt 0 discriminator 1
 1863 10fa 488B45B0 		movq	-80(%rbp), %rax
 1864 10fe 488D3500 		leaq	.LC25(%rip), %rsi
 1864      000000
 1865 1105 4889C7   		movq	%rax, %rdi
 1866 1108 E8000000 		call	errPrefix@PLT
 1866      00
 1867 110d 8B45D8   		movl	-40(%rbp), %eax
 1868 1110 8945D4   		movl	%eax, -44(%rbp)
 1869 1113 E9C20000 		jmp	.L129
 1869      00
 1870              	.L130:
 453:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1871              		.loc 3 453 0 is_stmt 1
 1872 1118 488B45E0 		movq	-32(%rbp), %rax
 1873 111c 488B00   		movq	(%rax), %rax
 1874 111f 488945E8 		movq	%rax, -24(%rbp)
 454:libusbwrap.c  **** 	completed = &wrapper->completed;
 1875              		.loc 3 454 0
 1876 1123 488B45E0 		movq	-32(%rbp), %rax
 1877 1127 4883C008 		addq	$8, %rax
 1878 112b 488945F0 		movq	%rax, -16(%rbp)
 455:libusbwrap.c  **** 	*completed = 0;
 1879              		.loc 3 455 0
 1880 112f 488B45F0 		movq	-16(%rbp), %rax
 1881 1133 C7000000 		movl	$0, (%rax)
 1881      0000
 456:libusbwrap.c  **** 	wrapper->flags.isRead = 0;
 1882              		.loc 3 456 0
 1883 1139 488B45E0 		movq	-32(%rbp), %rax
 1884 113d 0FB6500C 		movzbl	12(%rax), %edx
 1885 1141 83E2FE   		andl	$-2, %edx
 1886 1144 88500C   		movb	%dl, 12(%rax)
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1887              		.loc 3 457 0
 1888 1147 448B45C0 		movl	-64(%rbp), %r8d
 458:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_OUT | endpoint, wrapper->buffer, (int)length,
 1889              		.loc 3 458 0
 1890 114b 488B45E0 		movq	-32(%rbp), %rax
 1891 114f 488D7810 		leaq	16(%rax), %rdi
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1892              		.loc 3 457 0
 1893 1153 0FB655C4 		movzbl	-60(%rbp), %edx
 1894              		.loc 3 458 0
 1895 1157 488B45C8 		movq	-56(%rbp), %rax
 1896 115b 488B30   		movq	(%rax), %rsi
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1897              		.loc 3 457 0
 1898 115e 488B45E8 		movq	-24(%rbp), %rax
 1899 1162 8B4DBC   		movl	-68(%rbp), %ecx
 1900 1165 51       		pushq	%rcx
 1901 1166 FF75F0   		pushq	-16(%rbp)
 1902 1169 4C8D0D2E 		leaq	bulk_transfer_cb(%rip), %r9
 1902      FDFFFF
 1903 1170 4889F9   		movq	%rdi, %rcx
 1904 1173 4889C7   		movq	%rax, %rdi
 1905 1176 E897EEFF 		call	libusb_fill_bulk_transfer
 1905      FF
 1906 117b 4883C410 		addq	$16, %rsp
 459:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 460:libusbwrap.c  **** 	);
 461:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 1907              		.loc 3 461 0
 1908 117f 488B45E8 		movq	-24(%rbp), %rax
 1909 1183 C6400A02 		movb	$2, 10(%rax)
 462:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 1910              		.loc 3 462 0
 1911 1187 488B45E8 		movq	-24(%rbp), %rax
 1912 118b 4889C7   		movq	%rax, %rdi
 1913 118e E8000000 		call	libusb_submit_transfer@PLT
 1913      00
 1914 1193 8945DC   		movl	%eax, -36(%rbp)
 463:libusbwrap.c  **** 	CHECK_STATUS(
 1915              		.loc 3 463 0
 1916 1196 837DDC00 		cmpl	$0, -36(%rbp)
 1917 119a 742E     		je	.L131
 1918              		.loc 3 463 0 is_stmt 0 discriminator 1
 1919 119c 8B45DC   		movl	-36(%rbp), %eax
 1920 119f 89C7     		movl	%eax, %edi
 1921 11a1 E8000000 		call	libusb_error_name@PLT
 1921      00
 1922 11a6 4889C2   		movq	%rax, %rdx
 1923 11a9 488B45B0 		movq	-80(%rbp), %rax
 1924 11ad 488D3500 		leaq	.LC26(%rip), %rsi
 1924      000000
 1925 11b4 4889C7   		movq	%rax, %rdi
 1926 11b7 B8000000 		movl	$0, %eax
 1926      00
 1927 11bc E8000000 		call	errRender@PLT
 1927      00
 1928 11c1 C745D40E 		movl	$14, -44(%rbp)
 1928      000000
 1929 11c8 EB10     		jmp	.L129
 1930              	.L131:
 464:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 465:libusbwrap.c  **** 		"usbBulkWriteAsyncSubmit(): Submission error: %s", libusb_error_name(iStatus));
 466:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 1931              		.loc 3 466 0 is_stmt 1
 1932 11ca 488B45C8 		movq	-56(%rbp), %rax
 1933 11ce 4883C008 		addq	$8, %rax
 1934 11d2 4889C7   		movq	%rax, %rdi
 1935 11d5 E8000000 		call	queueCommitPut@PLT
 1935      00
 1936              	.L129:
 467:libusbwrap.c  **** cleanup:
 468:libusbwrap.c  **** 	return retVal;
 1937              		.loc 3 468 0
 1938 11da 8B45D4   		movl	-44(%rbp), %eax
 469:libusbwrap.c  **** }
 1939              		.loc 3 469 0
 1940 11dd 488B4DF8 		movq	-8(%rbp), %rcx
 1941 11e1 6448330C 		xorq	%fs:40, %rcx
 1941      25280000 
 1941      00
 1942 11ea 7405     		je	.L133
 1943 11ec E8000000 		call	__stack_chk_fail@PLT
 1943      00
 1944              	.L133:
 1945 11f1 C9       		leave
 1946              		.cfi_def_cfa 7, 8
 1947 11f2 C3       		ret
 1948              		.cfi_endproc
 1949              	.LFE39:
 1951              		.section	.rodata
 1952              		.align 8
 1953              	.LC27:
 1954 04e8 75736242 		.string	"usbBulkReadAsync(): Transfer length exceeds 0x10000"
 1954      756C6B52 
 1954      65616441 
 1954      73796E63 
 1954      28293A20 
 1955 051c 00000000 		.align 8
 1956              	.LC28:
 1957 0520 75736242 		.string	"usbBulkReadAsync(): Work queue insertion error"
 1957      756C6B52 
 1957      65616441 
 1957      73796E63 
 1957      28293A20 
 1958 054f 00       		.align 8
 1959              	.LC29:
 1960 0550 75736242 		.string	"usbBulkReadAsync(): Submission error: %s"
 1960      756C6B52 
 1960      65616441 
 1960      73796E63 
 1960      28293A20 
 1961              		.text
 1962              		.globl	usbBulkReadAsync
 1964              	usbBulkReadAsync:
 1965              	.LFB40:
 470:libusbwrap.c  **** 
 471:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkReadAsync(
 472:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint8 *buffer, uint32 length, uint32 timeout, const char **
 473:libusbwrap.c  **** {
 1966              		.loc 3 473 0
 1967              		.cfi_startproc
 1968 11f3 55       		pushq	%rbp
 1969              		.cfi_def_cfa_offset 16
 1970              		.cfi_offset 6, -16
 1971 11f4 4889E5   		movq	%rsp, %rbp
 1972              		.cfi_def_cfa_register 6
 1973 11f7 4883EC60 		subq	$96, %rsp
 1974 11fb 48897DC8 		movq	%rdi, -56(%rbp)
 1975 11ff 89F0     		movl	%esi, %eax
 1976 1201 488955B8 		movq	%rdx, -72(%rbp)
 1977 1205 894DC0   		movl	%ecx, -64(%rbp)
 1978 1208 448945B4 		movl	%r8d, -76(%rbp)
 1979 120c 4C894DA8 		movq	%r9, -88(%rbp)
 1980 1210 8845C4   		movb	%al, -60(%rbp)
 1981              		.loc 3 473 0
 1982 1213 64488B04 		movq	%fs:40, %rax
 1982      25280000 
 1982      00
 1983 121c 488945F8 		movq	%rax, -8(%rbp)
 1984 1220 31C0     		xorl	%eax, %eax
 474:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1985              		.loc 3 474 0
 1986 1222 C745D400 		movl	$0, -44(%rbp)
 1986      000000
 475:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 476:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 477:libusbwrap.c  **** 	int *completed;
 478:libusbwrap.c  **** 	USBStatus uStatus;
 479:libusbwrap.c  **** 	int iStatus;
 480:libusbwrap.c  **** 	CHECK_STATUS(
 1987              		.loc 3 480 0
 1988 1229 817DC000 		cmpl	$65536, -64(%rbp)
 1988      000100
 1989 1230 761F     		jbe	.L135
 1990              		.loc 3 480 0 is_stmt 0 discriminator 1
 1991 1232 488B45A8 		movq	-88(%rbp), %rax
 1992 1236 488D3500 		leaq	.LC27(%rip), %rsi
 1992      000000
 1993 123d 4889C7   		movq	%rax, %rdi
 1994 1240 E8000000 		call	errPrefix@PLT
 1994      00
 1995 1245 C745D411 		movl	$17, -44(%rbp)
 1995      000000
 1996 124c E9230100 		jmp	.L136
 1996      00
 1997              	.L135:
 481:libusbwrap.c  **** 		length > 0x10000, USB_ASYNC_SIZE, cleanup,
 482:libusbwrap.c  **** 		"usbBulkReadAsync(): Transfer length exceeds 0x10000");
 483:libusbwrap.c  **** 	uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1998              		.loc 3 483 0 is_stmt 1
 1999 1251 488B45C8 		movq	-56(%rbp), %rax
 2000 1255 488D5008 		leaq	8(%rax), %rdx
 2001 1259 488D45E0 		leaq	-32(%rbp), %rax
 2002 125d 4889C6   		movq	%rax, %rsi
 2003 1260 4889D7   		movq	%rdx, %rdi
 2004 1263 E8000000 		call	queuePut@PLT
 2004      00
 2005 1268 8945D8   		movl	%eax, -40(%rbp)
 484:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup, "usbBulkReadAsync(): Work queue insertion error");
 2006              		.loc 3 484 0
 2007 126b 837DD800 		cmpl	$0, -40(%rbp)
 2008 126f 741E     		je	.L137
 2009              		.loc 3 484 0 is_stmt 0 discriminator 1
 2010 1271 488B45A8 		movq	-88(%rbp), %rax
 2011 1275 488D3500 		leaq	.LC28(%rip), %rsi
 2011      000000
 2012 127c 4889C7   		movq	%rax, %rdi
 2013 127f E8000000 		call	errPrefix@PLT
 2013      00
 2014 1284 8B45D8   		movl	-40(%rbp), %eax
 2015 1287 8945D4   		movl	%eax, -44(%rbp)
 2016 128a E9E50000 		jmp	.L136
 2016      00
 2017              	.L137:
 485:libusbwrap.c  **** 	transfer = wrapper->transfer;
 2018              		.loc 3 485 0 is_stmt 1
 2019 128f 488B45E0 		movq	-32(%rbp), %rax
 2020 1293 488B00   		movq	(%rax), %rax
 2021 1296 488945E8 		movq	%rax, -24(%rbp)
 486:libusbwrap.c  **** 	completed = &wrapper->completed;
 2022              		.loc 3 486 0
 2023 129a 488B45E0 		movq	-32(%rbp), %rax
 2024 129e 4883C008 		addq	$8, %rax
 2025 12a2 488945F0 		movq	%rax, -16(%rbp)
 487:libusbwrap.c  **** 	*completed = 0;
 2026              		.loc 3 487 0
 2027 12a6 488B45F0 		movq	-16(%rbp), %rax
 2028 12aa C7000000 		movl	$0, (%rax)
 2028      0000
 488:libusbwrap.c  **** 	wrapper->flags.isRead = 1;
 2029              		.loc 3 488 0
 2030 12b0 488B45E0 		movq	-32(%rbp), %rax
 2031 12b4 0FB6500C 		movzbl	12(%rax), %edx
 2032 12b8 83CA01   		orl	$1, %edx
 2033 12bb 88500C   		movb	%dl, 12(%rax)
 489:libusbwrap.c  **** 	if ( buffer ) {
 2034              		.loc 3 489 0
 2035 12be 48837DB8 		cmpq	$0, -72(%rbp)
 2035      00
 2036 12c3 7411     		je	.L138
 490:libusbwrap.c  **** 		wrapper->bufPtr = buffer;
 2037              		.loc 3 490 0
 2038 12c5 488B45E0 		movq	-32(%rbp), %rax
 2039 12c9 488B55B8 		movq	-72(%rbp), %rdx
 2040 12cd 48899010 		movq	%rdx, 65552(%rax)
 2040      000100
 2041 12d4 EB0C     		jmp	.L139
 2042              	.L138:
 491:libusbwrap.c  **** 	} else {
 492:libusbwrap.c  **** 		buffer = wrapper->buffer;
 2043              		.loc 3 492 0
 2044 12d6 488B45E0 		movq	-32(%rbp), %rax
 2045 12da 4883C010 		addq	$16, %rax
 2046 12de 488945B8 		movq	%rax, -72(%rbp)
 2047              	.L139:
 493:libusbwrap.c  **** 	}
 494:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 2048              		.loc 3 494 0
 2049 12e2 448B45C0 		movl	-64(%rbp), %r8d
 2050 12e6 0FB645C4 		movzbl	-60(%rbp), %eax
 2051 12ea 83C880   		orl	$-128, %eax
 2052 12ed 0FB6D0   		movzbl	%al, %edx
 495:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_IN | endpoint, buffer, (int)length,
 2053              		.loc 3 495 0
 2054 12f0 488B45C8 		movq	-56(%rbp), %rax
 2055 12f4 488B30   		movq	(%rax), %rsi
 494:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_IN | endpoint, buffer, (int)length,
 2056              		.loc 3 494 0
 2057 12f7 488B4DB8 		movq	-72(%rbp), %rcx
 2058 12fb 488B45E8 		movq	-24(%rbp), %rax
 2059 12ff 8B7DB4   		movl	-76(%rbp), %edi
 2060 1302 57       		pushq	%rdi
 2061 1303 FF75F0   		pushq	-16(%rbp)
 2062 1306 4C8D0D91 		leaq	bulk_transfer_cb(%rip), %r9
 2062      FBFFFF
 2063 130d 4889C7   		movq	%rax, %rdi
 2064 1310 E8FDECFF 		call	libusb_fill_bulk_transfer
 2064      FF
 2065 1315 4883C410 		addq	$16, %rsp
 496:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 497:libusbwrap.c  **** 	);
 498:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 2066              		.loc 3 498 0
 2067 1319 488B45E8 		movq	-24(%rbp), %rax
 2068 131d C6400A02 		movb	$2, 10(%rax)
 499:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 2069              		.loc 3 499 0
 2070 1321 488B45E8 		movq	-24(%rbp), %rax
 2071 1325 4889C7   		movq	%rax, %rdi
 2072 1328 E8000000 		call	libusb_submit_transfer@PLT
 2072      00
 2073 132d 8945DC   		movl	%eax, -36(%rbp)
 500:libusbwrap.c  **** 	CHECK_STATUS(
 2074              		.loc 3 500 0
 2075 1330 837DDC00 		cmpl	$0, -36(%rbp)
 2076 1334 742E     		je	.L140
 2077              		.loc 3 500 0 is_stmt 0 discriminator 1
 2078 1336 8B45DC   		movl	-36(%rbp), %eax
 2079 1339 89C7     		movl	%eax, %edi
 2080 133b E8000000 		call	libusb_error_name@PLT
 2080      00
 2081 1340 4889C2   		movq	%rax, %rdx
 2082 1343 488B45A8 		movq	-88(%rbp), %rax
 2083 1347 488D3500 		leaq	.LC29(%rip), %rsi
 2083      000000
 2084 134e 4889C7   		movq	%rax, %rdi
 2085 1351 B8000000 		movl	$0, %eax
 2085      00
 2086 1356 E8000000 		call	errRender@PLT
 2086      00
 2087 135b C745D40E 		movl	$14, -44(%rbp)
 2087      000000
 2088 1362 EB10     		jmp	.L136
 2089              	.L140:
 501:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 502:libusbwrap.c  **** 		"usbBulkReadAsync(): Submission error: %s", libusb_error_name(iStatus));
 503:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 2090              		.loc 3 503 0 is_stmt 1
 2091 1364 488B45C8 		movq	-56(%rbp), %rax
 2092 1368 4883C008 		addq	$8, %rax
 2093 136c 4889C7   		movq	%rax, %rdi
 2094 136f E8000000 		call	queueCommitPut@PLT
 2094      00
 2095              	.L136:
 504:libusbwrap.c  **** cleanup:
 505:libusbwrap.c  **** 	return retVal;
 2096              		.loc 3 505 0
 2097 1374 8B45D4   		movl	-44(%rbp), %eax
 506:libusbwrap.c  **** }
 2098              		.loc 3 506 0
 2099 1377 488B4DF8 		movq	-8(%rbp), %rcx
 2100 137b 6448330C 		xorq	%fs:40, %rcx
 2100      25280000 
 2100      00
 2101 1384 7405     		je	.L142
 2102 1386 E8000000 		call	__stack_chk_fail@PLT
 2102      00
 2103              	.L142:
 2104 138b C9       		leave
 2105              		.cfi_def_cfa 7, 8
 2106 138c C3       		ret
 2107              		.cfi_endproc
 2108              	.LFE40:
 2110              		.section	.rodata
 2111 0579 00000000 		.align 8
 2111      000000
 2112              	.LC30:
 2113 0580 75736242 		.string	"usbBulkAwaitCompletion(): Work queue fetch error"
 2113      756C6B41 
 2113      77616974 
 2113      436F6D70 
 2113      6C657469 
 2114 05b1 00000000 		.align 8
 2114      000000
 2115              	.LC31:
 2116 05b8 75736242 		.string	"usbBulkAwaitCompletion(): Event error: %s"
 2116      756C6B41 
 2116      77616974 
 2116      436F6D70 
 2116      6C657469 
 2117 05e2 00000000 		.align 8
 2117      0000
 2118              	.LC32:
 2119 05e8 75736242 		.string	"usbBulkAwaitCompletion(): Timeout"
 2119      756C6B41 
 2119      77616974 
 2119      436F6D70 
 2119      6C657469 
 2120 060a 00000000 		.align 8
 2120      0000
 2121              	.LC33:
 2122 0610 75736242 		.string	"usbBulkAwaitCompletion(): Transfer error: %s"
 2122      756C6B41 
 2122      77616974 
 2122      436F6D70 
 2122      6C657469 
 2123              		.text
 2124              		.globl	usbBulkAwaitCompletion
 2126              	usbBulkAwaitCompletion:
 2127              	.LFB41:
 507:libusbwrap.c  **** 
 508:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkAwaitCompletion(
 509:libusbwrap.c  **** 	struct USBDevice *dev, struct CompletionReport *report, const char **error)
 510:libusbwrap.c  **** {
 2128              		.loc 3 510 0
 2129              		.cfi_startproc
 2130 138d 55       		pushq	%rbp
 2131              		.cfi_def_cfa_offset 16
 2132              		.cfi_offset 6, -16
 2133 138e 4889E5   		movq	%rsp, %rbp
 2134              		.cfi_def_cfa_register 6
 2135 1391 4883EC70 		subq	$112, %rsp
 2136 1395 48897DA8 		movq	%rdi, -88(%rbp)
 2137 1399 488975A0 		movq	%rsi, -96(%rbp)
 2138 139d 48895598 		movq	%rdx, -104(%rbp)
 2139              		.loc 3 510 0
 2140 13a1 64488B04 		movq	%fs:40, %rax
 2140      25280000 
 2140      00
 2141 13aa 488945F8 		movq	%rax, -8(%rbp)
 2142 13ae 31C0     		xorl	%eax, %eax
 511:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 2143              		.loc 3 511 0
 2144 13b0 C745BC00 		movl	$0, -68(%rbp)
 2144      000000
 512:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 513:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 514:libusbwrap.c  **** 	int *completed;
 515:libusbwrap.c  **** 	int iStatus;
 516:libusbwrap.c  **** 	struct timeval timeout = {UINT_MAX/1000, 1000*(UINT_MAX%1000)};
 2145              		.loc 3 516 0
 2146 13b7 48C745E0 		movq	$4294967, -32(%rbp)
 2146      37894100 
 2147 13bf 48C745E8 		movq	$295000, -24(%rbp)
 2147      58800400 
 517:libusbwrap.c  **** 	                         // This horrible thing should boil down to a call to poll() with
 518:libusbwrap.c  **** 	                         // timeout -1ms, which will be interpreted as "no timeout" on all
 519:libusbwrap.c  **** 	                         // platforms.
 520:libusbwrap.c  **** 	USBStatus uStatus = queueTake(&dev->queue, (Item*)&wrapper);
 2148              		.loc 3 520 0
 2149 13c7 488B45A8 		movq	-88(%rbp), %rax
 2150 13cb 488D5008 		leaq	8(%rax), %rdx
 2151 13cf 488D45C8 		leaq	-56(%rbp), %rax
 2152 13d3 4889C6   		movq	%rax, %rsi
 2153 13d6 4889D7   		movq	%rdx, %rdi
 2154 13d9 E8000000 		call	queueTake@PLT
 2154      00
 2155 13de 8945C4   		movl	%eax, -60(%rbp)
 521:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, exit, "usbBulkAwaitCompletion(): Work queue fetch error");
 2156              		.loc 3 521 0
 2157 13e1 837DC400 		cmpl	$0, -60(%rbp)
 2158 13e5 741E     		je	.L144
 2159              		.loc 3 521 0 is_stmt 0 discriminator 1
 2160 13e7 488B4598 		movq	-104(%rbp), %rax
 2161 13eb 488D3500 		leaq	.LC30(%rip), %rsi
 2161      000000
 2162 13f2 4889C7   		movq	%rax, %rdi
 2163 13f5 E8000000 		call	errPrefix@PLT
 2163      00
 2164 13fa 8B45C4   		movl	-60(%rbp), %eax
 2165 13fd 8945BC   		movl	%eax, -68(%rbp)
 2166 1400 E9E20100 		jmp	.L145
 2166      00
 2167              	.L144:
 522:libusbwrap.c  **** 	transfer = wrapper->transfer;
 2168              		.loc 3 522 0 is_stmt 1
 2169 1405 488B45C8 		movq	-56(%rbp), %rax
 2170 1409 488B00   		movq	(%rax), %rax
 2171 140c 488945D0 		movq	%rax, -48(%rbp)
 523:libusbwrap.c  **** 	completed = &wrapper->completed;
 2172              		.loc 3 523 0
 2173 1410 488B45C8 		movq	-56(%rbp), %rax
 2174 1414 4883C008 		addq	$8, %rax
 2175 1418 488945D8 		movq	%rax, -40(%rbp)
 524:libusbwrap.c  **** 	wrapper->bufPtr = NULL;
 2176              		.loc 3 524 0
 2177 141c 488B45C8 		movq	-56(%rbp), %rax
 2178 1420 48C78010 		movq	$0, 65552(%rax)
 2178      00010000 
 2178      000000
 525:libusbwrap.c  **** 	while ( *completed == 0 ) {
 2179              		.loc 3 525 0
 2180 142b E9990000 		jmp	.L146
 2180      00
 2181              	.L152:
 526:libusbwrap.c  **** 		iStatus = libusb_handle_events_timeout_completed(m_ctx, &timeout, completed);
 2182              		.loc 3 526 0
 2183 1430 488B0500 		movq	m_ctx(%rip), %rax
 2183      000000
 2184 1437 488B55D8 		movq	-40(%rbp), %rdx
 2185 143b 488D4DE0 		leaq	-32(%rbp), %rcx
 2186 143f 4889CE   		movq	%rcx, %rsi
 2187 1442 4889C7   		movq	%rax, %rdi
 2188 1445 E8000000 		call	libusb_handle_events_timeout_completed@PLT
 2188      00
 2189 144a 8945C0   		movl	%eax, -64(%rbp)
 527:libusbwrap.c  **** 		if ( iStatus < 0 ) {
 2190              		.loc 3 527 0
 2191 144d 837DC000 		cmpl	$0, -64(%rbp)
 2192 1451 7976     		jns	.L146
 528:libusbwrap.c  **** 			if ( iStatus == LIBUSB_ERROR_INTERRUPTED ) {
 2193              		.loc 3 528 0
 2194 1453 837DC0F6 		cmpl	$-10, -64(%rbp)
 2195 1457 7502     		jne	.L147
 529:libusbwrap.c  **** 				continue;
 2196              		.loc 3 529 0
 2197 1459 EB6E     		jmp	.L146
 2198              	.L147:
 530:libusbwrap.c  **** 			}
 531:libusbwrap.c  **** 			if ( libusb_cancel_transfer(transfer) == LIBUSB_SUCCESS ) {
 2199              		.loc 3 531 0
 2200 145b 488B45D0 		movq	-48(%rbp), %rax
 2201 145f 4889C7   		movq	%rax, %rdi
 2202 1462 E8000000 		call	libusb_cancel_transfer@PLT
 2202      00
 2203 1467 85C0     		testl	%eax, %eax
 2204 1469 752D     		jne	.L165
 532:libusbwrap.c  **** 				while ( *completed == 0 ) {
 2205              		.loc 3 532 0
 2206 146b EB1E     		jmp	.L149
 2207              	.L150:
 533:libusbwrap.c  **** 					if ( libusb_handle_events_timeout_completed(m_ctx, &timeout, completed) < 0 ) {
 2208              		.loc 3 533 0
 2209 146d 488B0500 		movq	m_ctx(%rip), %rax
 2209      000000
 2210 1474 488B55D8 		movq	-40(%rbp), %rdx
 2211 1478 488D4DE0 		leaq	-32(%rbp), %rcx
 2212 147c 4889CE   		movq	%rcx, %rsi
 2213 147f 4889C7   		movq	%rax, %rdi
 2214 1482 E8000000 		call	libusb_handle_events_timeout_completed@PLT
 2214      00
 2215 1487 85C0     		testl	%eax, %eax
 2216 1489 780C     		js	.L166
 2217              	.L149:
 532:libusbwrap.c  **** 				while ( *completed == 0 ) {
 2218              		.loc 3 532 0
 2219 148b 488B45D8 		movq	-40(%rbp), %rax
 2220 148f 8B00     		movl	(%rax), %eax
 2221 1491 85C0     		testl	%eax, %eax
 2222 1493 74D8     		je	.L150
 2223 1495 EB01     		jmp	.L165
 2224              	.L166:
 534:libusbwrap.c  **** 						break;
 2225              		.loc 3 534 0
 2226 1497 90       		nop
 2227              	.L165:
 535:libusbwrap.c  **** 					}
 536:libusbwrap.c  **** 				}
 537:libusbwrap.c  **** 			}
 538:libusbwrap.c  **** 			CHECK_STATUS(
 2228              		.loc 3 538 0 discriminator 1
 2229 1498 8B45C0   		movl	-64(%rbp), %eax
 2230 149b 89C7     		movl	%eax, %edi
 2231 149d E8000000 		call	libusb_error_name@PLT
 2231      00
 2232 14a2 4889C2   		movq	%rax, %rdx
 2233 14a5 488B4598 		movq	-104(%rbp), %rax
 2234 14a9 488D3500 		leaq	.LC31(%rip), %rsi
 2234      000000
 2235 14b0 4889C7   		movq	%rax, %rdi
 2236 14b3 B8000000 		movl	$0, %eax
 2236      00
 2237 14b8 E8000000 		call	errRender@PLT
 2237      00
 2238 14bd C745BC0F 		movl	$15, -68(%rbp)
 2238      000000
 2239 14c4 E90E0100 		jmp	.L151
 2239      00
 2240              	.L146:
 525:libusbwrap.c  **** 		iStatus = libusb_handle_events_timeout_completed(m_ctx, &timeout, completed);
 2241              		.loc 3 525 0
 2242 14c9 488B45D8 		movq	-40(%rbp), %rax
 2243 14cd 8B00     		movl	(%rax), %eax
 2244 14cf 85C0     		testl	%eax, %eax
 2245 14d1 0F8459FF 		je	.L152
 2245      FFFF
 539:libusbwrap.c  **** 				true, USB_ASYNC_EVENT, commit,
 540:libusbwrap.c  **** 				"usbBulkAwaitCompletion(): Event error: %s", libusb_error_name(iStatus));
 541:libusbwrap.c  **** 		}
 542:libusbwrap.c  **** 	}
 543:libusbwrap.c  **** 
 544:libusbwrap.c  **** 	report->buffer = transfer->buffer;
 2246              		.loc 3 544 0
 2247 14d7 488B45D0 		movq	-48(%rbp), %rax
 2248 14db 488B5030 		movq	48(%rax), %rdx
 2249 14df 488B45A0 		movq	-96(%rbp), %rax
 2250 14e3 488910   		movq	%rdx, (%rax)
 545:libusbwrap.c  **** 	report->requestLength = (uint32)transfer->length;
 2251              		.loc 3 545 0
 2252 14e6 488B45D0 		movq	-48(%rbp), %rax
 2253 14ea 8B4014   		movl	20(%rax), %eax
 2254 14ed 89C2     		movl	%eax, %edx
 2255 14ef 488B45A0 		movq	-96(%rbp), %rax
 2256 14f3 895008   		movl	%edx, 8(%rax)
 546:libusbwrap.c  **** 	report->actualLength = (uint32)transfer->actual_length;
 2257              		.loc 3 546 0
 2258 14f6 488B45D0 		movq	-48(%rbp), %rax
 2259 14fa 8B4018   		movl	24(%rax), %eax
 2260 14fd 89C2     		movl	%eax, %edx
 2261 14ff 488B45A0 		movq	-96(%rbp), %rax
 2262 1503 89500C   		movl	%edx, 12(%rax)
 547:libusbwrap.c  **** 	report->flags = wrapper->flags;
 2263              		.loc 3 547 0
 2264 1506 488B55C8 		movq	-56(%rbp), %rdx
 2265 150a 488B45A0 		movq	-96(%rbp), %rax
 2266 150e 8B520C   		movl	12(%rdx), %edx
 2267 1511 895010   		movl	%edx, 16(%rax)
 548:libusbwrap.c  **** 
 549:libusbwrap.c  **** 	switch ( transfer->status ) {
 2268              		.loc 3 549 0
 2269 1514 488B45D0 		movq	-48(%rbp), %rax
 2270 1518 8B4010   		movl	16(%rax), %eax
 2271 151b 83F806   		cmpl	$6, %eax
 2272 151e 7759     		ja	.L153
 2273 1520 89C0     		movl	%eax, %eax
 2274 1522 488D1485 		leaq	0(,%rax,4), %rdx
 2274      00000000 
 2275 152a 488D0500 		leaq	.L155(%rip), %rax
 2275      000000
 2276 1531 8B0402   		movl	(%rdx,%rax), %eax
 2277 1534 4863D0   		movslq	%eax, %rdx
 2278 1537 488D0500 		leaq	.L155(%rip), %rax
 2278      000000
 2279 153e 4801D0   		addq	%rdx, %rax
 2280 1541 FFE0     		jmp	*%rax
 2281              		.section	.rodata
 2282 063d 000000   		.align 4
 2283              		.align 4
 2284              	.L155:
 2285 0640 00000000 		.long	.L154-.L155
 2286 0644 00000000 		.long	.L156-.L155
 2287 0648 00000000 		.long	.L157-.L155
 2288 064c 00000000 		.long	.L156-.L155
 2289 0650 00000000 		.long	.L158-.L155
 2290 0654 00000000 		.long	.L159-.L155
 2291 0658 00000000 		.long	.L160-.L155
 2292              		.text
 2293              	.L154:
 550:libusbwrap.c  **** 	case LIBUSB_TRANSFER_COMPLETED:
 551:libusbwrap.c  **** 		iStatus = 0;
 2294              		.loc 3 551 0
 2295 1543 C745C000 		movl	$0, -64(%rbp)
 2295      000000
 552:libusbwrap.c  **** 		break;
 2296              		.loc 3 552 0
 2297 154a EB34     		jmp	.L161
 2298              	.L157:
 553:libusbwrap.c  **** 	case LIBUSB_TRANSFER_TIMED_OUT:
 554:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_TIMEOUT;
 2299              		.loc 3 554 0
 2300 154c C745C0F9 		movl	$-7, -64(%rbp)
 2300      FFFFFF
 555:libusbwrap.c  **** 		break;
 2301              		.loc 3 555 0
 2302 1553 EB2B     		jmp	.L161
 2303              	.L158:
 556:libusbwrap.c  **** 	case LIBUSB_TRANSFER_STALL:
 557:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_PIPE;
 2304              		.loc 3 557 0
 2305 1555 C745C0F7 		movl	$-9, -64(%rbp)
 2305      FFFFFF
 558:libusbwrap.c  **** 		break;
 2306              		.loc 3 558 0
 2307 155c EB22     		jmp	.L161
 2308              	.L160:
 559:libusbwrap.c  **** 	case LIBUSB_TRANSFER_OVERFLOW:
 560:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_OVERFLOW;
 2309              		.loc 3 560 0
 2310 155e C745C0F8 		movl	$-8, -64(%rbp)
 2310      FFFFFF
 561:libusbwrap.c  **** 		break;
 2311              		.loc 3 561 0
 2312 1565 EB19     		jmp	.L161
 2313              	.L159:
 562:libusbwrap.c  **** 	case LIBUSB_TRANSFER_NO_DEVICE:
 563:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_NO_DEVICE;
 2314              		.loc 3 563 0
 2315 1567 C745C0FC 		movl	$-4, -64(%rbp)
 2315      FFFFFF
 564:libusbwrap.c  **** 		break;
 2316              		.loc 3 564 0
 2317 156e EB10     		jmp	.L161
 2318              	.L156:
 565:libusbwrap.c  **** 	case LIBUSB_TRANSFER_ERROR:
 566:libusbwrap.c  **** 	case LIBUSB_TRANSFER_CANCELLED:
 567:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_IO;
 2319              		.loc 3 567 0
 2320 1570 C745C0FF 		movl	$-1, -64(%rbp)
 2320      FFFFFF
 568:libusbwrap.c  **** 		break;
 2321              		.loc 3 568 0
 2322 1577 EB07     		jmp	.L161
 2323              	.L153:
 569:libusbwrap.c  **** 	default:
 570:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_OTHER;
 2324              		.loc 3 570 0
 2325 1579 C745C09D 		movl	$-99, -64(%rbp)
 2325      FFFFFF
 2326              	.L161:
 571:libusbwrap.c  **** 	}
 572:libusbwrap.c  **** 	CHECK_STATUS(
 2327              		.loc 3 572 0
 2328 1580 837DC0F9 		cmpl	$-7, -64(%rbp)
 2329 1584 751C     		jne	.L162
 2330              		.loc 3 572 0 is_stmt 0 discriminator 1
 2331 1586 488B4598 		movq	-104(%rbp), %rax
 2332 158a 488D3500 		leaq	.LC32(%rip), %rsi
 2332      000000
 2333 1591 4889C7   		movq	%rax, %rdi
 2334 1594 E8000000 		call	errPrefix@PLT
 2334      00
 2335 1599 C745BC12 		movl	$18, -68(%rbp)
 2335      000000
 2336 15a0 EB35     		jmp	.L151
 2337              	.L162:
 573:libusbwrap.c  **** 		iStatus == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, commit,
 574:libusbwrap.c  **** 		"usbBulkAwaitCompletion(): Timeout");
 575:libusbwrap.c  **** 	CHECK_STATUS(
 2338              		.loc 3 575 0 is_stmt 1
 2339 15a2 837DC000 		cmpl	$0, -64(%rbp)
 2340 15a6 742E     		je	.L167
 2341              		.loc 3 575 0 is_stmt 0 discriminator 1
 2342 15a8 8B45C0   		movl	-64(%rbp), %eax
 2343 15ab 89C7     		movl	%eax, %edi
 2344 15ad E8000000 		call	libusb_error_name@PLT
 2344      00
 2345 15b2 4889C2   		movq	%rax, %rdx
 2346 15b5 488B4598 		movq	-104(%rbp), %rax
 2347 15b9 488D3500 		leaq	.LC33(%rip), %rsi
 2347      000000
 2348 15c0 4889C7   		movq	%rax, %rdi
 2349 15c3 B8000000 		movl	$0, %eax
 2349      00
 2350 15c8 E8000000 		call	errRender@PLT
 2350      00
 2351 15cd C745BC10 		movl	$16, -68(%rbp)
 2351      000000
 2352 15d4 EB01     		jmp	.L151
 2353              	.L167:
 576:libusbwrap.c  **** 		iStatus, USB_ASYNC_TRANSFER, commit,
 577:libusbwrap.c  **** 		"usbBulkAwaitCompletion(): Transfer error: %s", libusb_error_name(iStatus));
 578:libusbwrap.c  **** commit:
 2354              		.loc 3 578 0 is_stmt 1
 2355 15d6 90       		nop
 2356              	.L151:
 579:libusbwrap.c  **** 	queueCommitTake(&dev->queue);
 2357              		.loc 3 579 0
 2358 15d7 488B45A8 		movq	-88(%rbp), %rax
 2359 15db 4883C008 		addq	$8, %rax
 2360 15df 4889C7   		movq	%rax, %rdi
 2361 15e2 E8000000 		call	queueCommitTake@PLT
 2361      00
 2362              	.L145:
 580:libusbwrap.c  **** exit:
 581:libusbwrap.c  **** 	return retVal;
 2363              		.loc 3 581 0
 2364 15e7 8B45BC   		movl	-68(%rbp), %eax
 582:libusbwrap.c  **** }
 2365              		.loc 3 582 0
 2366 15ea 488B4DF8 		movq	-8(%rbp), %rcx
 2367 15ee 6448330C 		xorq	%fs:40, %rcx
 2367      25280000 
 2367      00
 2368 15f7 7405     		je	.L164
 2369 15f9 E8000000 		call	__stack_chk_fail@PLT
 2369      00
 2370              	.L164:
 2371 15fe C9       		leave
 2372              		.cfi_def_cfa 7, 8
 2373 15ff C3       		ret
 2374              		.cfi_endproc
 2375              	.LFE41:
 2377              		.globl	usbNumOutstandingRequests
 2379              	usbNumOutstandingRequests:
 2380              	.LFB42:
 583:libusbwrap.c  **** 
 584:libusbwrap.c  **** DLLEXPORT(size_t) usbNumOutstandingRequests(struct USBDevice *dev) {
 2381              		.loc 3 584 0
 2382              		.cfi_startproc
 2383 1600 55       		pushq	%rbp
 2384              		.cfi_def_cfa_offset 16
 2385              		.cfi_offset 6, -16
 2386 1601 4889E5   		movq	%rsp, %rbp
 2387              		.cfi_def_cfa_register 6
 2388 1604 4883EC08 		subq	$8, %rsp
 2389 1608 48897DF8 		movq	%rdi, -8(%rbp)
 585:libusbwrap.c  **** 	return queueSize(&dev->queue);
 2390              		.loc 3 585 0
 2391 160c 488B45F8 		movq	-8(%rbp), %rax
 2392 1610 4883C008 		addq	$8, %rax
 2393 1614 4889C7   		movq	%rax, %rdi
 2394 1617 E8E4E9FF 		call	queueSize
 2394      FF
 586:libusbwrap.c  **** }
 2395              		.loc 3 586 0
 2396 161c C9       		leave
 2397              		.cfi_def_cfa 7, 8
 2398 161d C3       		ret
 2399              		.cfi_endproc
 2400              	.LFE42:
 2402              	.Letext0:
 2403              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2404              		.file 5 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
 2405              		.file 6 "/usr/include/unistd.h"
 2406              		.file 7 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
 2407              		.file 8 "/usr/include/libio.h"
 2408              		.file 9 "/usr/include/stdio.h"
 2409              		.file 10 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
 2410              		.file 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
 2411              		.file 12 "/home/gani/eval/20140524/makestuff/common/makestuff.h"
 2412              		.file 13 "libusbwrap.h"
 2413              		.file 14 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
 2414              		.file 15 "/usr/include/x86_64-linux-gnu/sys/time.h"
 2415              		.file 16 "/usr/include/time.h"
 2416              		.file 17 "private.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 libusbwrap.c
     /tmp/ccdtdTzt.s:5      .text:0000000000000000 queueSize
     /tmp/ccdtdTzt.s:27     .text:0000000000000012 libusb_fill_bulk_transfer
     /tmp/ccdtdTzt.s:84     .bss:0000000000000000 m_ctx
     /tmp/ccdtdTzt.s:90     .text:0000000000000088 libusbOpenWithVidPid
     /tmp/ccdtdTzt.s:266    .text:0000000000000260 usbValidateVidPid
     /tmp/ccdtdTzt.s:473    .text:00000000000003e2 usbInitialise
     /tmp/ccdtdTzt.s:535    .text:0000000000000454 usbIsDeviceAvailable
     /tmp/ccdtdTzt.s:734    .text:0000000000000683 createTransfer
     /tmp/ccdtdTzt.s:792    .text:00000000000006f3 destroyTransfer
     /tmp/ccdtdTzt.s:841    .text:0000000000000724 usbOpenDevice
     /tmp/ccdtdTzt.s:1100   .text:0000000000000a2d usbCloseDevice
     /tmp/ccdtdTzt.s:1160   .text:0000000000000a8a usbControlRead
     /tmp/ccdtdTzt.s:1265   .text:0000000000000b7b usbControlWrite
     /tmp/ccdtdTzt.s:1370   .text:0000000000000c6c usbBulkRead
     /tmp/ccdtdTzt.s:1487   .text:0000000000000d88 usbBulkWrite
     /tmp/ccdtdTzt.s:1592   .text:0000000000000e9e bulk_transfer_cb
     /tmp/ccdtdTzt.s:1624   .text:0000000000000ebf usbBulkWriteAsync
     /tmp/ccdtdTzt.s:1746   .text:0000000000000ff4 usbBulkWriteAsyncPrepare
     /tmp/ccdtdTzt.s:1818   .text:0000000000001081 usbBulkWriteAsyncSubmit
     /tmp/ccdtdTzt.s:1964   .text:00000000000011f3 usbBulkReadAsync
     /tmp/ccdtdTzt.s:2126   .text:000000000000138d usbBulkAwaitCompletion
     /tmp/ccdtdTzt.s:2379   .text:0000000000001600 usbNumOutstandingRequests

UNDEFINED SYMBOLS
_GLOBAL_OFFSET_TABLE_
libusb_get_device_list
libusb_error_name
errPrefix
libusb_get_device_descriptor
libusb_open
errRender
libusb_free_device_list
__stack_chk_fail
strlen
libusb_init
libusb_set_debug
strtoul
calloc
libusb_alloc_transfer
free
libusb_free_transfer
malloc
queueInit
libusb_set_configuration
libusb_claim_interface
libusb_set_interface_alt_setting
libusb_release_interface
libusb_close
queueDestroy
libusb_control_transfer
libusb_bulk_transfer
queuePut
libusb_submit_transfer
queueCommitPut
queueTake
libusb_handle_events_timeout_completed
libusb_cancel_transfer
queueCommitTake
