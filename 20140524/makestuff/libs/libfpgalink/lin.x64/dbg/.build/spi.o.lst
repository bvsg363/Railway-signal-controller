   1              		.file	"spi.c"
   2              		.text
   3              	.Ltext0:
   5              	littleEndian32:
   6              	.LFB3:
   7              		.file 1 "/home/gani/eval/20140524/makestuff/common/makestuff.h"
   1:/home/gani/eval/20140524/makestuff/common/makestuff.h **** /*
   2:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * Copyright (C) 2009-2012 Chris McClelland
   3:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  *
   4:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * This program is free software: you can redistribute it and/or modify
   5:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * it under the terms of the GNU Lesser General Public License as published by
   6:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * the Free Software Foundation, either version 3 of the License, or
   7:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * (at your option) any later version.
   8:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  *
   9:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * This program is distributed in the hope that it will be useful,
  10:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * GNU Lesser General Public License for more details.
  13:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  *
  14:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * You should have received a copy of the GNU Lesser General Public License
  15:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:/home/gani/eval/20140524/makestuff/common/makestuff.h ****  */
  17:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  18:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #ifndef MAKESTUFF_H
  19:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define MAKESTUFF_H
  20:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  21:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #include <stddef.h>
  22:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  23:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #ifndef __cplusplus
  24:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#ifdef WIN32
  25:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		typedef char bool;
  26:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		enum {
  27:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 			false = 0,
  28:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 			true = 1
  29:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		};
  30:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#else
  31:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#include <stdbool.h>
  32:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#endif
  33:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #endif
  34:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  35:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #ifdef WIN32
  36:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#define WARN_UNUSED_RESULT
  37:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#define DLLEXPORT(t) __declspec(dllexport) t __stdcall
  38:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#define PFSZD "%Iu"
  39:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#ifdef _WIN64
  40:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#define PFSZH "%016IX"
  41:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#define WORD_LENGTH 64
  42:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#else
  43:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#define PFSZH "%08IX"
  44:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#define WORD_LENGTH 32
  45:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#endif
  46:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #else
  47:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#define WARN_UNUSED_RESULT __attribute__((warn_unused_result))
  48:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#define DLLEXPORT(t) t
  49:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#define PFSZD "%zu"
  50:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#ifdef __LP64__
  51:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#define PFSZH "%016zX"
  52:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#define WORD_LENGTH 64
  53:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#else
  54:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#define PFSZH "%08zX"
  55:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#define WORD_LENGTH 32
  56:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#endif
  57:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #endif
  58:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  59:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #ifndef NULL
  60:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#define NULL ((void*)0)
  61:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #endif
  62:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  63:/home/gani/eval/20140524/makestuff/common/makestuff.h **** typedef unsigned char      uint8;
  64:/home/gani/eval/20140524/makestuff/common/makestuff.h **** typedef unsigned short     uint16;
  65:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #ifndef __cplusplus
  66:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#ifndef SDCC
  67:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		typedef unsigned long long uint64;
  68:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#endif
  69:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #endif
  70:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  71:/home/gani/eval/20140524/makestuff/common/makestuff.h **** typedef signed char        int8;
  72:/home/gani/eval/20140524/makestuff/common/makestuff.h **** typedef signed short       int16;
  73:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  74:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #if (defined __AVR__ && defined __GNUC__) || defined SDCC
  75:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	// The embedded platforms have sizeof(int) = 2, so use long
  76:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	typedef signed long    int32;
  77:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	typedef unsigned long  uint32;
  78:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #else
  79:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	// The i686 & x86_64 have sizeof(int) = 4
  80:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	typedef signed int     int32;
  81:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	typedef unsigned int   uint32;
  82:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #endif
  83:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  84:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #ifndef __cplusplus
  85:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#ifndef SDCC
  86:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		typedef signed long long int64;
  87:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#endif
  88:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #endif
  89:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  90:/home/gani/eval/20140524/makestuff/common/makestuff.h **** typedef unsigned int       bitfield;
  91:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
  92:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #if defined __GNUC__
  93:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#define swap32(x) __builtin_bswap32(x)
  94:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #elif defined WIN32
  95:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#ifdef __cplusplus
  96:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		extern "C"
  97:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#endif
  98:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	unsigned long  __cdecl _byteswap_ulong(unsigned long);
  99:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#define swap32(x) _byteswap_ulong(x)
 100:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#ifndef __cplusplus
 101:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		#define inline __inline
 102:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#endif
 103:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #endif
 104:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define swap16(x) ((uint16)((((x) & 0x00FF) << 8) | (((x) >> 8) & 0x00FF)))
 105:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
 106:/home/gani/eval/20140524/makestuff/common/makestuff.h **** // The C standard requires this two-level indirection thing
 107:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #undef CONCAT
 108:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define CONCAT_INTERNAL(x, y) x ## y
 109:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define CONCAT(x, y) CONCAT_INTERNAL(x, y)
 110:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
 111:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define STR_INTERNAL(x) #x
 112:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define STR(x) STR_INTERNAL(x)
 113:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
 114:/home/gani/eval/20140524/makestuff/common/makestuff.h **** // The VA_NARGS() macro - count the number of arguments in a C99 variadic macro
 115:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define VA_EXPAND(x) x
 116:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define VA_NARGS(...) VA_EXPAND(VA_NARGS_INTERNAL(__VA_ARGS__, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 
 117:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define VA_NARGS_INTERNAL(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y
 118:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define FAIL(code, label) { retVal = code; goto label; }
 119:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
 120:/home/gani/eval/20140524/makestuff/common/makestuff.h **** // The CHECK_STATUS() macro - if condition is true, set a returnCode and jump to a label (exit,
 121:/home/gani/eval/20140524/makestuff/common/makestuff.h **** // cleanup etc). If liberror is included you can also give an error message.
 122:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define CHECK_INTERNAL3(condition, code, label) if ( condition ) { FAIL(code, label); }
 123:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define CHECK_INTERNAL4(condition, code, label, prefix) LIBERROR_IS_REQUIRED
 124:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define CHECK_INTERNAL5(condition, code, label, ...) LIBERROR_IS_REQUIRED
 125:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #define CHECK_STATUS(...) VA_EXPAND(CONCAT(CHECK_INTERNAL, VA_NARGS(__VA_ARGS__))(__VA_ARGS__))
 126:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 
 127:/home/gani/eval/20140524/makestuff/common/makestuff.h **** #ifdef BYTE_ORDER
 128:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 	#if BYTE_ORDER == 1234
 129:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		// Little-endian machines
 130:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		static inline uint16 bigEndian16(uint16 x) {
 131:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 			return swap16(x);
 132:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		}
 133:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		static inline uint32 bigEndian32(uint32 x) {
 134:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 			return swap32(x);
 135:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		}
 136:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		static inline uint16 littleEndian16(uint16 x) {
 137:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 			return x;
 138:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		}
 139:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		static inline uint32 littleEndian32(uint32 x) {
   8              		.loc 1 139 0
   9              		.cfi_startproc
  10 0000 55       		pushq	%rbp
  11              		.cfi_def_cfa_offset 16
  12              		.cfi_offset 6, -16
  13 0001 4889E5   		movq	%rsp, %rbp
  14              		.cfi_def_cfa_register 6
  15 0004 897DFC   		movl	%edi, -4(%rbp)
 140:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 			return x;
  16              		.loc 1 140 0
  17 0007 8B45FC   		movl	-4(%rbp), %eax
 141:/home/gani/eval/20140524/makestuff/common/makestuff.h **** 		}
  18              		.loc 1 141 0
  19 000a 5D       		popq	%rbp
  20              		.cfi_def_cfa 7, 8
  21 000b C3       		ret
  22              		.cfi_endproc
  23              	.LFE3:
  25              		.section	.rodata
  26              		.align 32
  29              	swapTable:
  30 0000 00       		.byte	0
  31 0001 80       		.byte	-128
  32 0002 40       		.byte	64
  33 0003 C0       		.byte	-64
  34 0004 20       		.byte	32
  35 0005 A0       		.byte	-96
  36 0006 60       		.byte	96
  37 0007 E0       		.byte	-32
  38 0008 10       		.byte	16
  39 0009 90       		.byte	-112
  40 000a 50       		.byte	80
  41 000b D0       		.byte	-48
  42 000c 30       		.byte	48
  43 000d B0       		.byte	-80
  44 000e 70       		.byte	112
  45 000f F0       		.byte	-16
  46 0010 08       		.byte	8
  47 0011 88       		.byte	-120
  48 0012 48       		.byte	72
  49 0013 C8       		.byte	-56
  50 0014 28       		.byte	40
  51 0015 A8       		.byte	-88
  52 0016 68       		.byte	104
  53 0017 E8       		.byte	-24
  54 0018 18       		.byte	24
  55 0019 98       		.byte	-104
  56 001a 58       		.byte	88
  57 001b D8       		.byte	-40
  58 001c 38       		.byte	56
  59 001d B8       		.byte	-72
  60 001e 78       		.byte	120
  61 001f F8       		.byte	-8
  62 0020 04       		.byte	4
  63 0021 84       		.byte	-124
  64 0022 44       		.byte	68
  65 0023 C4       		.byte	-60
  66 0024 24       		.byte	36
  67 0025 A4       		.byte	-92
  68 0026 64       		.byte	100
  69 0027 E4       		.byte	-28
  70 0028 14       		.byte	20
  71 0029 94       		.byte	-108
  72 002a 54       		.byte	84
  73 002b D4       		.byte	-44
  74 002c 34       		.byte	52
  75 002d B4       		.byte	-76
  76 002e 74       		.byte	116
  77 002f F4       		.byte	-12
  78 0030 0C       		.byte	12
  79 0031 8C       		.byte	-116
  80 0032 4C       		.byte	76
  81 0033 CC       		.byte	-52
  82 0034 2C       		.byte	44
  83 0035 AC       		.byte	-84
  84 0036 6C       		.byte	108
  85 0037 EC       		.byte	-20
  86 0038 1C       		.byte	28
  87 0039 9C       		.byte	-100
  88 003a 5C       		.byte	92
  89 003b DC       		.byte	-36
  90 003c 3C       		.byte	60
  91 003d BC       		.byte	-68
  92 003e 7C       		.byte	124
  93 003f FC       		.byte	-4
  94 0040 02       		.byte	2
  95 0041 82       		.byte	-126
  96 0042 42       		.byte	66
  97 0043 C2       		.byte	-62
  98 0044 22       		.byte	34
  99 0045 A2       		.byte	-94
 100 0046 62       		.byte	98
 101 0047 E2       		.byte	-30
 102 0048 12       		.byte	18
 103 0049 92       		.byte	-110
 104 004a 52       		.byte	82
 105 004b D2       		.byte	-46
 106 004c 32       		.byte	50
 107 004d B2       		.byte	-78
 108 004e 72       		.byte	114
 109 004f F2       		.byte	-14
 110 0050 0A       		.byte	10
 111 0051 8A       		.byte	-118
 112 0052 4A       		.byte	74
 113 0053 CA       		.byte	-54
 114 0054 2A       		.byte	42
 115 0055 AA       		.byte	-86
 116 0056 6A       		.byte	106
 117 0057 EA       		.byte	-22
 118 0058 1A       		.byte	26
 119 0059 9A       		.byte	-102
 120 005a 5A       		.byte	90
 121 005b DA       		.byte	-38
 122 005c 3A       		.byte	58
 123 005d BA       		.byte	-70
 124 005e 7A       		.byte	122
 125 005f FA       		.byte	-6
 126 0060 06       		.byte	6
 127 0061 86       		.byte	-122
 128 0062 46       		.byte	70
 129 0063 C6       		.byte	-58
 130 0064 26       		.byte	38
 131 0065 A6       		.byte	-90
 132 0066 66       		.byte	102
 133 0067 E6       		.byte	-26
 134 0068 16       		.byte	22
 135 0069 96       		.byte	-106
 136 006a 56       		.byte	86
 137 006b D6       		.byte	-42
 138 006c 36       		.byte	54
 139 006d B6       		.byte	-74
 140 006e 76       		.byte	118
 141 006f F6       		.byte	-10
 142 0070 0E       		.byte	14
 143 0071 8E       		.byte	-114
 144 0072 4E       		.byte	78
 145 0073 CE       		.byte	-50
 146 0074 2E       		.byte	46
 147 0075 AE       		.byte	-82
 148 0076 6E       		.byte	110
 149 0077 EE       		.byte	-18
 150 0078 1E       		.byte	30
 151 0079 9E       		.byte	-98
 152 007a 5E       		.byte	94
 153 007b DE       		.byte	-34
 154 007c 3E       		.byte	62
 155 007d BE       		.byte	-66
 156 007e 7E       		.byte	126
 157 007f FE       		.byte	-2
 158 0080 01       		.byte	1
 159 0081 81       		.byte	-127
 160 0082 41       		.byte	65
 161 0083 C1       		.byte	-63
 162 0084 21       		.byte	33
 163 0085 A1       		.byte	-95
 164 0086 61       		.byte	97
 165 0087 E1       		.byte	-31
 166 0088 11       		.byte	17
 167 0089 91       		.byte	-111
 168 008a 51       		.byte	81
 169 008b D1       		.byte	-47
 170 008c 31       		.byte	49
 171 008d B1       		.byte	-79
 172 008e 71       		.byte	113
 173 008f F1       		.byte	-15
 174 0090 09       		.byte	9
 175 0091 89       		.byte	-119
 176 0092 49       		.byte	73
 177 0093 C9       		.byte	-55
 178 0094 29       		.byte	41
 179 0095 A9       		.byte	-87
 180 0096 69       		.byte	105
 181 0097 E9       		.byte	-23
 182 0098 19       		.byte	25
 183 0099 99       		.byte	-103
 184 009a 59       		.byte	89
 185 009b D9       		.byte	-39
 186 009c 39       		.byte	57
 187 009d B9       		.byte	-71
 188 009e 79       		.byte	121
 189 009f F9       		.byte	-7
 190 00a0 05       		.byte	5
 191 00a1 85       		.byte	-123
 192 00a2 45       		.byte	69
 193 00a3 C5       		.byte	-59
 194 00a4 25       		.byte	37
 195 00a5 A5       		.byte	-91
 196 00a6 65       		.byte	101
 197 00a7 E5       		.byte	-27
 198 00a8 15       		.byte	21
 199 00a9 95       		.byte	-107
 200 00aa 55       		.byte	85
 201 00ab D5       		.byte	-43
 202 00ac 35       		.byte	53
 203 00ad B5       		.byte	-75
 204 00ae 75       		.byte	117
 205 00af F5       		.byte	-11
 206 00b0 0D       		.byte	13
 207 00b1 8D       		.byte	-115
 208 00b2 4D       		.byte	77
 209 00b3 CD       		.byte	-51
 210 00b4 2D       		.byte	45
 211 00b5 AD       		.byte	-83
 212 00b6 6D       		.byte	109
 213 00b7 ED       		.byte	-19
 214 00b8 1D       		.byte	29
 215 00b9 9D       		.byte	-99
 216 00ba 5D       		.byte	93
 217 00bb DD       		.byte	-35
 218 00bc 3D       		.byte	61
 219 00bd BD       		.byte	-67
 220 00be 7D       		.byte	125
 221 00bf FD       		.byte	-3
 222 00c0 03       		.byte	3
 223 00c1 83       		.byte	-125
 224 00c2 43       		.byte	67
 225 00c3 C3       		.byte	-61
 226 00c4 23       		.byte	35
 227 00c5 A3       		.byte	-93
 228 00c6 63       		.byte	99
 229 00c7 E3       		.byte	-29
 230 00c8 13       		.byte	19
 231 00c9 93       		.byte	-109
 232 00ca 53       		.byte	83
 233 00cb D3       		.byte	-45
 234 00cc 33       		.byte	51
 235 00cd B3       		.byte	-77
 236 00ce 73       		.byte	115
 237 00cf F3       		.byte	-13
 238 00d0 0B       		.byte	11
 239 00d1 8B       		.byte	-117
 240 00d2 4B       		.byte	75
 241 00d3 CB       		.byte	-53
 242 00d4 2B       		.byte	43
 243 00d5 AB       		.byte	-85
 244 00d6 6B       		.byte	107
 245 00d7 EB       		.byte	-21
 246 00d8 1B       		.byte	27
 247 00d9 9B       		.byte	-101
 248 00da 5B       		.byte	91
 249 00db DB       		.byte	-37
 250 00dc 3B       		.byte	59
 251 00dd BB       		.byte	-69
 252 00de 7B       		.byte	123
 253 00df FB       		.byte	-5
 254 00e0 07       		.byte	7
 255 00e1 87       		.byte	-121
 256 00e2 47       		.byte	71
 257 00e3 C7       		.byte	-57
 258 00e4 27       		.byte	39
 259 00e5 A7       		.byte	-89
 260 00e6 67       		.byte	103
 261 00e7 E7       		.byte	-25
 262 00e8 17       		.byte	23
 263 00e9 97       		.byte	-105
 264 00ea 57       		.byte	87
 265 00eb D7       		.byte	-41
 266 00ec 37       		.byte	55
 267 00ed B7       		.byte	-73
 268 00ee 77       		.byte	119
 269 00ef F7       		.byte	-9
 270 00f0 0F       		.byte	15
 271 00f1 8F       		.byte	-113
 272 00f2 4F       		.byte	79
 273 00f3 CF       		.byte	-49
 274 00f4 2F       		.byte	47
 275 00f5 AF       		.byte	-81
 276 00f6 6F       		.byte	111
 277 00f7 EF       		.byte	-17
 278 00f8 1F       		.byte	31
 279 00f9 9F       		.byte	-97
 280 00fa 5F       		.byte	95
 281 00fb DF       		.byte	-33
 282 00fc 3F       		.byte	63
 283 00fd BF       		.byte	-65
 284 00fe 7F       		.byte	127
 285 00ff FF       		.byte	-1
 286              		.text
 287              		.globl	spiBitSwap
 289              	spiBitSwap:
 290              	.LFB4:
 291              		.file 2 "spi.c"
   1:spi.c         **** /*
   2:spi.c         ****  * Copyright (C) 2013 Chris McClelland
   3:spi.c         ****  *
   4:spi.c         ****  * This program is free software: you can redistribute it and/or modify
   5:spi.c         ****  * it under the terms of the GNU Lesser General Public License as published by
   6:spi.c         ****  * the Free Software Foundation, either version 3 of the License, or
   7:spi.c         ****  * (at your option) any later version.
   8:spi.c         ****  *
   9:spi.c         ****  * This program is distributed in the hope that it will be useful,
  10:spi.c         ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:spi.c         ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:spi.c         ****  * GNU Lesser General Public License for more details.
  13:spi.c         ****  *
  14:spi.c         ****  * You should have received a copy of the GNU Lesser General Public License
  15:spi.c         ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:spi.c         ****  */
  17:spi.c         **** #include <stdlib.h>
  18:spi.c         **** #include <makestuff.h>
  19:spi.c         **** #include <libusbwrap.h>
  20:spi.c         **** #include <liberror.h>
  21:spi.c         **** #include "private.h"
  22:spi.c         **** #include "vendorCommands.h"
  23:spi.c         **** 
  24:spi.c         **** static const uint8 swapTable[] = {
  25:spi.c         **** 	0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
  26:spi.c         **** 	0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
  27:spi.c         **** 	0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
  28:spi.c         **** 	0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
  29:spi.c         **** 	0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
  30:spi.c         **** 	0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
  31:spi.c         **** 	0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
  32:spi.c         **** 	0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
  33:spi.c         **** 	0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
  34:spi.c         **** 	0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
  35:spi.c         **** 	0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
  36:spi.c         **** 	0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
  37:spi.c         **** 	0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
  38:spi.c         **** 	0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
  39:spi.c         **** 	0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
  40:spi.c         **** 	0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
  41:spi.c         **** };
  42:spi.c         **** 
  43:spi.c         **** DLLEXPORT(void) spiBitSwap(uint32 length, uint8 *buffer) {
 292              		.loc 2 43 0
 293              		.cfi_startproc
 294 000c 55       		pushq	%rbp
 295              		.cfi_def_cfa_offset 16
 296              		.cfi_offset 6, -16
 297 000d 4889E5   		movq	%rsp, %rbp
 298              		.cfi_def_cfa_register 6
 299 0010 897DFC   		movl	%edi, -4(%rbp)
 300 0013 488975F0 		movq	%rsi, -16(%rbp)
  44:spi.c         **** 	while ( length-- ) {
 301              		.loc 2 44 0
 302 0017 EB23     		jmp	.L4
 303              	.L5:
  45:spi.c         **** 		*buffer = swapTable[*buffer];
 304              		.loc 2 45 0
 305 0019 488B45F0 		movq	-16(%rbp), %rax
 306 001d 0FB600   		movzbl	(%rax), %eax
 307 0020 0FB6C0   		movzbl	%al, %eax
 308 0023 4863D0   		movslq	%eax, %rdx
 309 0026 488D0500 		leaq	swapTable(%rip), %rax
 309      000000
 310 002d 0FB61402 		movzbl	(%rdx,%rax), %edx
 311 0031 488B45F0 		movq	-16(%rbp), %rax
 312 0035 8810     		movb	%dl, (%rax)
  46:spi.c         **** 		buffer++;
 313              		.loc 2 46 0
 314 0037 488345F0 		addq	$1, -16(%rbp)
 314      01
 315              	.L4:
  44:spi.c         **** 	while ( length-- ) {
 316              		.loc 2 44 0
 317 003c 8B45FC   		movl	-4(%rbp), %eax
 318 003f 8D50FF   		leal	-1(%rax), %edx
 319 0042 8955FC   		movl	%edx, -4(%rbp)
 320 0045 85C0     		testl	%eax, %eax
 321 0047 75D0     		jne	.L5
  47:spi.c         **** 	}
  48:spi.c         **** }
 322              		.loc 2 48 0
 323 0049 90       		nop
 324 004a 5D       		popq	%rbp
 325              		.cfi_def_cfa 7, 8
 326 004b C3       		ret
 327              		.cfi_endproc
 328              	.LFE4:
 330              		.section	.rodata
 331              	.LC0:
 332 0100 73706953 		.string	"spiSend()"
 332      656E6428 
 332      2900
 333 010a 00000000 		.align 8
 333      0000
 334              	.LC1:
 335 0110 73706953 		.string	"spiSend(): device doesn't support SPI send"
 335      656E6428 
 335      293A2064 
 335      65766963 
 335      6520646F 
 336              		.text
 337              		.globl	spiSend
 339              	spiSend:
 340              	.LFB5:
  49:spi.c         **** 
  50:spi.c         **** DLLEXPORT(FLStatus) spiSend(
  51:spi.c         **** 	struct FLContext *handle, uint32 length, const uint8 *buffer, uint8 bitOrder, const char **error)
  52:spi.c         **** {
 341              		.loc 2 52 0
 342              		.cfi_startproc
 343 004c 55       		pushq	%rbp
 344              		.cfi_def_cfa_offset 16
 345              		.cfi_offset 6, -16
 346 004d 4889E5   		movq	%rsp, %rbp
 347              		.cfi_def_cfa_register 6
 348 0050 4883EC60 		subq	$96, %rsp
 349 0054 48897DB8 		movq	%rdi, -72(%rbp)
 350 0058 8975B4   		movl	%esi, -76(%rbp)
 351 005b 488955A8 		movq	%rdx, -88(%rbp)
 352 005f 89C8     		movl	%ecx, %eax
 353 0061 4C8945A0 		movq	%r8, -96(%rbp)
 354 0065 8845B0   		movb	%al, -80(%rbp)
 355              		.loc 2 52 0
 356 0068 64488B04 		movq	%fs:40, %rax
 356      25280000 
 356      00
 357 0071 488945F8 		movq	%rax, -8(%rbp)
 358 0075 31C0     		xorl	%eax, %eax
  53:spi.c         **** 	FLStatus retVal = FL_SUCCESS;
 359              		.loc 2 53 0
 360 0077 C745C400 		movl	$0, -60(%rbp)
 360      000000
  54:spi.c         **** 	USBStatus uStatus;
  55:spi.c         **** 	uint8 *swapBuffer = NULL;
 361              		.loc 2 55 0
 362 007e 48C745D0 		movq	$0, -48(%rbp)
 362      00000000 
  56:spi.c         **** 	const uint8 *data = buffer;
 363              		.loc 2 56 0
 364 0086 488B45A8 		movq	-88(%rbp), %rax
 365 008a 488945D8 		movq	%rax, -40(%rbp)
  57:spi.c         **** 	union {
  58:spi.c         **** 		uint32 u32;
  59:spi.c         **** 		uint8 bytes[4];
  60:spi.c         **** 	} countUnion;
  61:spi.c         **** 
  62:spi.c         **** 	// Maybe make a bit-swapped copy of the data before sending it
  63:spi.c         **** 	if ( bitOrder == SPI_MSBFIRST ) {
 366              		.loc 2 63 0
 367 008e 807DB000 		cmpb	$0, -80(%rbp)
 368 0092 0F858E00 		jne	.L7
 368      0000
 369              	.LBB2:
  64:spi.c         **** 		uint32 count = length;
 370              		.loc 2 64 0
 371 0098 8B45B4   		movl	-76(%rbp), %eax
 372 009b 8945CC   		movl	%eax, -52(%rbp)
  65:spi.c         **** 		const uint8 *srcPtr = buffer;
 373              		.loc 2 65 0
 374 009e 488B45A8 		movq	-88(%rbp), %rax
 375 00a2 488945E0 		movq	%rax, -32(%rbp)
  66:spi.c         **** 		uint8 *dstPtr = swapBuffer = (uint8*)malloc(length);
 376              		.loc 2 66 0
 377 00a6 8B45B4   		movl	-76(%rbp), %eax
 378 00a9 4889C7   		movq	%rax, %rdi
 379 00ac E8000000 		call	malloc@PLT
 379      00
 380 00b1 488945D0 		movq	%rax, -48(%rbp)
 381 00b5 488B45D0 		movq	-48(%rbp), %rax
 382 00b9 488945E8 		movq	%rax, -24(%rbp)
  67:spi.c         **** 		CHECK_STATUS(!swapBuffer, FL_ALLOC_ERR, cleanup, "spiSend()");
 383              		.loc 2 67 0
 384 00bd 48837DD0 		cmpq	$0, -48(%rbp)
 384      00
 385 00c2 754D     		jne	.L10
 386              		.loc 2 67 0 is_stmt 0 discriminator 1
 387 00c4 488B45A0 		movq	-96(%rbp), %rax
 388 00c8 488D3500 		leaq	.LC0(%rip), %rsi
 388      000000
 389 00cf 4889C7   		movq	%rax, %rdi
 390 00d2 E8000000 		call	errPrefix@PLT
 390      00
 391 00d7 C745C401 		movl	$1, -60(%rbp)
 391      000000
 392 00de E96C0100 		jmp	.L9
 392      00
 393              	.L11:
  68:spi.c         **** 		while ( count-- ) {
  69:spi.c         **** 			*dstPtr++ = swapTable[*srcPtr++];
 394              		.loc 2 69 0 is_stmt 1
 395 00e3 488B45E0 		movq	-32(%rbp), %rax
 396 00e7 488D5001 		leaq	1(%rax), %rdx
 397 00eb 488955E0 		movq	%rdx, -32(%rbp)
 398 00ef 0FB600   		movzbl	(%rax), %eax
 399 00f2 0FB6C8   		movzbl	%al, %ecx
 400 00f5 488B45E8 		movq	-24(%rbp), %rax
 401 00f9 488D5001 		leaq	1(%rax), %rdx
 402 00fd 488955E8 		movq	%rdx, -24(%rbp)
 403 0101 4863C9   		movslq	%ecx, %rcx
 404 0104 488D1500 		leaq	swapTable(%rip), %rdx
 404      000000
 405 010b 0FB61411 		movzbl	(%rcx,%rdx), %edx
 406 010f 8810     		movb	%dl, (%rax)
 407              	.L10:
  68:spi.c         **** 		while ( count-- ) {
 408              		.loc 2 68 0
 409 0111 8B45CC   		movl	-52(%rbp), %eax
 410 0114 8D50FF   		leal	-1(%rax), %edx
 411 0117 8955CC   		movl	%edx, -52(%rbp)
 412 011a 85C0     		testl	%eax, %eax
 413 011c 75C5     		jne	.L11
  70:spi.c         **** 		}
  71:spi.c         **** 		data = swapBuffer;
 414              		.loc 2 71 0
 415 011e 488B45D0 		movq	-48(%rbp), %rax
 416 0122 488945D8 		movq	%rax, -40(%rbp)
 417              	.L7:
 418              	.LBE2:
  72:spi.c         **** 	}
  73:spi.c         **** 
  74:spi.c         **** 	// Request the SPI send operation
  75:spi.c         **** 	countUnion.u32 = littleEndian32(length);
 419              		.loc 2 75 0
 420 0126 8B45B4   		movl	-76(%rbp), %eax
 421 0129 89C7     		movl	%eax, %edi
 422 012b E8D0FEFF 		call	littleEndian32
 422      FF
 423 0130 8945F4   		movl	%eax, -12(%rbp)
  76:spi.c         **** 	uStatus = usbControlWrite(
 424              		.loc 2 76 0
 425 0133 488B45B8 		movq	-72(%rbp), %rax
 426 0137 488B00   		movq	(%rax), %rax
 427 013a 488D55F4 		leaq	-12(%rbp), %rdx
 428 013e 6A00     		pushq	$0
 429 0140 68E80300 		pushq	$1000
 429      00
 430 0145 41B90400 		movl	$4, %r9d
 430      0000
 431 014b 4989D0   		movq	%rdx, %r8
 432 014e B9060000 		movl	$6, %ecx
 432      00
 433 0153 BA000000 		movl	$0, %edx
 433      00
 434 0158 BE810000 		movl	$129, %esi
 434      00
 435 015d 4889C7   		movq	%rax, %rdi
 436 0160 E8000000 		call	usbControlWrite@PLT
 436      00
 437 0165 4883C410 		addq	$16, %rsp
 438 0169 8945C8   		movl	%eax, -56(%rbp)
  77:spi.c         **** 		handle->device, CMD_PROG_CLOCK_DATA, 0x0000, PROG_SPI_SEND,
  78:spi.c         **** 		countUnion.bytes, 4, 1000, NULL);
  79:spi.c         **** 	CHECK_STATUS(uStatus, FL_PROTOCOL_ERR, cleanup, "spiSend(): device doesn't support SPI send");
 439              		.loc 2 79 0
 440 016c 837DC800 		cmpl	$0, -56(%rbp)
 441 0170 745B     		je	.L13
 442              		.loc 2 79 0 is_stmt 0 discriminator 1
 443 0172 488B45A0 		movq	-96(%rbp), %rax
 444 0176 488D3500 		leaq	.LC1(%rip), %rsi
 444      000000
 445 017d 4889C7   		movq	%rax, %rdi
 446 0180 E8000000 		call	errPrefix@PLT
 446      00
 447 0185 C745C403 		movl	$3, -60(%rbp)
 447      000000
 448 018c E9BE0000 		jmp	.L9
 448      00
 449              	.L14:
  80:spi.c         **** 
  81:spi.c         **** 	// You have to report it as 512 bytes, but make sure you never try to do a
  82:spi.c         **** 	// packet larger than 64.
  83:spi.c         **** 	// http://permalink.gmane.org/gmane.comp.lib.libusbx.devel/1312
  84:spi.c         **** 	//
  85:spi.c         **** 	while ( length >= 64 ) {
  86:spi.c         **** 		uStatus = usbBulkWrite(
  87:spi.c         **** 			handle->device,
  88:spi.c         **** 			handle->progOutEP,  // write to OUT endpoint
 450              		.loc 2 88 0 is_stmt 1
 451 0191 488B45B8 		movq	-72(%rbp), %rax
 452 0195 0FB64015 		movzbl	21(%rax), %eax
  86:spi.c         **** 			handle->device,
 453              		.loc 2 86 0
 454 0199 0FB6F0   		movzbl	%al, %esi
 455 019c 488B45B8 		movq	-72(%rbp), %rax
 456 01a0 488B00   		movq	(%rax), %rax
 457 01a3 488B4DA0 		movq	-96(%rbp), %rcx
 458 01a7 488B55D8 		movq	-40(%rbp), %rdx
 459 01ab 4989C9   		movq	%rcx, %r9
 460 01ae 41B8FFFF 		movl	$-1, %r8d
 460      FFFF
 461 01b4 B9400000 		movl	$64, %ecx
 461      00
 462 01b9 4889C7   		movq	%rax, %rdi
 463 01bc E8000000 		call	usbBulkWrite@PLT
 463      00
 464 01c1 8945C8   		movl	%eax, -56(%rbp)
  89:spi.c         **** 			data,               // write from send buffer
  90:spi.c         **** 			64,                 // write this many bytes
  91:spi.c         **** 			U32MAX,             // timeout in milliseconds
  92:spi.c         **** 			error
  93:spi.c         **** 		);
  94:spi.c         **** 		data += 64;
 465              		.loc 2 94 0
 466 01c4 488345D8 		addq	$64, -40(%rbp)
 466      40
  95:spi.c         **** 		length -= 64;
 467              		.loc 2 95 0
 468 01c9 836DB440 		subl	$64, -76(%rbp)
 469              	.L13:
  85:spi.c         **** 		uStatus = usbBulkWrite(
 470              		.loc 2 85 0
 471 01cd 837DB43F 		cmpl	$63, -76(%rbp)
 472 01d1 77BE     		ja	.L14
  96:spi.c         **** 	}
  97:spi.c         **** 	if ( length ) {
 473              		.loc 2 97 0
 474 01d3 837DB400 		cmpl	$0, -76(%rbp)
 475 01d7 7475     		je	.L18
  98:spi.c         **** 		CHECK_STATUS(uStatus, FL_USB_ERR, cleanup, "spiSend()");
 476              		.loc 2 98 0
 477 01d9 837DC800 		cmpl	$0, -56(%rbp)
 478 01dd 741C     		je	.L15
 479              		.loc 2 98 0 is_stmt 0 discriminator 1
 480 01df 488B45A0 		movq	-96(%rbp), %rax
 481 01e3 488D3500 		leaq	.LC0(%rip), %rsi
 481      000000
 482 01ea 4889C7   		movq	%rax, %rdi
 483 01ed E8000000 		call	errPrefix@PLT
 483      00
 484 01f2 C745C402 		movl	$2, -60(%rbp)
 484      000000
 485 01f9 EB54     		jmp	.L9
 486              	.L15:
  99:spi.c         **** 		uStatus = usbBulkWrite(
 100:spi.c         **** 			handle->device,
 101:spi.c         **** 			handle->progOutEP,  // write to OUT endpoint
 487              		.loc 2 101 0 is_stmt 1
 488 01fb 488B45B8 		movq	-72(%rbp), %rax
 489 01ff 0FB64015 		movzbl	21(%rax), %eax
  99:spi.c         **** 		uStatus = usbBulkWrite(
 490              		.loc 2 99 0
 491 0203 0FB6F0   		movzbl	%al, %esi
 492 0206 488B45B8 		movq	-72(%rbp), %rax
 493 020a 488B00   		movq	(%rax), %rax
 494 020d 488B7DA0 		movq	-96(%rbp), %rdi
 495 0211 8B4DB4   		movl	-76(%rbp), %ecx
 496 0214 488B55D8 		movq	-40(%rbp), %rdx
 497 0218 4989F9   		movq	%rdi, %r9
 498 021b 41B8FFFF 		movl	$-1, %r8d
 498      FFFF
 499 0221 4889C7   		movq	%rax, %rdi
 500 0224 E8000000 		call	usbBulkWrite@PLT
 500      00
 501 0229 8945C8   		movl	%eax, -56(%rbp)
 102:spi.c         **** 			data,               // write from send buffer
 103:spi.c         **** 			length,             // write this many bytes
 104:spi.c         **** 			U32MAX,             // timeout in milliseconds
 105:spi.c         **** 			error
 106:spi.c         **** 		);
 107:spi.c         **** 		CHECK_STATUS(uStatus, FL_USB_ERR, cleanup, "spiSend()");
 502              		.loc 2 107 0
 503 022c 837DC800 		cmpl	$0, -56(%rbp)
 504 0230 741C     		je	.L18
 505              		.loc 2 107 0 is_stmt 0 discriminator 1
 506 0232 488B45A0 		movq	-96(%rbp), %rax
 507 0236 488D3500 		leaq	.LC0(%rip), %rsi
 507      000000
 508 023d 4889C7   		movq	%rax, %rdi
 509 0240 E8000000 		call	errPrefix@PLT
 509      00
 510 0245 C745C402 		movl	$2, -60(%rbp)
 510      000000
 511 024c EB01     		jmp	.L9
 512              	.L18:
 108:spi.c         **** 	}
 109:spi.c         **** cleanup:
 513              		.loc 2 109 0 is_stmt 1
 514 024e 90       		nop
 515              	.L9:
 110:spi.c         **** 	free(swapBuffer);
 516              		.loc 2 110 0
 517 024f 488B45D0 		movq	-48(%rbp), %rax
 518 0253 4889C7   		movq	%rax, %rdi
 519 0256 E8000000 		call	free@PLT
 519      00
 111:spi.c         **** 	return retVal;
 520              		.loc 2 111 0
 521 025b 8B45C4   		movl	-60(%rbp), %eax
 112:spi.c         **** }
 522              		.loc 2 112 0
 523 025e 488B4DF8 		movq	-8(%rbp), %rcx
 524 0262 6448330C 		xorq	%fs:40, %rcx
 524      25280000 
 524      00
 525 026b 7405     		je	.L17
 526 026d E8000000 		call	__stack_chk_fail@PLT
 526      00
 527              	.L17:
 528 0272 C9       		leave
 529              		.cfi_def_cfa 7, 8
 530 0273 C3       		ret
 531              		.cfi_endproc
 532              	.LFE5:
 534              		.section	.rodata
 535 013b 00000000 		.align 8
 535      00
 536              	.LC2:
 537 0140 73706952 		.string	"spiRecv(): device doesn't support SPI receive"
 537      65637628 
 537      293A2064 
 537      65766963 
 537      6520646F 
 538              	.LC3:
 539 016e 73706952 		.string	"spiRecv()"
 539      65637628 
 539      2900
 540              		.text
 541              		.globl	spiRecv
 543              	spiRecv:
 544              	.LFB6:
 113:spi.c         **** 
 114:spi.c         **** DLLEXPORT(FLStatus) spiRecv(
 115:spi.c         **** 	struct FLContext *handle, uint32 length, uint8 *buf, uint8 bitOrder, const char **error)
 116:spi.c         **** {
 545              		.loc 2 116 0
 546              		.cfi_startproc
 547 0274 55       		pushq	%rbp
 548              		.cfi_def_cfa_offset 16
 549              		.cfi_offset 6, -16
 550 0275 4889E5   		movq	%rsp, %rbp
 551              		.cfi_def_cfa_register 6
 552 0278 4883EC50 		subq	$80, %rsp
 553 027c 48897DC8 		movq	%rdi, -56(%rbp)
 554 0280 8975C4   		movl	%esi, -60(%rbp)
 555 0283 488955B8 		movq	%rdx, -72(%rbp)
 556 0287 89C8     		movl	%ecx, %eax
 557 0289 4C8945B0 		movq	%r8, -80(%rbp)
 558 028d 8845C0   		movb	%al, -64(%rbp)
 559              		.loc 2 116 0
 560 0290 64488B04 		movq	%fs:40, %rax
 560      25280000 
 560      00
 561 0299 488945F8 		movq	%rax, -8(%rbp)
 562 029d 31C0     		xorl	%eax, %eax
 117:spi.c         **** 	FLStatus retVal = FL_SUCCESS;
 563              		.loc 2 117 0
 564 029f C745DC00 		movl	$0, -36(%rbp)
 564      000000
 118:spi.c         **** 	USBStatus uStatus;
 119:spi.c         **** 	union {
 120:spi.c         **** 		uint32 u32;
 121:spi.c         **** 		uint8 bytes[4];
 122:spi.c         **** 	} countUnion;
 123:spi.c         **** 	uint32 count = length;
 565              		.loc 2 123 0
 566 02a6 8B45C4   		movl	-60(%rbp), %eax
 567 02a9 8945E0   		movl	%eax, -32(%rbp)
 124:spi.c         **** 	uint8 *ptr = buf;
 568              		.loc 2 124 0
 569 02ac 488B45B8 		movq	-72(%rbp), %rax
 570 02b0 488945E8 		movq	%rax, -24(%rbp)
 125:spi.c         **** 
 126:spi.c         **** 	// Request the SPI receive operation
 127:spi.c         **** 	countUnion.u32 = littleEndian32(length);
 571              		.loc 2 127 0
 572 02b4 8B45C4   		movl	-60(%rbp), %eax
 573 02b7 89C7     		movl	%eax, %edi
 574 02b9 E842FDFF 		call	littleEndian32
 574      FF
 575 02be 8945F4   		movl	%eax, -12(%rbp)
 128:spi.c         **** 	uStatus = usbControlWrite(
 576              		.loc 2 128 0
 577 02c1 488B45C8 		movq	-56(%rbp), %rax
 578 02c5 488B00   		movq	(%rax), %rax
 579 02c8 488D55F4 		leaq	-12(%rbp), %rdx
 580 02cc 6A00     		pushq	$0
 581 02ce 68E80300 		pushq	$1000
 581      00
 582 02d3 41B90400 		movl	$4, %r9d
 582      0000
 583 02d9 4989D0   		movq	%rdx, %r8
 584 02dc B9070000 		movl	$7, %ecx
 584      00
 585 02e1 BA000000 		movl	$0, %edx
 585      00
 586 02e6 BE810000 		movl	$129, %esi
 586      00
 587 02eb 4889C7   		movq	%rax, %rdi
 588 02ee E8000000 		call	usbControlWrite@PLT
 588      00
 589 02f3 4883C410 		addq	$16, %rsp
 590 02f7 8945E4   		movl	%eax, -28(%rbp)
 129:spi.c         **** 		handle->device, CMD_PROG_CLOCK_DATA, 0x0000, PROG_SPI_RECV,
 130:spi.c         **** 		countUnion.bytes, 4, 1000, NULL);
 131:spi.c         **** 	CHECK_STATUS(uStatus, FL_PROTOCOL_ERR, cleanup, "spiRecv(): device doesn't support SPI receive");
 591              		.loc 2 131 0
 592 02fa 837DE400 		cmpl	$0, -28(%rbp)
 593 02fe 0F848000 		je	.L22
 593      0000
 594              		.loc 2 131 0 is_stmt 0 discriminator 1
 595 0304 488B45B0 		movq	-80(%rbp), %rax
 596 0308 488D3500 		leaq	.LC2(%rip), %rsi
 596      000000
 597 030f 4889C7   		movq	%rax, %rdi
 598 0312 E8000000 		call	errPrefix@PLT
 598      00
 599 0317 C745DC03 		movl	$3, -36(%rbp)
 599      000000
 600 031e E9F90000 		jmp	.L21
 600      00
 601              	.L24:
 132:spi.c         **** 
 133:spi.c         **** 	// You have to report it as 512 bytes, but make sure you never try to do a
 134:spi.c         **** 	// packet larger than 64.
 135:spi.c         **** 	// http://permalink.gmane.org/gmane.comp.lib.libusbx.devel/1312
 136:spi.c         **** 	//
 137:spi.c         **** 	while ( count >= 64 ) {
 138:spi.c         **** 		uStatus = usbBulkRead(
 139:spi.c         **** 			handle->device,
 140:spi.c         **** 			handle->progInEP,  // read from IN endpoint
 602              		.loc 2 140 0 is_stmt 1
 603 0323 488B45C8 		movq	-56(%rbp), %rax
 604 0327 0FB64016 		movzbl	22(%rax), %eax
 138:spi.c         **** 			handle->device,
 605              		.loc 2 138 0
 606 032b 0FB6F0   		movzbl	%al, %esi
 607 032e 488B45C8 		movq	-56(%rbp), %rax
 608 0332 488B00   		movq	(%rax), %rax
 609 0335 488B4DB0 		movq	-80(%rbp), %rcx
 610 0339 488B55E8 		movq	-24(%rbp), %rdx
 611 033d 4989C9   		movq	%rcx, %r9
 612 0340 41B8FFFF 		movl	$-1, %r8d
 612      FFFF
 613 0346 B9400000 		movl	$64, %ecx
 613      00
 614 034b 4889C7   		movq	%rax, %rdi
 615 034e E8000000 		call	usbBulkRead@PLT
 615      00
 616 0353 8945E4   		movl	%eax, -28(%rbp)
 141:spi.c         **** 			ptr,               // read into receive buffer
 142:spi.c         **** 			64,                // read this many bytes
 143:spi.c         **** 			U32MAX,            // timeout in milliseconds
 144:spi.c         **** 			error
 145:spi.c         **** 		);
 146:spi.c         **** 		CHECK_STATUS(uStatus, FL_USB_ERR, cleanup, "spiRecv()");
 617              		.loc 2 146 0
 618 0356 837DE400 		cmpl	$0, -28(%rbp)
 619 035a 741F     		je	.L23
 620              		.loc 2 146 0 is_stmt 0 discriminator 1
 621 035c 488B45B0 		movq	-80(%rbp), %rax
 622 0360 488D3500 		leaq	.LC3(%rip), %rsi
 622      000000
 623 0367 4889C7   		movq	%rax, %rdi
 624 036a E8000000 		call	errPrefix@PLT
 624      00
 625 036f C745DC02 		movl	$2, -36(%rbp)
 625      000000
 626 0376 E9A10000 		jmp	.L21
 626      00
 627              	.L23:
 147:spi.c         **** 		ptr += 64;
 628              		.loc 2 147 0 is_stmt 1
 629 037b 488345E8 		addq	$64, -24(%rbp)
 629      40
 148:spi.c         **** 		count -= 64;
 630              		.loc 2 148 0
 631 0380 836DE040 		subl	$64, -32(%rbp)
 632              	.L22:
 137:spi.c         **** 		uStatus = usbBulkRead(
 633              		.loc 2 137 0
 634 0384 837DE03F 		cmpl	$63, -32(%rbp)
 635 0388 7799     		ja	.L24
 149:spi.c         **** 	}
 150:spi.c         **** 	if ( count ) {
 636              		.loc 2 150 0
 637 038a 837DE000 		cmpl	$0, -32(%rbp)
 638 038e 7453     		je	.L25
 151:spi.c         **** 		uStatus = usbBulkRead(
 152:spi.c         **** 			handle->device,
 153:spi.c         **** 			handle->progInEP,  // read from IN endpoint
 639              		.loc 2 153 0
 640 0390 488B45C8 		movq	-56(%rbp), %rax
 641 0394 0FB64016 		movzbl	22(%rax), %eax
 151:spi.c         **** 		uStatus = usbBulkRead(
 642              		.loc 2 151 0
 643 0398 0FB6F0   		movzbl	%al, %esi
 644 039b 488B45C8 		movq	-56(%rbp), %rax
 645 039f 488B00   		movq	(%rax), %rax
 646 03a2 488B7DB0 		movq	-80(%rbp), %rdi
 647 03a6 8B4DE0   		movl	-32(%rbp), %ecx
 648 03a9 488B55E8 		movq	-24(%rbp), %rdx
 649 03ad 4989F9   		movq	%rdi, %r9
 650 03b0 41B8FFFF 		movl	$-1, %r8d
 650      FFFF
 651 03b6 4889C7   		movq	%rax, %rdi
 652 03b9 E8000000 		call	usbBulkRead@PLT
 652      00
 653 03be 8945E4   		movl	%eax, -28(%rbp)
 154:spi.c         **** 			ptr,               // read into receive buffer
 155:spi.c         **** 			count,             // read this many bytes
 156:spi.c         **** 			U32MAX,            // timeout in milliseconds
 157:spi.c         **** 			error
 158:spi.c         **** 		);
 159:spi.c         **** 		CHECK_STATUS(uStatus, FL_USB_ERR, cleanup, "spiRecv()");
 654              		.loc 2 159 0
 655 03c1 837DE400 		cmpl	$0, -28(%rbp)
 656 03c5 741C     		je	.L25
 657              		.loc 2 159 0 is_stmt 0 discriminator 1
 658 03c7 488B45B0 		movq	-80(%rbp), %rax
 659 03cb 488D3500 		leaq	.LC3(%rip), %rsi
 659      000000
 660 03d2 4889C7   		movq	%rax, %rdi
 661 03d5 E8000000 		call	errPrefix@PLT
 661      00
 662 03da C745DC02 		movl	$2, -36(%rbp)
 662      000000
 663 03e1 EB39     		jmp	.L21
 664              	.L25:
 160:spi.c         **** 	}
 161:spi.c         **** 
 162:spi.c         **** 	// Maybe bitswap the data
 163:spi.c         **** 	if ( bitOrder == SPI_MSBFIRST ) {
 665              		.loc 2 163 0 is_stmt 1
 666 03e3 807DC000 		cmpb	$0, -64(%rbp)
 667 03e7 7532     		jne	.L30
 164:spi.c         **** 		while ( length-- ) {
 668              		.loc 2 164 0
 669 03e9 EB23     		jmp	.L26
 670              	.L27:
 165:spi.c         **** 			*buf = swapTable[*buf];
 671              		.loc 2 165 0
 672 03eb 488B45B8 		movq	-72(%rbp), %rax
 673 03ef 0FB600   		movzbl	(%rax), %eax
 674 03f2 0FB6C0   		movzbl	%al, %eax
 675 03f5 4863D0   		movslq	%eax, %rdx
 676 03f8 488D0500 		leaq	swapTable(%rip), %rax
 676      000000
 677 03ff 0FB61402 		movzbl	(%rdx,%rax), %edx
 678 0403 488B45B8 		movq	-72(%rbp), %rax
 679 0407 8810     		movb	%dl, (%rax)
 166:spi.c         **** 			buf++;
 680              		.loc 2 166 0
 681 0409 488345B8 		addq	$1, -72(%rbp)
 681      01
 682              	.L26:
 164:spi.c         **** 		while ( length-- ) {
 683              		.loc 2 164 0
 684 040e 8B45C4   		movl	-60(%rbp), %eax
 685 0411 8D50FF   		leal	-1(%rax), %edx
 686 0414 8955C4   		movl	%edx, -60(%rbp)
 687 0417 85C0     		testl	%eax, %eax
 688 0419 75D0     		jne	.L27
 689              	.L30:
 167:spi.c         **** 		}
 168:spi.c         **** 	}
 169:spi.c         **** cleanup:
 690              		.loc 2 169 0
 691 041b 90       		nop
 692              	.L21:
 170:spi.c         **** 	return retVal;
 693              		.loc 2 170 0
 694 041c 8B45DC   		movl	-36(%rbp), %eax
 171:spi.c         **** }
 695              		.loc 2 171 0
 696 041f 488B4DF8 		movq	-8(%rbp), %rcx
 697 0423 6448330C 		xorq	%fs:40, %rcx
 697      25280000 
 697      00
 698 042c 7405     		je	.L29
 699 042e E8000000 		call	__stack_chk_fail@PLT
 699      00
 700              	.L29:
 701 0433 C9       		leave
 702              		.cfi_def_cfa 7, 8
 703 0434 C3       		ret
 704              		.cfi_endproc
 705              	.LFE6:
 707              	.Letext0:
 708              		.file 3 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
 709              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 710              		.file 5 "/usr/include/libio.h"
 711              		.file 6 "/usr/include/stdio.h"
 712              		.file 7 "/home/gani/eval/20140524/makestuff/libs/libusbwrap/libusbwrap.h"
 713              		.file 8 "libfpgalink.h"
 714              		.file 9 "firmware.h"
 715              		.file 10 "private.h"
 716              		.file 11 "vendorCommands.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 spi.c
     /tmp/cc5BcdOo.s:5      .text:0000000000000000 littleEndian32
     /tmp/cc5BcdOo.s:29     .rodata:0000000000000000 swapTable
     /tmp/cc5BcdOo.s:289    .text:000000000000000c spiBitSwap
     /tmp/cc5BcdOo.s:339    .text:000000000000004c spiSend
     /tmp/cc5BcdOo.s:543    .text:0000000000000274 spiRecv

UNDEFINED SYMBOLS
_GLOBAL_OFFSET_TABLE_
malloc
errPrefix
usbControlWrite
usbBulkWrite
free
__stack_chk_fail
usbBulkRead
